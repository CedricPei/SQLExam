[
  {
    "question_id": 470,
    "db_id": "card_games",
    "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
    "predicted_sql": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Ancestor''s Chosen'",
    "gold_sql": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
    "reason_1": "",
    "reason_2": "No distinct"
  },
  {
    "question_id": 215,
    "db_id": "toxicology",
    "question": "How many atoms with iodine and with sulfur type elements are there in single bond molecules?",
    "predicted_sql": "SELECT COUNT(DISTINCT CASE WHEN a.element = 'i' THEN a.atom_id END) + COUNT(DISTINCT CASE WHEN a.element = 's' THEN a.atom_id END) AS total_iodine_sulfur_atoms FROM atom a JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '-'",
    "gold_sql": "SELECT COUNT(DISTINCT CASE WHEN T1.element = 'i' THEN T1.atom_id ELSE NULL END) AS iodine_nums , COUNT(DISTINCT CASE WHEN T1.element = 's' THEN T1.atom_id ELSE NULL END) AS sulfur_nums FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '-'",
    "reason_1": "",
    "reason_2": "FALSE GOLD. Not correct in where atom_id and atom_id2."
  },
  {
    "question_id": 281,
    "db_id": "toxicology",
    "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
    "predicted_sql": "SELECT atom.element, COUNT(*) FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.label = '+' AND SUBSTRING(atom.atom_id, 7, 1) = '4' GROUP BY atom.element",
    "gold_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
    "reason_1": "GOLD FALSE",
    "reason_2": "extra 'na'"
  },
  {
    "question_id": 177,
    "db_id": "financial",
    "question": "What is the sum that client number 4's account has following transaction 851? Who owns this account, a man or a woman?",
    "predicted_sql": "SELECT SUM(trans.balance) AS sum_balance, client.gender FROM trans INNER JOIN disp ON trans.account_id = disp.account_id INNER JOIN client ON disp.client_id = client.client_id WHERE disp.client_id = 4 AND trans.trans_id > 851",
    "gold_sql": "SELECT T4.balance, T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id =T3.account_id INNER JOIN trans AS T4 ON T3.account_id = T4.account_id WHERE T1.client_id = 4 AND T4.trans_id = 851",
    "reason_1": "trans.trans_id > 851;  no GROUP BY",
    "reason_2": "the condition is wrong. trans_id > 851."
  },
  {
    "question_id": 80,
    "db_id": "california_schools",
    "question": "What is the school type of the school with the highest latitude? Indicate the name of the school as well as the latitude coordinates.",
    "predicted_sql": "SELECT SOCType, School, Latitude FROM schools ORDER BY Latitude DESC LIMIT 1",
    "gold_sql": "SELECT T1.`School Type`, T1.`School Name`, T2.Latitude FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Latitude = (SELECT MAX(Latitude) FROM schools)",
    "reason_1": "",
    "reason_2": "There are 2 highest schools with the same latitude."
  },
  {
    "question_id": 326,
    "db_id": "toxicology",
    "question": "Which molecule consisted of Sulphur atom with double bond?",
    "predicted_sql": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 's' AND T3.bond_type = '='",
    "gold_sql": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='",
    "reason_1": "use the connect, mislead the meaning.",
    "reason_2": "ground truth false"
  },
  {
    "question_id": 220,
    "db_id": "toxicology",
    "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
    "predicted_sql": "SELECT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element LIMIT 3",
    "gold_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
    "reason_1": "do not use distinct",
    "reason_2": "The sqls are same."
  },
  {
    "question_id": 1090,
    "db_id": "european_football_2",
    "question": "What is the long passing score of the oldest player?",
    "predicted_sql": "SELECT t2.long_passing FROM player AS t1 INNER JOIN player_attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.birthday = (SELECT MIN(birthday) FROM player) LIMIT 1",
    "gold_sql": "SELECT T2.long_passing FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.birthday = (SELECT MIN(birthday) FROM Player)",
    "reason_1": "",
    "reason_2": "wrong limit 1"
  },
  {
    "question_id": 1013,
    "db_id": "formula_1",
    "question": "What is the lap record for the Austrian Grand Prix Circuit?",
    "predicted_sql": "SELECT MIN(lt.time) FROM laptimes lt JOIN races r ON lt.raceId = r.raceId WHERE r.name = 'Austrian Grand Prix'",
    "gold_sql": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.fastestLapTime FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL) SELECT MIN(fastest_lap_times.fastestLapTime) as lap_record FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix'",
    "reason_1": "",
    "reason_2": "Austrian Grand Prix is not a circuit"
  },
  {
    "question_id": 447,
    "db_id": "card_games",
    "question": "Give the code of sets have expansion commander type?",
    "predicted_sql": "SELECT code FROM sets WHERE type = 'commander'",
    "gold_sql": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
    "reason_1": "",
    "reason_2": "evidence ask to refer to sekcode"
  },
  {
    "question_id": 646,
    "db_id": "codebase_community",
    "question": "Describe the post title which got positive comments and display names of the users who posted those comments.",
    "predicted_sql": "SELECT T2.Title, T1.UserDisplayName FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T1.Score > 60",
    "gold_sql": "SELECT T1.Title, T2.UserDisplayName FROM posts AS T1 INNER JOIN comments AS T2 ON T2.PostId = T2.Id WHERE T1.Score > 60",
    "reason_1": "",
    "reason_2": "FALSE GOLD. T2.postid=T2.ID is meaningless"
  },
  {
    "question_id": 962,
    "db_id": "formula_1",
    "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
    "predicted_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN strftime('%Y', T1.dob) < '1985' AND T2.laps > 50 THEN T2.driverId END) AS REAL) * 100 / COUNT(DISTINCT T2.driverId) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.year BETWEEN 2000 AND 2005",
    "gold_sql": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
    "reason_1": "",
    "reason_2": "wrong aggregation"
  },
  {
    "question_id": 984,
    "db_id": "formula_1",
    "question": "What is the website of the constructor who tallied the most total wins.",
    "predicted_sql": "SELECT c.url FROM constructors c JOIN constructorstandings cs ON c.constructorid = cs.constructorid GROUP BY c.constructorid ORDER BY SUM(cs.wins) DESC LIMIT 1",
    "gold_sql": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1",
    "reason_1": "",
    "reason_2": "wrong aggregation in condition"
  },
  {
    "question_id": 1391,
    "db_id": "student_club",
    "question": "What is the ratio between students majored in finance and physics?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T1.major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.major_name = 'Physics' THEN 1 ELSE 0 END) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major",
    "gold_sql": "SELECT SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) / SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END) AS ratio FROM major",
    "reason_1": "",
    "reason_2": "GOLD FALSE"
  },
  {
    "question_id": 1389,
    "db_id": "student_club",
    "question": "Which event has the lowest cost?",
    "predicted_sql": "SELECT T3.event_name FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget INNER JOIN event AS T3 ON T1.link_to_event = T3.event_id ORDER BY T2.cost ASC LIMIT 1",
    "gold_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.cost = (SELECT MIN(T6.cost) FROM event AS T4 INNER JOIN budget AS T5 ON T4.event_id = T5.link_to_event INNER JOIN expense AS T6 ON T5.budget_id = T6.link_to_budget)",
    "reason_1": "",
    "reason_2": "There are more than one lowest value candidates"
  },
  {
    "question_id": 1441,
    "db_id": "student_club",
    "question": "How many members have education major in the College of Education & Human Services?",
    "predicted_sql": "SELECT COUNT(member_id) FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE major_name = 'education' AND college = 'College of Education & Human Services' AND position = 'Member'",
    "gold_sql": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member' AND T2.major_name LIKE '%Education%' AND T2.college = 'College of Education & Human Services'",
    "reason_1": "Error major value",
    "reason_2": "need approximate condition"
  },
  {
    "question_id": 1068,
    "db_id": "european_football_2",
    "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
    "predicted_sql": "SELECT AVG(T2.overall_rating) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height > 170 AND STRFTIME('%Y', T2.`date`) BETWEEN '2010' AND '2015'",
    "gold_sql": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
    "reason_1": "",
    "reason_2": "wrong formula"
  },
  {
    "question_id": 77,
    "db_id": "california_schools",
    "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
    "predicted_sql": "SELECT schools.School, frpm.`Percent (%) Eligible FRPM (Ages 5-17)` FROM schools INNER JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.GSserved = 'K-9' AND schools.County = 'Los Angeles';",
    "gold_sql": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
    "reason_1": "",
    "reason_2": "forgot to * 100"
  },
  {
    "question_id": 892,
    "db_id": "formula_1",
    "question": "State the driver with the most points scored. Find his full name with that points.",
    "predicted_sql": "SELECT drivers.forename, drivers.surname, SUM(results.points) AS total_points FROM results INNER JOIN drivers ON results.driverid = drivers.driverid GROUP BY drivers.driverid ORDER BY total_points DESC LIMIT 1",
    "gold_sql": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
    "reason_1": "",
    "reason_2": "wrong table, results and races"
  },
  {
    "question_id": 257,
    "db_id": "toxicology",
    "question": "List down atom id2 for atoms with element sulfur.",
    "predicted_sql": "SELECT atom_id2 FROM connected JOIN atom ON connected.atom_id = atom.atom_id WHERE atom.element = 's'",
    "gold_sql": "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'",
    "reason_1": "",
    "reason_2": "wrong table"
  },
  {
    "question_id": 1092,
    "db_id": "european_football_2",
    "question": "Give the name of the league had the most matches in the 2008/2009 season?",
    "predicted_sql": "SELECT L.name AS league_name FROM Match M JOIN League L ON M.league_id = L.id WHERE M.season = '2008/2009' GROUP BY L.name ORDER BY COUNT(M.id) DESC LIMIT 1",
    "gold_sql": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
    "reason_1": "",
    "reason_2": "there are more than 1 top"
  },
  {
    "question_id": 1214,
    "db_id": "thrombosis_prediction",
    "question": "List ID, sex and date of birth of patient whose total protein (TP) below the lower range of the normal index.",
    "predicted_sql": "SELECT Patient.ID, Patient.SEX, Patient.Birthday FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.TP < 6.0",
    "gold_sql": "SELECT DISTINCT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TP < 6.0",
    "reason_1": "",
    "reason_2": ""
  },
  {
    "question_id": 49,
    "db_id": "california_schools",
    "question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
    "predicted_sql": "SELECT T1.County, T1.School, T1.ClosedDate FROM schools T1 WHERE T1.StatusType = 'Closed' AND T1.County = (SELECT T2.County FROM schools T2 WHERE T2.StatusType = 'Closed' GROUP BY T2.County ORDER BY COUNT(*) DESC LIMIT 1)",
    "gold_sql": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Closed' AND school IS NOT NULL",
    "reason_1": "",
    "reason_2": "should use distinct"
  },
  {
    "question_id": 1174,
    "db_id": "thrombosis_prediction",
    "question": "What is the average age of patients as of year 1999 examined in the laboratory for the October of the year 1991?",
    "predicted_sql": "SELECT AVG(1999 - STRFTIME('%Y', patient.birthday)) AS averageage FROM patient INNER JOIN laboratory ON patient.id = laboratory.id WHERE laboratory.date BETWEEN '1991-10-01' AND '1991-10-31'",
    "gold_sql": "SELECT AVG('1999'  - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
    "reason_1": "precision error I think",
    "reason_2": "1991-10-31 false"
  },
  {
    "question_id": 1514,
    "db_id": "debit_card_specializing",
    "question": "What kind of currency did the customer paid at 16:25:00 in 2012/8/24?",
    "predicted_sql": "SELECT T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '2012-08-24' AND T2.Time = '16:25:00'",
    "gold_sql": "SELECT DISTINCT T3.Currency FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T1.Date = '2012-08-24' AND T1.Time = '16:25:00'",
    "reason_1": "",
    "reason_2": "Missing  DISTINCT"
  },
  {
    "question_id": 406,
    "db_id": "card_games",
    "question": "Lists by ID all Creature-type cards with legal status.",
    "predicted_sql": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.types = 'Creature' AND T2.status = 'Legal'",
    "gold_sql": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
    "reason_1": "",
    "reason_2": "INNER JOIN rulings"
  },
  {
    "question_id": 978,
    "db_id": "formula_1",
    "question": "How many times the circuits were held in Austria? Please give their location and coordinates.",
    "predicted_sql": "SELECT COUNT(T1.location), T1.location, T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.country = 'Austria' GROUP BY T1.location, T1.lat, T1.lng",
    "gold_sql": "SELECT DISTINCT location, lat, lng FROM circuits WHERE country = 'Austria'",
    "reason_1": "",
    "reason_2": "Missing COUNT"
  },
  {
    "question_id": 186,
    "db_id": "financial",
    "question": "What percentage of male clients request for weekly statements to be issued?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN c.gender = 'M' THEN 1 ELSE 0 END) AS REAL) / COUNT(c.client_id) * 100 AS percentage_of_male_clients_requesting_weekly_statements FROM client c JOIN account a ON c.district_id = a.district_id WHERE a.frequency = 'POPLATEK TYDNE'",
    "gold_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
    "reason_1": "",
    "reason_2": "No transition JOIN link through intermediate table"
  },
  {
    "question_id": 849,
    "db_id": "formula_1",
    "question": "Where can the introduction of the races held on Circuit de Barcelona-Catalunya be found?",
    "predicted_sql": "SELECT races.url FROM races INNER JOIN circuits ON races.circuitid = circuits.circuitid WHERE circuits.name = 'Circuit de Barcelona-Catalunya'",
    "gold_sql": "SELECT DISTINCT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T1.name = 'Circuit de Barcelona-Catalunya'",
    "reason_1": "",
    "reason_2": "GOLD FALSE. Gold SQL returns circuits.url, but the question requires races.url"
  },
  {
    "question_id": 46,
    "db_id": "california_schools",
    "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
    "predicted_sql": "SELECT s.school, f.\"Enrollment (K-12)\" FROM frpm AS f INNER JOIN schools AS s ON f.cdscode = s.cdscode WHERE s.doc = '31' AND (s.eilcode = 'ELEMHIGH' OR s.eilcode = 'K-12') ORDER BY f.\"Enrollment (K-12)\" DESC LIMIT 1",
    "gold_sql": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
    "reason_1": "",
    "reason_2": "S.elcode = 'ELEMHIGH' is not mentioned in the question and may lead to incorrect results."
  },
  {
    "question_id": 520,
    "db_id": "card_games",
    "question": "Who is the illustrator that illustrated the least amount of cards? List the format of play of the cards that he/she illustrated.",
    "predicted_sql": "SELECT l.format FROM cards c JOIN legalities l ON c.uuid = l.uuid GROUP BY c.artist ORDER BY COUNT(c.id) ASC LIMIT 1",
    "gold_sql": "SELECT T1.artist, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid GROUP BY T1.artist ORDER BY COUNT(T1.id) ASC LIMIT 1",
    "reason_1": "",
    "reason_2": "Predicted SQLdo not mention who is the illustrator that illustrated the least amount of cards"
  },
  {
    "question_id": 1403,
    "db_id": "student_club",
    "question": "Indicate the name of the closed event whose cost has exceeded the budget the most.",
    "predicted_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.status = 'Closed' ORDER BY T2.remaining ASC LIMIT 1",
    "gold_sql": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event WHERE T1.event_status = 'Closed' AND T1.remaining < 0 ORDER BY T1.remaining LIMIT 1",
    "reason_1": "",
    "reason_2": "Predicted SQL does not reflect cost has exceeded the budget, that is, remaining < 0"
  },
  {
    "question_id": 1243,
    "db_id": "thrombosis_prediction",
    "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN Patient.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE strftime('%Y', current_timestamp) - strftime('%Y', Patient.Birthday) > 55 AND Laboratory.PT >= 14",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
    "reason_1": "Error WHERE condition",
    "reason_2": "The predicted SQL computes the percentage of females among abnormal-PT patients older than 55[(F&pt>14&age>55)/(F&age>55)], while the gold SQL computes the percentage of all patients older than 55 who are both female and abnormal-PT[(F&pt>14&age>55)/(age>55)]."
  },
  {
    "question_id": 82,
    "db_id": "california_schools",
    "question": "What is the grade span offered in the school with the highest longitude?",
    "predicted_sql": "SELECT GSoffered FROM schools ORDER BY ABS(Longitude) DESC LIMIT 1",
    "gold_sql": "SELECT GSoffered FROM schools WHERE ABS(longitude) = (SELECT MAX(ABS(longitude)) FROM schools)",
    "reason_1": "",
    "reason_2": "If there are the same longitude schools, using LIMIT 1 might not be strict."
  },
  {
    "question_id": 736,
    "db_id": "superhero",
    "question": "Who is the dumbest superhero?",
    "predicted_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' AND T2.attribute_value IS NOT NULL ORDER BY T2.attribute_value ASC LIMIT 1",
    "gold_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' AND T2.attribute_value = (SELECT MIN(T4.attribute_value) FROM hero_attribute AS T4 INNER JOIN attribute AS T5 ON T4.attribute_id = T5.id WHERE T5.attribute_name = 'Intelligence')",
    "reason_1": "",
    "reason_2": "There are multiple dumbest Superheroes, and using LIMIT 1 is not strict."
  },
  {
    "question_id": 391,
    "db_id": "card_games",
    "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
    "predicted_sql": "SELECT cards.name, foreign_data.language FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.originalType LIKE '%Artifact%' AND cards.colors LIKE '%B%' AND foreign_data.language != ''",
    "gold_sql": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
    "reason_1": "",
    "reason_2": "GOLD FALSE. Predicted SQL FALSE.gold sql  should add  foreign_data.language ! = null, Predicted SQL using cards.colors LIKE '%B%' causes color filtering errors and may also result in \"blue\"."
  },
  {
    "question_id": 189,
    "db_id": "financial",
    "question": "Name the account numbers of female clients who are oldest and have lowest average salary?",
    "predicted_sql": "SELECT account.account_id FROM account INNER JOIN disp ON account.account_id = disp.account_id INNER JOIN client ON disp.client_id = client.client_id INNER JOIN district ON client.district_id = district.district_id WHERE client.gender = 'F' AND client.birth_date IS NOT NULL AND district.A11 IS NOT NULL ORDER BY client.birth_date ASC, district.A11 ASC LIMIT 1",
    "gold_sql": "SELECT T3.account_id FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN account AS T3 ON T2.district_id = T3.district_id WHERE T1.gender = 'F' AND T1.birth_date = (SELECT MIN(birth_date) FROM client WHERE gender = 'F') AND T2.A11 = (SELECT MIN(T2.A11) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T1.birth_date = (SELECT MIN(birth_date) FROM client WHERE gender = 'F'))",
    "reason_1": "",
    "reason_2": "When not a single piece of data meets the conditions, using LIMIT 1 is not rigorous"
  },
  {
    "question_id": 619,
    "db_id": "codebase_community",
    "question": "How many adults who obtained the badge Supporter?",
    "predicted_sql": "SELECT COUNT(DISTINCT u.Id) FROM badges b JOIN users u ON b.UserId = u.Id WHERE b.Name = 'Supporter' AND u.Age BETWEEN 19 AND 65",
    "gold_sql": "SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Supporter' AND T1.Age BETWEEN 19 AND 65",
    "reason_1": "",
    "reason_2": "GOLD FALSE. Predicted SQL TRUE. Gold sql does not use DISTINCT and may return a larger value."
  },
  {
    "question_id": 271,
    "db_id": "toxicology",
    "question": "Does bond id TR001_1_8 have both element of chlorine and carbon?",
    "predicted_sql": "SELECT CASE WHEN COUNT(DISTINCT CASE WHEN T2.element IN ('cl', 'c') THEN T2.element END) = 2 THEN 'yes' ELSE 'no' END AS has_both FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id  WHERE T1.bond_id = 'TR001_1_8'",
    "gold_sql": "SELECT T2.bond_id, T2.atom_id2, T1.element AS flag_have_CaCl FROM atom AS T1 INNER JOIN connected AS T2 ON T2.atom_id = T1.atom_id WHERE T2.bond_id = 'TR001_1_8' AND (T1.element = 'c1' OR T1.element = 'c')",
    "reason_1": "",
    "reason_2": "GOLD FALSE.Predicted  TRUE. Gold sql does not meet the condition of \"both element of chlorine and carbon\", but only meets one condition."
  },
  {
    "question_id": 1152,
    "db_id": "thrombosis_prediction",
    "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
    "predicted_sql": "SELECT CAST(COUNT(CASE WHEN Admission = '-' THEN 1 END) AS REAL) / COUNT(CASE WHEN Admission = '+' THEN 1 END) AS outpatient_to_inpatient_ratio FROM Patient WHERE Diagnosis = 'SLE'",
    "gold_sql": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
    "reason_1": "GOLD FALSE: The question is asking for the ratio of outpatient to inpatient, so should use DIVIDE(COUNT(ID) where Diagnosis = 'SLE' and Admission = '-', COUNT(ID) where Diagnosis = 'SLE' and Admission = '+'). The provided evicence is also wrong here.",
    "reason_2": "GOLD FALSE. The numerator should be Admission = '-', that is, outpatient."
  },
  {
    "question_id": 1525,
    "db_id": "debit_card_specializing",
    "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
    "predicted_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.Currency = 'EUR' THEN T2.CustomerID END) AS REAL) * 100.0 / COUNT(DISTINCT T2.CustomerID) FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '2012-08-25'",
    "gold_sql": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
    "reason_1": "Predicted SQL incorrectly measures customers’ default currency (customer-based ratio) instead of transactions’ actual currency usage (transaction-based ratio).",
    "reason_2": "GOLD FALSE: Since the question is asking for the percentage of customers rather than the percentage of transactions, so should use DISTINCT CustomerID"
  },
  {
    "question_id": 1419,
    "db_id": "student_club",
    "question": "What is the category of event which was taken place in 2020-03-24T12:00:00?",
    "predicted_sql": "SELECT type FROM event WHERE event_date = '2020-03-24T12:00:00'",
    "gold_sql": "SELECT T2.category FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_date = '2020-03-24T12:00:00'",
    "reason_1": "GOLD FALSE. Check that the type of the event is indeed type, not category in the budget table. The category in budget is the type of budget.",
    "reason_2": "GOLD FALSE: The column budget.category is the category of the budget rather than the event. The question should state which column means the category of event (Ambiguous question)"
  },
  {
    "question_id": 365,
    "db_id": "card_games",
    "question": "What is the type of card \"Benalish Knight\"?",
    "predicted_sql": "SELECT type FROM cards WHERE name = 'Benalish Knight'",
    "gold_sql": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
    "reason_1": "GOLD FALSE: should not use foreign_data.name as filter condition",
    "reason_2": "GOLD FALSE. Predicted SQL is correct. gold sql filters foreign_data, which is completely unnecessary and cannot meet the requirements of the question under certain conditions."
  },
  {
    "question_id": 102,
    "db_id": "financial",
    "question": "State different accounts who have account opening date before 1997 and own an amount of money greater than 3000USD",
    "predicted_sql": "SELECT DISTINCT T1.account_id FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T1.date < '1997-01-01' AND T2.balance > 3000",
    "gold_sql": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) < '1997' AND T1.amount > 3000",
    "reason_1": "GOLD FALSE: the gold SQL uses trans.amount>3000 as the filter condition, which means the amount in a specific transaction. However, the question is asking for accounts own an amount of money greater than 3000USD, which in fact corresponding to the trans.balance column, which reflects the latest balance of the account",
    "reason_2": "GOLD FALSE. amount represents the transaction amount, and balance is the balance after the transaction."
  },
  {
    "question_id": 649,
    "db_id": "codebase_community",
    "question": "Describe the post history counts and last edit date of the post title \"What is the best introductory Bayesian statistics textbook?\"",
    "predicted_sql": "SELECT COUNT(T2.Id), T1.LastEditDate FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'What is the best introductory Bayesian statistics textbook?'",
    "gold_sql": "SELECT T1.Id, T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'",
    "reason_1": "GOLD FALSE: Should return the post history counts",
    "reason_2": "GOLD FALSE. The question requires a historical count, while gold sql returns the id of each edit"
  },
  {
    "question_id": 516,
    "db_id": "card_games",
    "question": "How many cards did Volkan BaÇµa illustrated whose foreign language is in French?",
    "predicted_sql": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Volkan Baǵa' AND T2.language = 'French'",
    "gold_sql": "SELECT COUNT(T3.id) FROM ( SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Baǵa' AND T2.language = 'French' GROUP BY T1.id ) AS T3",
    "reason_1": "",
    "reason_2": "no group by"
  },
  {
    "question_id": 652,
    "db_id": "codebase_community",
    "question": "List the post IDs and badge names of the user Samuel in 2013.",
    "predicted_sql": "SELECT DISTINCT posts.Id, badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id INNER JOIN posts ON users.Id = posts.OwnerUserId WHERE users.DisplayName = 'Samuel' AND strftime('%Y', badges.Date) = '2013' AND strftime('%Y', posts.CreaionDate) = '2013'",
    "gold_sql": "SELECT T1.PostId, T2.Name FROM postHistory AS T1 INNER JOIN badges AS T2 ON T1.UserId = T2.UserId WHERE T1.UserDisplayName = 'Samuel' AND STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'",
    "reason_1": "GOLD FALSE: Should use the posts table rather than the postHistory table for filtering, should use DISTINCT to remove duplicates",
    "reason_2": "maybe have different names in the past"
  },
  {
    "question_id": 1283,
    "db_id": "thrombosis_prediction",
    "question": "For the patients with the normal glutamic pylvic transaminase level, how many of them are male?",
    "predicted_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT < 60 AND T1.SEX = 'M'",
    "gold_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
    "reason_1": "Predicted SQL uses T2.GPT < 60, and T2.GOT < 60 should be used instead",
    "reason_2": "GOLD FALSE: Wrong evidence. According to the real database schema, glutamic pyruvic transaminase corresponds to the Laboratory.GPT column, so the predicted SQL is right."
  },
  {
    "question_id": 427,
    "db_id": "card_games",
    "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
    "predicted_sql": "SELECT set_translations.language FROM set_translations WHERE set_translations.setCode = 'ARC';",
    "gold_sql": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
    "reason_1": "",
    "reason_2": "Predicted SQL does not use the filter condition mcmName = 'Archenemy'"
  },
  {
    "question_id": 1457,
    "db_id": "student_club",
    "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
    "predicted_sql": "SELECT T1.first_name, T1.last_name, T1.phone FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.first_name, T1.last_name, T1.phone HAVING SUM(T2.cost) > (SELECT AVG(cost) FROM expense)",
    "gold_sql": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
    "reason_1": "",
    "reason_2": "False Positive: wrong filter condition"
  },
  {
    "question_id": 259,
    "db_id": "toxicology",
    "question": "How many elements are there for single bond molecules?",
    "predicted_sql": "SELECT COUNT(DISTINCT atom.element) AS element_count FROM bond INNER JOIN connected ON bond.bond_id = connected.bond_id INNER JOIN atom ON connected.atom_id = atom.atom_id WHERE bond.bond_type = '-'",
    "gold_sql": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
    "reason_1": "GOLD FALSE: Wrong JOIN logic, all atoms in any molecule containing single bonds will be counted.",
    "reason_2": "Predicted SQL does not perform screening at the molecule level."
  },
  {
    "question_id": 710,
    "db_id": "codebase_community",
    "question": "In posts with 1 comment, how many of the comments have 0 score?",
    "predicted_sql": "SELECT COUNT(*) FROM comments WHERE PostId IN (SELECT Id FROM posts WHERE CommentCount = 1) AND Score = 0",
    "gold_sql": "SELECT COUNT(T1.id) FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.CommentCount = 1 AND T2.Score = 0",
    "reason_1": "GOLD FALSE. gold sql calculates the number of posts with a score of 0, but the question requires the number of comments with a score of 0",
    "reason_2": "GOLD FALSE: Since the question is asking for how many of the comments have 0 score, so the filter condition should be comments.Score=0 rather than posts.Score = 0"
  },
  {
    "question_id": 1006,
    "db_id": "formula_1",
    "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
    "predicted_sql": "SELECT lapTimes.time FROM lapTimes ORDER BY lapTimes.time ASC LIMIT 1;",
    "gold_sql": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
    "reason_1": "Predict SQL should transform the lapTimes.time to milliseconds, or just use the lapTimes.milliseconds column\nGOLD FALSE: Wrong Calculation, the correct result should be 1:07.411",
    "reason_2": "string ordering"
  },
  {
    "question_id": 525,
    "db_id": "card_games",
    "question": "Find the uuid of cards in which the old school format is restricted or banned.",
    "predicted_sql": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND status IN ('banned', 'restricted')",
    "gold_sql": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')",
    "reason_1": "It should be correct in a case-insensitive database",
    "reason_2": "Wrong evidence and database schema provided, leading to wrong prediction"
  },
  {
    "question_id": 1318,
    "db_id": "student_club",
    "question": "What is the event that has the highest attendance of the students from the Student_Club?",
    "predicted_sql": "SELECT event.event_name FROM attendance INNER JOIN member ON attendance.link_to_member = member.member_id INNER JOIN event ON attendance.link_to_event = event.event_id GROUP BY attendance.link_to_event, event.event_name ORDER BY COUNT(member.member_id) DESC LIMIT 1",
    "gold_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event GROUP BY T1.event_name HAVING COUNT(T2.link_to_event) = (SELECT MAX(attendance_count) FROM (SELECT COUNT(link_to_event) AS attendance_count FROM attendance GROUP BY link_to_event) AS subquery)",
    "reason_1": "",
    "reason_2": "Using LIMIT 1 cann't handle cases where more than one event should return"
  },
  {
    "question_id": 1501,
    "db_id": "debit_card_specializing",
    "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
    "predicted_sql": "SELECT DISTINCT gasstations.Country FROM transactions_1k JOIN gasstations ON transactions_1k.GasStationID = gasstations.GasStationID WHERE strftime('%Y%m', transactions_1k.Date) = '201306';",
    "gold_sql": "SELECT DISTINCT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Date = '201306'",
    "reason_1": "GOLD FALSE: Filter date on the wrong table and column",
    "reason_2": "Predicted SQL does not filter data with the dates specified in the table yearmonth."
  },
  {
    "question_id": 1512,
    "db_id": "debit_card_specializing",
    "question": "Which customer paid the most in 2012/8/25?",
    "predicted_sql": "SELECT \"transactions_1k\".\"CustomerID\" FROM \"transactions_1k\" WHERE \"transactions_1k\".\"Date\" = '2012-08-25' GROUP BY \"transactions_1k\".\"CustomerID\" ORDER BY SUM(\"transactions_1k\".\"Amount\" * \"transactions_1k\".\"Price\") DESC LIMIT 1",
    "gold_sql": "SELECT CustomerID FROM transactions_1k WHERE Date = '2012-08-25' GROUP BY CustomerID ORDER BY SUM(Price) DESC LIMIT 1",
    "reason_1": "GOLD FALSE: total price = Amount x Price, so should use ORDER BY SUM(\"transactions_1k\".\"Amount\" * \"transactions_1k\".\"Price\")",
    "reason_2": "GOLD FALSE. the gold SQL treats Price as the total payment per transaction and sums it directly.However, \"price\" refers to the unit price rather than the total amount."
  },
  {
    "question_id": 603,
    "db_id": "codebase_community",
    "question": "What is the sum of favourite count gained by user ID 686 in 2011?",
    "predicted_sql": "SELECT SUM(FavoriteCount) FROM posts WHERE OwnerUserId = 686 AND strftime('%Y', CreaionDate) = '2011'",
    "gold_sql": "SELECT SUM(DISTINCT FavoriteCount) FROM posts WHERE Id IN ( SELECT PostId FROM postHistory WHERE UserId = 686 AND STRFTIME('%Y', CreationDate) = '2011' )",
    "reason_1": "If the question only tests the posts created by the user, it is correct. gold sql counts the posts that the user has modified.",
    "reason_2": "GOLD FALSE: Using postHistory.UserId will count the posts where user 686 just updated the post. In addition, using distinct in the sum function will filter out the posts with the same favorite count"
  },
  {
    "question_id": 528,
    "db_id": "card_games",
    "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
    "predicted_sql": "SELECT cards.name, legalities.format FROM cards INNER JOIN sets ON cards.setCode = sets.code INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE sets.name = 'Hour of Devastation' AND legalities.status = 'Legal'",
    "gold_sql": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
    "reason_1": "",
    "reason_2": "Should not use legalities.status = 'Legal' as the global filter condition"
  },
  {
    "question_id": 168,
    "db_id": "financial",
    "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.gender) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN district AS T4 ON T3.district_id = T4.district_id WHERE T4.A11 > 10000",
    "gold_sql": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
    "reason_1": "GOLD FALSE: the filter condition of with an average salary of over 10000 should be on district (Ambiguous question)",
    "reason_2": "When a client has multiple accounts, Predicted SQL will be recalculated, resulting in an increase in the proportion."
  },
  {
    "question_id": 832,
    "db_id": "superhero",
    "question": "Name the tallest superhero.",
    "predicted_sql": "SELECT superhero_name FROM superhero ORDER BY height_cm DESC LIMIT 1",
    "gold_sql": "SELECT superhero_name FROM superhero WHERE height_cm = (SELECT MAX(height_cm) FROM superhero)",
    "reason_1": "",
    "reason_2": "There are multiple Superheroes with the same maximum height, and using LIMIT 1 is not strict."
  },
  {
    "question_id": 214,
    "db_id": "toxicology",
    "question": "What type of label is not on molecules with atoms with tin?",
    "predicted_sql": "SELECT DISTINCT T2.label FROM molecule AS T2 WHERE T2.molecule_id NOT IN (SELECT T1.molecule_id FROM atom AS T1 WHERE T1.element = 'Sn')",
    "gold_sql": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
    "reason_1": "",
    "reason_2": "Both predicted and gold SQL are incorrect"
  },
  {
    "question_id": 1482,
    "db_id": "debit_card_specializing",
    "question": "Which of the three segments—SME, LAM and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
    "predicted_sql": "WITH segment_stats AS ( SELECT T1.Segment, (SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2013' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END)) * 100.0 / SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) AS percentage_increase FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment IN ('SME', 'LAM', 'KAM') AND T1.Currency = 'EUR' GROUP BY T1.Segment ) SELECT * FROM ( SELECT 'Highest Increase' AS result_type, Segment, percentage_increase FROM segment_stats ORDER BY percentage_increase DESC LIMIT 1 ) AS highest UNION ALL SELECT * FROM ( SELECT 'Lowest Increase' AS result_type, Segment, percentage_increase FROM segment_stats ORDER BY percentage_increase ASC LIMIT 1 ) AS lowest;",
    "gold_sql": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
    "reason_1": "GOLD FALSE: Missing filter condition: Currency = 'EUR', wrong return format\nNote: Wrong evidence, Percentage of Increase should be (Increase or Decrease / consumption for 2012) * 100%",
    "reason_2": "wrong"
  },
  {
    "question_id": 938,
    "db_id": "formula_1",
    "question": "Who was the champion of 2008's Australian Grand Prix and where can I know more about him?",
    "predicted_sql": "SELECT T3.forename, T3.surname, T3.url FROM races AS T1 INNER JOIN results AS T2 ON T1.raceid = T2.raceid INNER JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' AND T1.year = 2008 AND T2.position = 1",
    "gold_sql": "SELECT T1.forename, T1.surname, T1.url FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T2.time LIKE '_:%:__.___' AND T3.year = 2008",
    "reason_1": "",
    "reason_2": "T2.time LIKE '_:%:__.___' false and ground truth false"
  },
  {
    "question_id": 584,
    "db_id": "codebase_community",
    "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
    "predicted_sql": "SELECT comments.text FROM comments INNER JOIN posthistory ON comments.userid = posthistory.userid INNER JOIN posts ON posthistory.postid = posts.id WHERE posts.title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
    "gold_sql": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
    "reason_1": "GOLD FALSE: Wrong Join logic: should be posts -> posthistory -> comments",
    "reason_2": "The question should be the summary of the edit post, not the text of the comments in the post."
  },
  {
    "question_id": 1527,
    "db_id": "debit_card_specializing",
    "question": "Which gas station has the highest amount of revenue?",
    "predicted_sql": "SELECT gasstationid FROM transactions_1k GROUP BY gasstationid ORDER BY SUM(amount * price) DESC LIMIT 1",
    "gold_sql": "SELECT GasStationID FROM transactions_1k GROUP BY GasStationID ORDER BY SUM(Price) DESC LIMIT 1",
    "reason_1": "GOLD FALSE: Should use SUM(amount * price) for the ranking",
    "reason_2": "gold sql false"
  },
  {
    "question_id": 250,
    "db_id": "toxicology",
    "question": "Of all the carcinogenic molecules, which one has the most double bonds?",
    "predicted_sql": "SELECT m.molecule_id FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id JOIN connected c ON b.bond_id = c.bond_id WHERE m.label = '+' AND b.bond_type = '=' GROUP BY m.molecule_id ORDER BY COUNT(b.bond_id) DESC LIMIT 1",
    "gold_sql": "SELECT T.molecule_id FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS bond_count FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id HAVING bond_count = (SELECT MAX(bond_count) FROM (SELECT T3.molecule_id, COUNT(T1.bond_type) AS bond_count FROM bond AS T1 INNER JOIN molecule AS T3 ON T1.molecule_id = T3.molecule_id WHERE T3.label = '+' AND T1.bond_type = '=' GROUP BY T3.molecule_id) AS subquery) ORDER BY bond_count DESC) AS T",
    "reason_1": "",
    "reason_2": "Using LIMIT 1 will limit only 1 result of all possible results"
  },
  {
    "question_id": 321,
    "db_id": "toxicology",
    "question": "What is the molecule of atom id \"TR000_2\" and atom id 2 \"TR000_4\"?",
    "predicted_sql": "SELECT molecule_id FROM atom WHERE atom_id IN ('TR000_2', 'TR000_4')",
    "gold_sql": "SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_2' AND T2.atom_id2 = 'TR000_4'",
    "reason_1": "",
    "reason_2": "Wrong filter condition"
  },
  {
    "question_id": 28,
    "db_id": "california_schools",
    "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
    "predicted_sql": "SELECT T2.School, T2.DOCType FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)` > ( SELECT AVG(T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' )",
    "gold_sql": "SELECT T2.School, T2.DOC FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
    "reason_1": "GOLD FALSE, Predicted TRUE. Gold sql does not return DOCType but DOCid.",
    "reason_2": "Ambiguous question (Ambiguous output format)"
  },
  {
    "question_id": 529,
    "db_id": "card_games",
    "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
    "predicted_sql": "SELECT T1.name FROM sets AS T1 WHERE EXISTS (SELECT 1 FROM set_translations AS T2 WHERE T1.code = T2.setCode AND T2.language = 'Korean') AND NOT EXISTS (SELECT 1 FROM set_translations AS T3 WHERE T1.code = T3.setCode AND T3.language LIKE '%Japanese%')",
    "gold_sql": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
    "reason_1": "GOLD FALSE, Predicted SQL TRUE. The filtering conditions of Gold sql can only filter out sets that are in Korean, but not sets that are not in Japanese.",
    "reason_2": "GOLD FALSE: Only checking a single record that is a Korean translation but not a Japanese translation is not enough, can't eliminate the sets having other Japanese translations (some sets may have Korean and Japanese records separately)"
  },
  {
    "question_id": 1253,
    "db_id": "thrombosis_prediction",
    "question": "For the patient who has the highest Ig A within the normal range, what is his or her diagnosis?",
    "predicted_sql": "SELECT Patient.Diagnosis FROM Patient JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.IGA BETWEEN 80 AND 500 ORDER BY Laboratory.IGA DESC LIMIT 1",
    "gold_sql": "SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA = (SELECT MAX(IGA) FROM Laboratory WHERE IGA BETWEEN 80 AND 500)",
    "reason_1": "",
    "reason_2": "Using LIMIT 1 will exclude other valid results"
  },
  {
    "question_id": 27,
    "db_id": "california_schools",
    "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
    "predicted_sql": "SELECT T1.School, T2.AvgScrWrite, T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE STRFTIME('%Y', T1.OpenDate) > '1991' OR STRFTIME('%Y', T1.ClosedDate) < '2000'",
    "gold_sql": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
    "reason_1": "some schools may not have satscores",
    "reason_2": "GOLD FALSE: Using Left Join will include schools that lack records in the stascores table, which is not aligned with the intent"
  },
  {
    "question_id": 1175,
    "db_id": "thrombosis_prediction",
    "question": "How old was the patient who had the highest hemoglobin count at the time of the examination, and what is the doctor's diagnosis?",
    "predicted_sql": "SELECT strftime('%Y', T1.`Examination Date`) - strftime('%Y', T3.Birthday) AS age, T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Patient AS T3 ON T1.ID = T3.ID ORDER BY T2.HGB DESC LIMIT 1;",
    "gold_sql": "SELECT STRFTIME('%Y', T2.Date) - STRFTIME('%Y', T1.Birthday), T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID ORDER BY T2.HGB DESC LIMIT 1",
    "reason_1": "should use T2.Date",
    "reason_2": "GOLD FALSE: Should use  SUBTRACT(year(`Examination Date`), year(Birthday))"
  }
]