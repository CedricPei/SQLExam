[
  {
    "question_id": 281,
    "db_id": "toxicology",
    "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
    "predicted_sql": "SELECT atom.element, COUNT(*) FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.label = '+' AND SUBSTRING(atom.atom_id, 7, 1) = '4' GROUP BY atom.element",
    "gold_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
    "evidence": "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; ",
    "reason_1": "GOLD FALSE",
    "reason_2": "extra 'na'"
  },
  {
    "question_id": 326,
    "db_id": "toxicology",
    "question": "Which molecule consisted of Sulphur atom with double bond?",
    "predicted_sql": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id2 INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T1.element = 's' AND T3.bond_type = '='",
    "gold_sql": "SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='",
    "evidence": "sulphur refers to element - 's'; double bond refers to bond_type = ' = ';",
    "reason_1": "ground truth false",
    "reason_2": "use the connect, mislead the meaning."
  },
  {
    "question_id": 220,
    "db_id": "toxicology",
    "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
    "predicted_sql": "SELECT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element LIMIT 3",
    "gold_sql": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
    "evidence": "TR000 is the molecule id;",
    "reason_1": "",
    "reason_2": "do not use distinct"
  },
  {
    "question_id": 1090,
    "db_id": "european_football_2",
    "question": "What is the long passing score of the oldest player?",
    "predicted_sql": "SELECT t2.long_passing FROM player AS t1 INNER JOIN player_attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.birthday = (SELECT MIN(birthday) FROM player) LIMIT 1",
    "gold_sql": "SELECT T2.long_passing FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.birthday = (SELECT MIN(birthday) FROM Player)",
    "evidence": "long passing score refers to long_passing; oldest player refers to oldest birthday;",
    "reason_1": "",
    "reason_2": "wrong limit 1"
  },
  {
    "question_id": 1013,
    "db_id": "formula_1",
    "question": "What is the lap record for the Austrian Grand Prix Circuit?",
    "predicted_sql": "SELECT MIN(lt.time) FROM laptimes lt JOIN races r ON lt.raceId = r.raceId WHERE r.name = 'Austrian Grand Prix'",
    "gold_sql": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.fastestLapTime FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL) SELECT MIN(fastest_lap_times.fastestLapTime) as lap_record FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix'",
    "evidence": "lap record means the fastest time recorded which refers to time",
    "reason_1": "",
    "reason_2": "Austrian Grand Prix is not a circuit"
  },
  {
    "question_id": 447,
    "db_id": "card_games",
    "question": "Give the code of sets have expansion commander type?",
    "predicted_sql": "SELECT code FROM sets WHERE type = 'commander'",
    "gold_sql": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
    "evidence": "code of sets refers to setCode",
    "reason_1": "",
    "reason_2": "evidence ask to refer to sekcode"
  },
  {
    "question_id": 962,
    "db_id": "formula_1",
    "question": "From 2000 to 2005, what percentage of drivers who were born before 1985 and the lap numbers were over 50?",
    "predicted_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN strftime('%Y', T1.dob) < '1985' AND T2.laps > 50 THEN T2.driverId END) AS REAL) * 100 / COUNT(DISTINCT T2.driverId) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.year BETWEEN 2000 AND 2005",
    "gold_sql": "SELECT CAST(SUM(IIF(STRFTIME('%Y', T3.dob) < '1985' AND T1.laps > 50, 1, 0)) AS REAL) * 100 / COUNT(*) FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN drivers AS T3 on T1.driverId = T3.driverId WHERE T2.year BETWEEN 2000 AND 2005",
    "evidence": "born before 1985 refers to year(dob)<1985; in 2000 to 2005 refers to year between 2000 and 2005; percentage = Divide(COUNT(driverId where year (dob) <1985 and laps >50),COUNT(DriverID where year between 2000 and 2005) *100;",
    "reason_1": "",
    "reason_2": "wrong aggregation"
  },
  {
    "question_id": 984,
    "db_id": "formula_1",
    "question": "What is the website of the constructor who tallied the most total wins.",
    "predicted_sql": "SELECT c.url FROM constructors c JOIN constructorstandings cs ON c.constructorid = cs.constructorid GROUP BY c.constructorid ORDER BY SUM(cs.wins) DESC LIMIT 1",
    "gold_sql": "SELECT T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 on T1.constructorId = T2.constructorId ORDER BY T2.wins DESC LIMIT 1",
    "evidence": "introduction website refers to url;",
    "reason_1": "",
    "reason_2": "wrong aggregation in condition"
  },
  {
    "question_id": 1391,
    "db_id": "student_club",
    "question": "What is the ratio between students majored in finance and physics?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T1.major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.major_name = 'Physics' THEN 1 ELSE 0 END) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major",
    "gold_sql": "SELECT SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) / SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END) AS ratio FROM major",
    "evidence": "DIVDE(SUM(major_name = 'Finance'), SUM(major_name = 'Physics'))",
    "reason_1": "",
    "reason_2": "GOLD FALSE"
  },
  {
    "question_id": 1389,
    "db_id": "student_club",
    "question": "Which event has the lowest cost?",
    "predicted_sql": "SELECT T3.event_name FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget INNER JOIN event AS T3 ON T1.link_to_event = T3.event_id ORDER BY T2.cost ASC LIMIT 1",
    "gold_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget WHERE T3.cost = (SELECT MIN(T6.cost) FROM event AS T4 INNER JOIN budget AS T5 ON T4.event_id = T5.link_to_event INNER JOIN expense AS T6 ON T5.budget_id = T6.link_to_budget)",
    "evidence": "event refers to event_name where MIN(cost)",
    "reason_1": "",
    "reason_2": "There are more than one lowest value candidates"
  },
  {
    "question_id": 1441,
    "db_id": "student_club",
    "question": "How many members have education major in the College of Education & Human Services?",
    "predicted_sql": "SELECT COUNT(member_id) FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE major_name = 'education' AND college = 'College of Education & Human Services' AND position = 'Member'",
    "gold_sql": "SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major WHERE T1.position = 'Member' AND T2.major_name LIKE '%Education%' AND T2.college = 'College of Education & Human Services'",
    "evidence": "'education' is the major name; 'Member' is a position of club;",
    "reason_1": "Error major value",
    "reason_2": "need approximate condition"
  },
  {
    "question_id": 1068,
    "db_id": "european_football_2",
    "question": "From 2010 to 2015, what was the average overall rating of players who are higher than 170?",
    "predicted_sql": "SELECT AVG(T2.overall_rating) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height > 170 AND STRFTIME('%Y', T2.`date`) BETWEEN '2010' AND '2015'",
    "gold_sql": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 170 AND STRFTIME('%Y',t2.`date`) >= '2010' AND STRFTIME('%Y',t2.`date`) <= '2015'",
    "evidence": "from 2010 to 2015 refers to strftime('%Y', date) >= '2010' AND <= '2015'; average overall rating = SUM(t2.overall_rating)/ COUNT(t2.id); higher than 170 refers to Player.height > 170;",
    "reason_1": "",
    "reason_2": "wrong formula"
  },
  {
    "question_id": 77,
    "db_id": "california_schools",
    "question": "Which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles and what is its Percent (%) Eligible FRPM (Ages 5-17)?",
    "predicted_sql": "SELECT schools.School, frpm.`Percent (%) Eligible FRPM (Ages 5-17)` FROM schools INNER JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.GSserved = 'K-9' AND schools.County = 'Los Angeles';",
    "gold_sql": "SELECT T2.School, T1.`FRPM Count (Ages 5-17)` * 100 / T1.`Enrollment (Ages 5-17)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Los Angeles' AND T2.GSserved = 'K-9'",
    "evidence": "Percent (%) Eligible FRPM (Ages 5-17) can be acquired by `FRPM Count (Ages 5-17)` / `Enrollment (Ages 5-17)` * 100",
    "reason_1": "",
    "reason_2": "forgot to * 100"
  },
  {
    "question_id": 892,
    "db_id": "formula_1",
    "question": "State the driver with the most points scored. Find his full name with that points.",
    "predicted_sql": "SELECT drivers.forename, drivers.surname, SUM(results.points) AS total_points FROM results INNER JOIN drivers ON results.driverid = drivers.driverid GROUP BY drivers.driverid ORDER BY total_points DESC LIMIT 1",
    "gold_sql": "SELECT T3.forename, T3.surname, T2.points FROM races AS T1 INNER JOIN driverStandings AS T2 ON T2.raceId = T1.raceId INNER JOIN drivers AS T3 ON T3.driverId = T2.driverId ORDER BY T2.points DESC LIMIT 1",
    "evidence": "the most points scored refers to max(points); Full name of the driver refers to drivers.forename and drivers.surname;",
    "reason_1": "",
    "reason_2": "wrong table, results and races"
  },
  {
    "question_id": 257,
    "db_id": "toxicology",
    "question": "List down atom id2 for atoms with element sulfur.",
    "predicted_sql": "SELECT atom_id2 FROM connected JOIN atom ON connected.atom_id = atom.atom_id WHERE atom.element = 's'",
    "gold_sql": "SELECT DISTINCT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 's'",
    "evidence": "element sulfur refers to element = 's'",
    "reason_1": "wrong table",
    "reason_2": ""
  },
  {
    "question_id": 1092,
    "db_id": "european_football_2",
    "question": "Give the name of the league had the most matches in the 2008/2009 season?",
    "predicted_sql": "SELECT L.name AS league_name FROM Match M JOIN League L ON M.league_id = L.id WHERE M.season = '2008/2009' GROUP BY L.name ORDER BY COUNT(M.id) DESC LIMIT 1",
    "gold_sql": "SELECT t1.name FROM League AS t1 JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name HAVING COUNT(t2.id) = (SELECT MAX(match_count) FROM (SELECT COUNT(t2.id) AS match_count FROM Match AS t2 WHERE t2.season = '2008/2009' GROUP BY t2.league_id))",
    "evidence": "league that had the most matches in the 2008/2009 season refers to MAX(league_name WHERE season = '2008/2009');",
    "reason_1": "",
    "reason_2": "there are more than 1 top"
  },
  {
    "question_id": 49,
    "db_id": "california_schools",
    "question": "Which different county has the most number of closed schools? Please provide the name of each school as well as the closure date.",
    "predicted_sql": "SELECT T1.County, T1.School, T1.ClosedDate FROM schools T1 WHERE T1.StatusType = 'Closed' AND T1.County = (SELECT T2.County FROM schools T2 WHERE T2.StatusType = 'Closed' GROUP BY T2.County ORDER BY COUNT(*) DESC LIMIT 1)",
    "gold_sql": "SELECT DISTINCT County, School, ClosedDate FROM schools WHERE County = ( SELECT County FROM schools WHERE StatusType = 'Closed' GROUP BY County ORDER BY COUNT(School) DESC LIMIT 1 ) AND StatusType = 'Closed' AND school IS NOT NULL",
    "evidence": "Closure date and closed date are synonyms; 'Closed' was mentioned in schools.StatusType.",
    "reason_1": "",
    "reason_2": "should use distinct because question asks for different counties"
  },
  {
    "question_id": 1174,
    "db_id": "thrombosis_prediction",
    "question": "What is the average age of patients as of year 1999 examined in the laboratory for the October of the year 1991?",
    "predicted_sql": "SELECT AVG(1999 - STRFTIME('%Y', patient.birthday)) AS averageage FROM patient INNER JOIN laboratory ON patient.id = laboratory.id WHERE laboratory.date BETWEEN '1991-10-01' AND '1991-10-31'",
    "gold_sql": "SELECT AVG('1999'  - STRFTIME('%Y', T2.Birthday)) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date BETWEEN '1991-10-01' AND '1991-10-30'",
    "evidence": "average age of patients as of year 1999 refers to AVG(SUBTRACT('1999', year(Birthday))); October of 1991 refers to Date BETWEEN '1991-10-01' AND '1991-10-30'",
    "reason_1": "1991-10-31 false",
    "reason_2": "precision error I think"
  },
  {
    "question_id": 406,
    "db_id": "card_games",
    "question": "Lists by ID all Creature-type cards with legal status.",
    "predicted_sql": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.types = 'Creature' AND T2.status = 'Legal'",
    "gold_sql": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
    "evidence": "legal status refer to status = 'legal'; Goblin-type cards refer to types = 'Creature';",
    "reason_1": "",
    "reason_2": "INNER JOIN rulings"
  },
  {
    "question_id": 186,
    "db_id": "financial",
    "question": "What percentage of male clients request for weekly statements to be issued?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN c.gender = 'M' THEN 1 ELSE 0 END) AS REAL) / COUNT(c.client_id) * 100 AS percentage_of_male_clients_requesting_weekly_statements FROM client c JOIN account a ON c.district_id = a.district_id WHERE a.frequency = 'POPLATEK TYDNE'",
    "gold_sql": "SELECT CAST(SUM(T1.gender = 'M') AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T3 ON T1.district_id = T3.district_id INNER JOIN account AS T2 ON T2.district_id = T3.district_id INNER JOIN disp as T4 on T1.client_id = T4.client_id AND T2.account_id = T4.account_id WHERE T2.frequency = 'POPLATEK TYDNE'",
    "evidence": "Percentage of male clients = [count(male clients who requested weekly statements / count(clients who requested weekly statements)] * 100%; Male means gender = 'M'; 'POPLATEK TYDNE' stands for weekly issuance",
    "reason_1": "",
    "reason_2": "No transition JOIN link through intermediate table"
  },
  {
    "question_id": 46,
    "db_id": "california_schools",
    "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
    "predicted_sql": "SELECT s.school, f.\"Enrollment (K-12)\" FROM frpm AS f INNER JOIN schools AS s ON f.cdscode = s.cdscode WHERE s.doc = '31' AND (s.eilcode = 'ELEMHIGH' OR s.eilcode = 'K-12') ORDER BY f.\"Enrollment (K-12)\" DESC LIMIT 1",
    "gold_sql": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
    "evidence": "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12",
    "reason_1": "",
    "reason_2": "S.elcode = 'ELEMHIGH' is not mentioned in the question and may lead to incorrect results."
  },
  {
    "question_id": 520,
    "db_id": "card_games",
    "question": "Who is the illustrator that illustrated the least amount of cards? List the format of play of the cards that he/she illustrated.",
    "predicted_sql": "SELECT l.format FROM cards c JOIN legalities l ON c.uuid = l.uuid GROUP BY c.artist ORDER BY COUNT(c.id) ASC LIMIT 1",
    "gold_sql": "SELECT T1.artist, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid GROUP BY T1.artist ORDER BY COUNT(T1.id) ASC LIMIT 1",
    "evidence": "format of the cards refers to format; illustrator refers to artist; the least amount of cards refers to MIN(artist)",
    "reason_1": "",
    "reason_2": "Predicted SQLdo not mention who is the illustrator that illustrated the least amount of cards"
  },
  {
    "question_id": 1403,
    "db_id": "student_club",
    "question": "Indicate the name of the closed event whose cost has exceeded the budget the most.",
    "predicted_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.status = 'Closed' ORDER BY T2.remaining ASC LIMIT 1",
    "gold_sql": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event WHERE T1.event_status = 'Closed' AND T1.remaining < 0 ORDER BY T1.remaining LIMIT 1",
    "evidence": "closed events refers to event_name where status = 'Closed'; exceed the budget the most refers to MIN(remaining) where remaining < 0",
    "reason_1": "",
    "reason_2": "Predicted SQL does not reflect cost has exceeded the budget, that is, remaining < 0"
  },
  {
    "question_id": 1243,
    "db_id": "thrombosis_prediction",
    "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN Patient.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE strftime('%Y', current_timestamp) - strftime('%Y', Patient.Birthday) > 55 AND Laboratory.PT >= 14",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
    "evidence": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; ",
    "reason_1": "Error WHERE condition",
    "reason_2": "The predicted SQL computes the percentage of females among abnormal-PT patients older than 55[(F&pt>14&age>55)/(F&age>55)], while the gold SQL computes the percentage of all patients older than 55 who are both female and abnormal-PT[(F&pt>14&age>55)/(age>55)]."
  },
  {
    "question_id": 423,
    "db_id": "card_games",
    "question": "Please provide the ids of top three powerful pairs of Kingdom Foil and Kingdom Cards sorted by Kingdom Foil id in alphabetical order.",
    "predicted_sql": "SELECT \"cards\".\"id\" FROM \"cards\" WHERE NOT \"cards\".\"cardKingdomFoilId\" IS NULL AND NOT \"cards\".\"cardKingdomId\" IS NULL ORDER BY \"cards\".\"cardKingdomFoilId\" ASC LIMIT 3",
    "gold_sql": "SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId LIMIT 3",
    "evidence": "poweful refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
    "reason_1": "Error SELECT",
    "reason_2": "GOLD FALSE. Predicted TRUE. The question requires returning cards.id."
  },
  {
    "question_id": 391,
    "db_id": "card_games",
    "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
    "predicted_sql": "SELECT cards.name, foreign_data.language FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.originalType LIKE '%Artifact%' AND cards.colors LIKE '%B%' AND foreign_data.language != ''",
    "gold_sql": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
    "evidence": "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data",
    "reason_1": "",
    "reason_2": "GOLD FALSE. Predicted SQL FALSE.gold sql  should add  foreign_data.language ! = null, Predicted SQL using cards.colors LIKE '%B%' causes color filtering errors and may also result in \"blue\"."
  },
  {
    "question_id": 1152,
    "db_id": "thrombosis_prediction",
    "question": "What is the ratio of outpatient to inpatient followed up treatment among all the 'SLE' diagnosed patient?",
    "predicted_sql": "SELECT CAST(COUNT(CASE WHEN Admission = '-' THEN 1 END) AS REAL) / COUNT(CASE WHEN Admission = '+' THEN 1 END) AS outpatient_to_inpatient_ratio FROM Patient WHERE Diagnosis = 'SLE'",
    "gold_sql": "SELECT SUM(CASE WHEN Admission = '+' THEN 1.0 ELSE 0 END) / SUM(CASE WHEN Admission = '-' THEN 1 ELSE 0 END) FROM Patient WHERE Diagnosis = 'SLE'",
    "evidence": "'SLE' diagnosed patient means Diagnosis = 'SLE'; inpatient refers to Admission = '+'; outpatient refers to Admission = '-'; calculation =  DIVIDE(COUNT(ID) where Diagnosis = 'SLE' and Admission = '+', COUNT(ID) where Diagnosis = 'SLE' and Admission = '-')",
    "reason_1": "GOLD FALSE: The question is asking for the ratio of outpatient to inpatient, so should use DIVIDE(COUNT(ID) where Diagnosis = 'SLE' and Admission = '-', COUNT(ID) where Diagnosis = 'SLE' and Admission = '+'). The provided evicence is also wrong here.",
    "reason_2": "GOLD FALSE. The numerator should be Admission = '-', that is, outpatient."
  },
  {
    "question_id": 1525,
    "db_id": "debit_card_specializing",
    "question": "What is the percentage of the customers who used EUR in 2012/8/25?",
    "predicted_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.Currency = 'EUR' THEN T2.CustomerID END) AS REAL) * 100.0 / COUNT(DISTINCT T2.CustomerID) FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '2012-08-25'",
    "gold_sql": "SELECT CAST(SUM(IIF(T2.Currency = 'EUR', 1, 0)) AS FLOAT) * 100 / COUNT(T1.CustomerID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25'",
    "evidence": "'2012/8/25' can be represented by '2012-08-25'",
    "reason_1": "GOLD FALSE: Since the question is asking for the percentage of customers rather than the percentage of transactions, so should use DISTINCT CustomerID",
    "reason_2": "Predicted SQL incorrectly measures customers’ default currency (customer-based ratio) instead of transactions’ actual currency usage (transaction-based ratio)."
  },
  {
    "question_id": 102,
    "db_id": "financial",
    "question": "State different accounts who have account opening date before 1997 and own an amount of money greater than 3000USD",
    "predicted_sql": "SELECT DISTINCT T1.account_id FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T1.date < '1997-01-01' AND T2.balance > 3000",
    "gold_sql": "SELECT DISTINCT T2.account_id FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T2.date) < '1997' AND T1.amount > 3000",
    "evidence": "",
    "reason_1": "GOLD FALSE: the gold SQL uses trans.amount>3000 as the filter condition, which means the amount in a specific transaction. However, the question is asking for accounts own an amount of money greater than 3000USD, which in fact corresponding to the trans.balance column, which reflects the latest balance of the account",
    "reason_2": "GOLD FALSE. amount represents the transaction amount, and balance is the balance after the transaction."
  },
  {
    "question_id": 649,
    "db_id": "codebase_community",
    "question": "Describe the post history counts and last edit date of the post title \"What is the best introductory Bayesian statistics textbook?\"",
    "predicted_sql": "SELECT COUNT(T2.Id), T1.LastEditDate FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'What is the best introductory Bayesian statistics textbook?'",
    "gold_sql": "SELECT T1.Id, T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook?'",
    "evidence": "",
    "reason_1": "GOLD FALSE. The question requires a historical count, while gold sql returns the id of each edit",
    "reason_2": "GOLD FALSE: Should return the post history counts"
  },
  {
    "question_id": 516,
    "db_id": "card_games",
    "question": "How many cards did Volkan BaÇµa illustrated whose foreign language is in French?",
    "predicted_sql": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Volkan Baǵa' AND T2.language = 'French'",
    "gold_sql": "SELECT COUNT(T3.id) FROM ( SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Baǵa' AND T2.language = 'French' GROUP BY T1.id ) AS T3",
    "evidence": "Volkan BaÇµa refers to artist = 'Volkan Baǵa'; foreign language is in French refers to language = 'French'",
    "reason_1": "",
    "reason_2": "Group by is needed to answer the question."
  },
  {
    "question_id": 652,
    "db_id": "codebase_community",
    "question": "List the post IDs and badge names of the user Samuel in 2013.",
    "predicted_sql": "SELECT DISTINCT posts.Id, badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id INNER JOIN posts ON users.Id = posts.OwnerUserId WHERE users.DisplayName = 'Samuel' AND strftime('%Y', badges.Date) = '2013' AND strftime('%Y', posts.CreaionDate) = '2013'",
    "gold_sql": "SELECT T1.PostId, T2.Name FROM postHistory AS T1 INNER JOIN badges AS T2 ON T1.UserId = T2.UserId WHERE T1.UserDisplayName = 'Samuel' AND STRFTIME('%Y', T1.CreationDate) = '2013' AND STRFTIME('%Y', T2.Date) = '2013'",
    "evidence": "Samuel refers to UserDisplayName; YEAR(CreationDate) = 2013 relates to PostId; YEAR(Date) = 2013 relates to the badge;",
    "reason_1": "GOLD FALSE: Should use the posts table rather than the postHistory table for filtering, should use DISTINCT to remove duplicates",
    "reason_2": "maybe have different names in the past"
  },
  {
    "question_id": 1283,
    "db_id": "thrombosis_prediction",
    "question": "For the patients with the normal glutamic pylvic transaminase level, how many of them are male?",
    "predicted_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT < 60 AND T1.SEX = 'M'",
    "gold_sql": "SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT < 60 AND T1.SEX = 'M'",
    "evidence": "normal glutamic pylvic transaminase level refers to GOT < 60; male refers to Sex = 'M';",
    "reason_1": "Predicted SQL uses T2.GPT < 60, and T2.GOT < 60 should be used instead",
    "reason_2": "GOLD FALSE: Wrong evidence. According to the real database schema, glutamic pyruvic transaminase corresponds to the Laboratory.GPT column, so the predicted SQL is right."
  },
  {
    "question_id": 427,
    "db_id": "card_games",
    "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
    "predicted_sql": "SELECT set_translations.language FROM set_translations WHERE set_translations.setCode = 'ARC';",
    "gold_sql": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
    "evidence": "known as Archenemy refers to mcmName = 'Archenemy'; having the code ARC refers to setCode = 'ARC'",
    "reason_1": "",
    "reason_2": "Predicted SQL does not use the filter condition mcmName = 'Archenemy'"
  },
  {
    "question_id": 1457,
    "db_id": "student_club",
    "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
    "predicted_sql": "SELECT T1.first_name, T1.last_name, T1.phone FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.first_name, T1.last_name, T1.phone HAVING SUM(T2.cost) > (SELECT AVG(cost) FROM expense)",
    "gold_sql": "SELECT DISTINCT T3.first_name, T3.last_name, T3.phone FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member WHERE T1.cost > ( SELECT AVG(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN member AS T3 ON T3.member_id = T1.link_to_member )",
    "evidence": "full name refers to first_name, last_name; contact number refers to phone; had spent more than average on each expense refers to cost > AVG(cost)",
    "reason_1": "",
    "reason_2": "False Positive: wrong filter condition"
  },
  {
    "question_id": 259,
    "db_id": "toxicology",
    "question": "How many elements are there for single bond molecules?",
    "predicted_sql": "SELECT COUNT(DISTINCT atom.element) AS element_count FROM bond INNER JOIN connected ON bond.bond_id = connected.bond_id INNER JOIN atom ON connected.atom_id = atom.atom_id WHERE bond.bond_type = '-'",
    "gold_sql": "SELECT COUNT(DISTINCT T.element) FROM ( SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN bond AS T3 ON T2.molecule_id = T3.molecule_id WHERE T3.bond_type = '-' ) AS T",
    "evidence": "single bond refers to bond_type = '-';",
    "reason_1": "Predicted SQL does not perform screening at the molecule level.",
    "reason_2": "GOLD FALSE: Wrong JOIN logic, all atoms in any molecule containing single bonds will be counted."
  },
  {
    "question_id": 1006,
    "db_id": "formula_1",
    "question": "Among all the lap records set on various circuits, what is the time for the fastest one?",
    "predicted_sql": "SELECT lapTimes.time FROM lapTimes ORDER BY lapTimes.time ASC LIMIT 1;",
    "gold_sql": "SELECT time FROM lapTimes ORDER BY (CASE WHEN INSTR(time, ':') <> INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':') THEN CAST(SUBSTR(time, 1, INSTR(time, ':') - 1) AS REAL) * 3600 ELSE 0 END) + (CAST(SUBSTR(time, INSTR(time, ':') - 2 * (INSTR(time, ':') = INSTR(SUBSTR(time, INSTR(time, ':') + 1), ':') + INSTR(time, ':')), INSTR(time, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(time, INSTR(time, ':') + 1, INSTR(time, '.') - INSTR(time, ':') - 1) AS REAL)) + (CAST(SUBSTR(time, INSTR(time, '.') + 1) AS REAL) / 1000) ASC LIMIT 1",
    "evidence": "",
    "reason_1": "string ordering",
    "reason_2": "Predict SQL should transform the lapTimes.time to milliseconds, or just use the lapTimes.milliseconds column\nGOLD FALSE: Wrong Calculation, the correct result should be 1:07.411"
  },
  {
    "question_id": 525,
    "db_id": "card_games",
    "question": "Find the uuid of cards in which the old school format is restricted or banned.",
    "predicted_sql": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND status IN ('banned', 'restricted')",
    "gold_sql": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')",
    "evidence": "old school format refers to format = 'oldschool'; restricted or banned refers to status = 'banned' or 'restricted'",
    "reason_1": "Wrong evidence and database schema provided, leading to wrong prediction",
    "reason_2": "It should be correct in a case-insensitive database"
  },
  {
    "question_id": 1501,
    "db_id": "debit_card_specializing",
    "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
    "predicted_sql": "SELECT DISTINCT gasstations.Country FROM transactions_1k JOIN gasstations ON transactions_1k.GasStationID = gasstations.GasStationID WHERE strftime('%Y%m', transactions_1k.Date) = '201306';",
    "gold_sql": "SELECT DISTINCT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Date = '201306'",
    "evidence": "June 2013 refers to '201306'; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month;",
    "reason_1": "Predicted SQL does not filter data with the dates specified in the table yearmonth.",
    "reason_2": "GOLD FALSE: Filter date on the wrong table and column"
  },
  {
    "question_id": 603,
    "db_id": "codebase_community",
    "question": "What is the sum of favourite count gained by user ID 686 in 2011?",
    "predicted_sql": "SELECT SUM(FavoriteCount) FROM posts WHERE OwnerUserId = 686 AND strftime('%Y', CreaionDate) = '2011'",
    "gold_sql": "SELECT SUM(DISTINCT FavoriteCount) FROM posts WHERE Id IN ( SELECT PostId FROM postHistory WHERE UserId = 686 AND STRFTIME('%Y', CreationDate) = '2011' )",
    "evidence": "in 2011 refers to year (CreatinDate) = 2011",
    "reason_1": "GOLD FALSE: Using postHistory.UserId will count the posts where user 686 just updated the post. In addition, using distinct in the sum function will filter out the posts with the same favorite count",
    "reason_2": "If the question only tests the posts created by the user, it is correct. gold sql counts the posts that the user has modified."
  },
  {
    "question_id": 528,
    "db_id": "card_games",
    "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
    "predicted_sql": "SELECT cards.name, legalities.format FROM cards INNER JOIN sets ON cards.setCode = sets.code INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE sets.name = 'Hour of Devastation' AND legalities.status = 'Legal'",
    "gold_sql": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
    "evidence": "the set Hour of Devastation refers to set.name = 'Hour of Devastation'; names of all the cards in the set refers to cards.name; legal cards refers to status = 'Legal'; the formats refers to format",
    "reason_1": "",
    "reason_2": "Should not use legalities.status = 'Legal' as the global filter condition"
  },
  {
    "question_id": 168,
    "db_id": "financial",
    "question": "What percentage of clients who opened their accounts in the district with an average salary of over 10000 are women?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.gender) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN district AS T4 ON T3.district_id = T4.district_id WHERE T4.A11 > 10000",
    "gold_sql": "SELECT CAST(SUM(T2.gender = 'F') AS REAL) * 100 / COUNT(T2.client_id) FROM district AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id WHERE T1.A11 > 10000",
    "evidence": "Female refers to gender = 'F'; Woman and female are closed; Average salary can be found in A11",
    "reason_1": "When a client has multiple accounts, Predicted SQL will be recalculated, resulting in an increase in the proportion.",
    "reason_2": "GOLD FALSE: the filter condition of with an average salary of over 10000 should be on district (Ambiguous question)"
  },
  {
    "question_id": 214,
    "db_id": "toxicology",
    "question": "What type of label is not on molecules with atoms with tin?",
    "predicted_sql": "SELECT DISTINCT T2.label FROM molecule AS T2 WHERE T2.molecule_id NOT IN (SELECT T1.molecule_id FROM atom AS T1 WHERE T1.element = 'Sn')",
    "gold_sql": "SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element != 'sn'",
    "evidence": "tin refers to element ! = 'sn'; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
    "reason_1": "",
    "reason_2": "Both predicted and gold SQL are incorrect"
  },
  {
    "question_id": 1482,
    "db_id": "debit_card_specializing",
    "question": "Which of the three segments—SME, LAM and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
    "predicted_sql": "WITH segment_stats AS ( SELECT T1.Segment, (SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2013' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END)) * 100.0 / SUM(CASE WHEN SUBSTR(T2.Date, 1, 4) = '2012' THEN T2.Consumption ELSE 0 END) AS percentage_increase FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment IN ('SME', 'LAM', 'KAM') AND T1.Currency = 'EUR' GROUP BY T1.Segment ) SELECT * FROM ( SELECT 'Highest Increase' AS result_type, Segment, percentage_increase FROM segment_stats ORDER BY percentage_increase DESC LIMIT 1 ) AS highest UNION ALL SELECT * FROM ( SELECT 'Lowest Increase' AS result_type, Segment, percentage_increase FROM segment_stats ORDER BY percentage_increase ASC LIMIT 1 ) AS lowest;",
    "gold_sql": "SELECT CAST((SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0))) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'SME' AND T2.Date LIKE '2012%', T2.Consumption, 0)), CAST(SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'LAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) , CAST(SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2013%', T2.Consumption, 0)) - SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) AS FLOAT) * 100 / SUM(IIF(T1.Segment = 'KAM' AND T2.Date LIKE '2012%', T2.Consumption, 0)) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID",
    "evidence": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; The first 4 strings of the Date values in the yearmonth table can represent year",
    "reason_1": "wrong",
    "reason_2": "GOLD FALSE: Missing filter condition: Currency = 'EUR', wrong return format\nNote: Wrong evidence, Percentage of Increase should be (Increase or Decrease / consumption for 2012) * 100%"
  },
  {
    "question_id": 938,
    "db_id": "formula_1",
    "question": "Who was the champion of 2008's Australian Grand Prix and where can I know more about him?",
    "predicted_sql": "SELECT T3.forename, T3.surname, T3.url FROM races AS T1 INNER JOIN results AS T2 ON T1.raceid = T2.raceid INNER JOIN drivers AS T3 ON T2.driverid = T3.driverid WHERE T1.name = 'Australian Grand Prix' AND T1.year = 2008 AND T2.position = 1",
    "gold_sql": "SELECT T1.forename, T1.surname, T1.url FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T3.raceId = T2.raceId WHERE T3.name = 'Australian Grand Prix' AND T2.time LIKE '_:%:__.___' AND T3.year = 2008",
    "evidence": "only champion's finished time is represented by 'HH:MM:SS.mmm'; where can I know more refers to url",
    "reason_1": "",
    "reason_2": "T2.time LIKE '_:%:__.___' false and ground truth false"
  },
  {
    "question_id": 584,
    "db_id": "codebase_community",
    "question": "Write all the comments left by users who edited the post titled 'Why square the difference instead of taking the absolute value in standard deviation?'",
    "predicted_sql": "SELECT comments.text FROM comments INNER JOIN posthistory ON comments.userid = posthistory.userid INNER JOIN posts ON posthistory.postid = posts.id WHERE posts.title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
    "gold_sql": "SELECT T2.Comment FROM posts AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'",
    "evidence": "\"Why square the difference instead of taking the absolute value in standard deviation?\" is the Title of post;",
    "reason_1": "The question should be the summary of the edit post, not the text of the comments in the post.",
    "reason_2": "GOLD FALSE: Wrong Join logic: should be posts -> posthistory -> comments"
  },
  {
    "question_id": 27,
    "db_id": "california_schools",
    "question": "What is the average score in writing for the schools that were opened after 1991 or closed before 2000? List the school names along with the score. Also, list the communication number of the schools if there is any.",
    "predicted_sql": "SELECT T1.School, T2.AvgScrWrite, T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE STRFTIME('%Y', T1.OpenDate) > '1991' OR STRFTIME('%Y', T1.ClosedDate) < '2000'",
    "gold_sql": "SELECT T2.School, T1.AvgScrWrite, T2.Phone FROM schools AS T2 LEFT JOIN satscores AS T1 ON T2.CDSCode = T1.cds WHERE strftime('%Y', T2.OpenDate) > '1991' OR strftime('%Y', T2.ClosedDate) < '2000'",
    "evidence": "Communication number refers to phone number.",
    "reason_1": "GOLD FALSE: Using Left Join will include schools that lack records in the stascores table, which is not aligned with the intent",
    "reason_2": "some schools may not have satscores"
  }
]