[
  {
    "question_id": 1041,
    "db_id": "european_football_2",
    "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
    "predicted_sql": "SELECT T2.team_long_name FROM Team_Attributes AS T1 INNER JOIN Team AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.buildUpPlayDribblingClass = 'Normal' AND T1.date LIKE '2014%' GROUP BY T2.team_long_name HAVING SUM(T1.chanceCreationPassing) / COUNT(T1.id) < ( SELECT CAST(SUM(chanceCreationPassing) AS REAL) / COUNT(id) FROM Team_Attributes WHERE date LIKE '2014%' ) ORDER BY SUM(T1.chanceCreationPassing) DESC",
    "gold_sql": "SELECT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
    "label": false,
    "reason_1": "Predicted SQL uses the wrong way to calculate the average value. It should be DIVIDE(SUM(chanceCreationPassing), COUNT(id)) > chanceCreationPassing.",
    "reason_2": "Predicted SQL: Missing the dribbling class filter condition in the sub-query\nGOLD FALSE: 1. Missing the 2014 filter condition in the main query, 2. do comparison and ranking using chance creation passing rather than average chance creation passing, which is different from the intent of the question",
    "evidence": "normal build-up play dribbling class refers to buildUpPlayDribblingClass = 'Normal'; in 2014 refers to date > = '2014-01-01 00:00:00' AND date < = '2014-01-31 00:00:00'; names of the teams refers to team_long_name; less than average chance creation passing = DIVIDE(SUM(chanceCreationPassing), COUNT(id)) > chanceCreationPassing;"
  },
  {
    "question_id": 967,
    "db_id": "formula_1",
    "question": "State code numbers of top 3 yougest drivers. How many Netherlandic drivers among them?",
    "predicted_sql": "SELECT code, SUM(CASE WHEN nationality IN ('Netherlandic', 'Dutch') THEN 1 ELSE 0 END) AS netherlandic_count FROM (SELECT code, nationality FROM drivers ORDER BY dob ASC LIMIT 3) AS top_drivers",
    "gold_sql": "SELECT COUNT(*) FROM ( SELECT T1.nationality FROM drivers AS T1 ORDER BY JULIANDAY(T1.dob) DESC LIMIT 3) AS T3 WHERE T3.nationality = 'Dutch'",
    "label": false,
    "reason_1": "ORDER BY dob ASC",
    "reason_2": "GOLD FALSE: should return code numbers of top 3 youngest drivers. Should use Netherlandic as the filter condition also. The problem should state how to return the answer given there are two separate questions (Ambiguous output)",
    "evidence": "youngest driver refers to Max (year(dob)); Netherlandic and Dutch refer to the same country"
  },
  {
    "question_id": 599,
    "db_id": "codebase_community",
    "question": "What are the post history type IDs for post ID 3720 and how many unique users have commented on the post?",
    "predicted_sql": "SELECT PostHistoryTypeId FROM postHistory WHERE PostId = 3720 UNION SELECT COUNT(DISTINCT UserId) AS UniqueUserCount FROM comments WHERE PostId = 3720",
    "gold_sql": "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory AS T1 WHERE T1.PostId = 3720",
    "label": false,
    "reason_1": "lack second answer",
    "reason_2": "Predicted SQL: Wrong return format\nGOLD FALSE: Wrong return format (Ambiguous output)",
    "evidence": ""
  },
  {
    "question_id": 233,
    "db_id": "toxicology",
    "question": "Please list top two bonds that happened with the molecule TR006 in alphabetical order.",
    "predicted_sql": "SELECT bond.bond_id FROM bond WHERE bond.molecule_id = 'TR006' ORDER BY bond.bond_id ASC LIMIT 2",
    "gold_sql": "SELECT DISTINCT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.molecule_id = 'TR006' ORDER BY T2.bond_id LIMIT 2",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "TR006 is the molecule id"
  },
  {
    "question_id": 507,
    "db_id": "card_games",
    "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T2.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid) AS percentage FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T1.language = 'Portuguese (Brazil)'",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
    "label": false,
    "reason_1": "do not operate on sets",
    "reason_2": "wrong condition",
    "evidence": "Brazil Portuguese translation refers to language = 'Portuguese (Brazil)'; only available online refers to isOnlineOnly = 1; percentage of online only Brazil Portuguese in all Brazil Portuguese cards refers to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)))*100"
  },
  {
    "question_id": 898,
    "db_id": "formula_1",
    "question": "How old is the youngest Japanese driver? What is his name?",
    "predicted_sql": "SELECT drivers.forename, drivers.surname, CAST(STRFTIME('%Y', CURRENT_TIMESTAMP) AS INTEGER) - CAST(STRFTIME('%Y', drivers.dob) AS INTEGER) AS age FROM drivers WHERE drivers.nationality = 'Japanese' ORDER BY drivers.dob DESC LIMIT 1",
    "gold_sql": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);"
  },
  {
    "question_id": 2,
    "db_id": "california_schools",
    "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
    "predicted_sql": "SELECT schools.Zip FROM schools INNER JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.County = 'Fresno County Office of Education' AND frpm.`Charter School (Y/N)` = 1",
    "gold_sql": "SELECT T2.Zip FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`District Name` = 'Fresno County Office of Education' AND T1.`Charter School (Y/N)` = 1",
    "label": false,
    "reason_1": "WHERE condition",
    "reason_2": "\"Fresno County Office of Education\" means `District Name` not County. Maybe GOLD FALSE.",
    "evidence": "Charter schools refers to `Charter School (Y/N)` = 1 in the table fprm"
  },
  {
    "question_id": 421,
    "db_id": "card_games",
    "question": "Please list top three unknown power cards that have promotional types for arena league in alphabetical order.",
    "predicted_sql": "SELECT name FROM cards WHERE (power IS NULL OR power = '*') AND promoTypes LIKE '%arenaleague%' ORDER BY name LIMIT 3",
    "gold_sql": "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "unknown power cards refers to power is null or power = '*'; promotional types for arena league refers to promoTypes = 'arenaleague'"
  },
  {
    "question_id": 1391,
    "db_id": "student_club",
    "question": "What is the ratio between students majored in finance and physics?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T1.major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T1.major_name = 'Physics' THEN 1 ELSE 0 END) FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major",
    "gold_sql": "SELECT SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) / SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END) AS ratio FROM major",
    "label": true,
    "reason_1": "",
    "reason_2": "GOLD FALSE",
    "evidence": "DIVDE(SUM(major_name = 'Finance'), SUM(major_name = 'Physics'))"
  },
  {
    "question_id": 1024,
    "db_id": "european_football_2",
    "question": "Who are the top 5 players who perform better in crossing actions? Indicate their player id.",
    "predicted_sql": "SELECT Player.player_api_id FROM Player_Attributes INNER JOIN Player ON Player_Attributes.player_api_id = Player.player_api_id ORDER BY Player_Attributes.crossing DESC LIMIT 5;",
    "gold_sql": "SELECT id FROM Player_Attributes ORDER BY crossing DESC LIMIT 5",
    "label": false,
    "reason_1": "GOLD FALSE",
    "reason_2": "There is no need to look for the id on another table.",
    "evidence": "perform better in crossing actions refers to MAX(crossing)"
  },
  {
    "question_id": 399,
    "db_id": "card_games",
    "question": "Lists all types of cards available in arena.",
    "predicted_sql": "SELECT subtypes, supertypes FROM cards WHERE availability = 'arena'",
    "gold_sql": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "all types refer to subtypes and supertypes\n\navailble in arena refers to availability = 'arena'"
  },
  {
    "question_id": 1458,
    "db_id": "student_club",
    "question": "Calculate the difference in the percentage of members in New Jersey and Vermont.",
    "predicted_sql": "SELECT ROUND(((CAST(SUM(CASE WHEN zip_code.state = 'Maine' THEN 1 ELSE 0 END) AS REAL) / CAST(SUM(CASE WHEN member.position = 'Member' THEN 1 ELSE 0 END) AS REAL)) - (CAST(SUM(CASE WHEN zip_code.state = 'Vermont' THEN 1 ELSE 0 END) AS REAL) / CAST(SUM(CASE WHEN member.position = 'Member' THEN 1 ELSE 0 END) AS REAL))) * 100, 2) FROM member INNER JOIN zip_code ON member.zip = zip_code.zip_code WHERE member.position = 'Member';",
    "gold_sql": "SELECT CAST((SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END)) AS REAL) * 100 / COUNT(T1.member_id) AS diff FROM member AS T1 INNER JOIN zip_code AS T2 ON T2.zip_code = T1.zip",
    "label": false,
    "reason_1": "Predicted SQL: wrong filter: state = 'Maine'\nGOLD FALSE: missing filter on position = 'Member'",
    "reason_2": "No New Jearsy",
    "evidence": "SUBTRACT( DIVIDE( SUM(state = 'New Jersey'), COUNT(position = 'Member')), DIVIDE( SUM(state = 'Vermont'), COUNT(position = 'Member')) )"
  },
  {
    "question_id": 970,
    "db_id": "formula_1",
    "question": "List out top 3 German drivers who were born from 1980-1990 and have the earliest lap time.",
    "predicted_sql": "SELECT d.forename, d.surname FROM drivers d JOIN laptimes l ON d.driverId = l.driverId WHERE d.nationality = 'German' AND d.dob BETWEEN '1980-01-01' AND '1990-12-31' ORDER BY l.time ASC LIMIT 3",
    "gold_sql": "SELECT T2.driverId FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1990' ORDER BY T1.time LIMIT 3",
    "label": false,
    "reason_1": "GOLD FALSE",
    "reason_2": "GOLD FALSE. gold sql uses the wrong table, laptime instend of pitStops, and is lack of ASC.",
    "evidence": "born from 1980-1990 refers to year(dob) between 1980 and 1990; earliest lap time refers to Min(time);"
  },
  {
    "question_id": 1035,
    "db_id": "european_football_2",
    "question": "Give the team_fifa_api_id of teams with more than 50 but less than 60 build-up play speed.",
    "predicted_sql": "SELECT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60",
    "gold_sql": "SELECT DISTINCT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "teams with more than 50 but less than 60 build-up play speed refers to buildUpPlaySpeed >50 AND buildUpPlaySpeed <60; "
  },
  {
    "question_id": 1124,
    "db_id": "european_football_2",
    "question": "Who are the players that tend to be attacking when their mates were doing attack moves? List down their name.",
    "predicted_sql": "SELECT Player.player_name FROM Player_Attributes JOIN Player ON Player_Attributes.player_api_id = Player.player_api_id WHERE Player_Attributes.attacking_work_rate = 'high';",
    "gold_sql": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.attacking_work_rate = 'high'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "tend to be attacking when their mates were doing attack moves refers to attacking_work_rate = 'high';"
  },
  {
    "question_id": 167,
    "db_id": "financial",
    "question": "List all the clients' IDs whose junior credit cards were issued after 1996.",
    "predicted_sql": "SELECT DISTINCT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.type = 'junior' AND T3.issued >= '1997-01-01'",
    "gold_sql": "SELECT T2.client_id FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'junior' AND T1.issued >= '1997-01-01'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "After 1996 means date > = '1997-01-01"
  },
  {
    "question_id": 1122,
    "db_id": "european_football_2",
    "question": "State the name of the most strongest player.",
    "predicted_sql": "SELECT Player.player_name FROM Player INNER JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id ORDER BY Player_Attributes.overall_rating DESC LIMIT 10;",
    "gold_sql": "SELECT DISTINCT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)",
    "label": false,
    "reason_1": "The strongest player should only return one result, which should be limit 1.",
    "reason_2": "Should use MAX(overall_rating) rather than ORDER BY overall_rating DESC LIMIT 10; Should use DISTINCT to remove duplicates",
    "evidence": "strongest players refers to player has MAX(overall_rating)"
  },
  {
    "question_id": 20,
    "db_id": "california_schools",
    "question": "How many schools in Amador which the Low Grade is 9 and the High Grade is 12?",
    "predicted_sql": "SELECT COUNT(CDSCode) FROM frpm WHERE `County Name` = 'Amador' AND `Low Grade` = '9' AND `High Grade` = '12'",
    "gold_sql": "SELECT COUNT(T1.`School Name`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Amador' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": ""
  },
  {
    "question_id": 1118,
    "db_id": "european_football_2",
    "question": "List down the name of players who are 35 years old and above.",
    "predicted_sql": "SELECT T1.player_name FROM Player AS T1 WHERE (strftime('%Y', 'now') - strftime('%Y', T1.birthday)) >= 35",
    "gold_sql": "SELECT player_name FROM Player WHERE CAST((JULIANDAY('now') - JULIANDAY(birthday)) AS REAL) / 365 >= 35",
    "label": false,
    "reason_1": "GOLD FALSE",
    "reason_2": "The predicted SQL uses year subtraction and can overestimate ages",
    "evidence": "35 years old and above refers to datetime(CURRENT_TIMESTAMP,'localtime') - datetime(birthday) > 34"
  },
  {
    "question_id": 1285,
    "db_id": "thrombosis_prediction",
    "question": "When is the latest patient's medical data recorded? This patient should have an abnormal level of lactate dehydrogenase.",
    "predicted_sql": "SELECT MAX(`Date`) AS latest_date FROM Laboratory WHERE ID IN ( SELECT ID FROM Patient ORDER BY `First Date` DESC LIMIT 1 ) AND LDH >= 500",
    "gold_sql": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH >= 500 ORDER BY T1.`First Date` DESC LIMIT 1",
    "label": false,
    "reason_1": "Predicted SQL first identifies the latest patient and then looks for anomalies, but the latest patient is not necessarily abnormal",
    "reason_2": "Error MAX function",
    "evidence": "latest patient refers to ID with MAX('First Date'); abnormal level of lactate dehydrogenase refers to LDH > = 500;"
  },
  {
    "question_id": 1492,
    "db_id": "debit_card_specializing",
    "question": "What percentage of KAM customers pay in euros?",
    "predicted_sql": "SELECT CAST(COUNT(CASE WHEN Currency = 'EUR' THEN 1 END) AS REAL) * 100 / COUNT(*) FROM customers WHERE Segment = 'KAM'",
    "gold_sql": "SELECT CAST(SUM(Currency = 'EUR') AS FLOAT) * 100 / COUNT(CustomerID) FROM customers WHERE Segment = 'KAM'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "Percentage of KAM uses Euro = (Total of KAM uses Euro / Total of KAM) * 100%."
  },
  {
    "question_id": 1455,
    "db_id": "student_club",
    "question": "Which budget allowed the most money for water, chips, and cookies?",
    "predicted_sql": "SELECT MAX(expense.cost) FROM expense WHERE expense.expense_description = 'Water, chips, cookies';",
    "gold_sql": "SELECT T2.budget_id FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Water, chips, cookies' ORDER BY T1.cost DESC LIMIT 1",
    "label": false,
    "reason_1": "Wrong return results & should join the budget and expense table",
    "reason_2": "Predicted SQL only returns cost and does not meet the requirement that question returns budget",
    "evidence": "budget allowed refers to expense_description; expense_description = 'Water, chips, cookies'; most money refers to MAX(cost)"
  },
  {
    "question_id": 1133,
    "db_id": "european_football_2",
    "question": "How many football players born after the 1990s have the first name \"Aaron\"?",
    "predicted_sql": "SELECT COUNT(*) FROM Player WHERE player_name LIKE 'Aaron%' AND birthday > '1990-12-31 00:00:00'",
    "gold_sql": "SELECT COUNT(id) FROM Player WHERE birthday > '1990' AND player_name LIKE 'Aaron%'",
    "label": false,
    "reason_1": "wrong condition.",
    "reason_2": "1990 not 1990-12-31",
    "evidence": "first name \"Aaron\" refers to player_name LIKE 'Aaron%'; born after the 1990s refers to birthday > '1990'"
  },
  {
    "question_id": 425,
    "db_id": "card_games",
    "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
    "predicted_sql": "SELECT number FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%'",
    "gold_sql": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "don't have multiple faces on a single card side is null"
  },
  {
    "question_id": 83,
    "db_id": "california_schools",
    "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the number of cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
    "predicted_sql": "SELECT City, COUNT(School) FROM schools WHERE GSoffered = 'K-8' AND Magnet = 1 GROUP BY City",
    "gold_sql": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
    "label": false,
    "reason_1": "Missing filter on  `NSLP Provision Status` = 'Multiple Provision Types'",
    "reason_2": "NSLP Provision Status` = 'Multiple Provision Types'",
    "evidence": "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1; Multiple Provision Types refers to `NSLP Provision Status` = 'Multiple Provision Types'"
  },
  {
    "question_id": 248,
    "db_id": "toxicology",
    "question": "What are the atoms of the triple bond with the molecule \"TR041\"?",
    "predicted_sql": "SELECT DISTINCT c.atom_id, c.atom_id2 FROM connected AS c INNER JOIN bond AS b ON c.bond_id = b.bond_id WHERE b.molecule_id = 'TR041' AND b.bond_type = '#'",
    "gold_sql": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_type = '#' AND T3.molecule_id = 'TR041'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "TR041 is the molecule id; triple bond refers to bond_type = '#';"
  },
  {
    "question_id": 1126,
    "db_id": "european_football_2",
    "question": "State the name of players who came from Belgium.",
    "predicted_sql": "SELECT DISTINCT p.player_name FROM Player p JOIN Match m ON p.player_api_id = m.home_player_1 OR p.player_api_id = m.home_player_2 OR p.player_api_id = m.home_player_3 OR p.player_api_id = m.home_player_4 OR p.player_api_id = m.home_player_5 OR p.player_api_id = m.home_player_6 OR p.player_api_id = m.home_player_7 OR p.player_api_id = m.home_player_8 OR p.player_api_id = m.home_player_9 OR p.player_api_id = m.home_player_10 OR p.player_api_id = m.home_player_11 OR p.player_api_id = m.away_player_1 OR p.player_api_id = m.away_player_2 OR p.player_api_id = m.away_player_3 OR p.player_api_id = m.away_player_4 OR p.player_api_id = m.away_player_5 OR p.player_api_id = m.away_player_6 OR p.player_api_id = m.away_player_7 OR p.player_api_id = m.away_player_8 OR p.player_api_id = m.away_player_9 OR p.player_api_id = m.away_player_10 OR p.player_api_id = m.away_player_11",
    "gold_sql": "SELECT t3.player_name FROM Country AS t1 INNER JOIN Match AS t2 ON t1.id = t2.country_id INNER JOIN Player AS t3 ON t2.home_player_1 = t3.player_api_id WHERE t1.name = 'Belgium'",
    "label": false,
    "reason_1": "Error WHERE condition",
    "reason_2": "The names are different.",
    "evidence": "name of players refers to player_name; Belgium is name of country"
  },
  {
    "question_id": 275,
    "db_id": "toxicology",
    "question": "Give me the molecule ID of the double bond type.",
    "predicted_sql": "SELECT molecule_id FROM bond WHERE bond_type = '='",
    "gold_sql": "SELECT DISTINCT T.molecule_id FROM bond AS T WHERE T.bond_type = '='",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "double bond refers to bond_type = ' = ';"
  },
  {
    "question_id": 916,
    "db_id": "formula_1",
    "question": "Please list the surnames of all the Italian drivers.",
    "predicted_sql": "SELECT DISTINCT drivers.surname FROM drivers WHERE drivers.nationality = 'Italian'",
    "gold_sql": "SELECT surname FROM drivers WHERE nationality = 'Italian'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "Italian refers to nationality = 'italian'"
  },
  {
    "question_id": 927,
    "db_id": "formula_1",
    "question": "Which driver created the fastest lap speed in a Formula_1 race? Please give both his forename and surname.",
    "predicted_sql": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
    "gold_sql": "SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapSpeed DESC LIMIT 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": ""
  }
]