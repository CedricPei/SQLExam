[
  {
    "question_id": 437,
    "db_id": "card_games",
    "question": "Among black card borders, which card has full artwork?",
    "predicted_sql": "SELECT name FROM cards WHERE borderColor = 'black' AND isFullArt = 1",
    "gold_sql": "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "white card borders refers to borderColor = 'white'; has full artwork refers to isFullArt = 1"
  },
  {
    "question_id": 1267,
    "db_id": "thrombosis_prediction",
    "question": "Among the patients with normal anti-SM, how many of them does not have thrombosis?",
    "predicted_sql": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative', '0') AND T1.Thrombosis = 1",
    "gold_sql": "SELECT COUNT(T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM IN ('negative','0') AND T1.Thrombosis = 0",
    "label": false,
    "reason_1": "Predicted SQL used the wrong filtering condition. T1.Thrombosis = 1 should be T1.Thrombosis = 0.",
    "reason_2": "Error WHERE condition",
    "evidence": "normal anti-SM refers to SM IN('-', '+-'); SM = 'negative' means '-'; SM = '0' means '+-'; SM = '1' means '+'; does not have thrombosis refers to Thrombosis = 0;"
  },
  {
    "question_id": 139,
    "db_id": "financial",
    "question": "How many high-level credit cards have \"OWNER\" type of disposition?",
    "predicted_sql": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'disponent'",
    "gold_sql": "SELECT COUNT(T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'OWNER'",
    "label": false,
    "reason_1": "Wrong filter condition, which should be type = 'OWNER'",
    "reason_2": "type should be owner",
    "evidence": "High-level credit cards refers to the cards with the gold type."
  },
  {
    "question_id": 595,
    "db_id": "codebase_community",
    "question": "Which user have only one post history per post and having at least 1000 views?",
    "predicted_sql": "SELECT postHistory.UserId FROM postHistory INNER JOIN users ON postHistory.UserId = users.Id WHERE users.Views >= 1000 GROUP BY postHistory.UserId HAVING COUNT(DISTINCT postHistory.PostId) = 1",
    "gold_sql": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
    "label": false,
    "reason_1": "Error JOIN",
    "reason_2": "Wrong condition column.",
    "evidence": "having at least 1000 view refers to Views > = 1000; user refers to UserId"
  },
  {
    "question_id": 1243,
    "db_id": "thrombosis_prediction",
    "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN Patient.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE strftime('%Y', current_timestamp) - strftime('%Y', Patient.Birthday) > 55 AND Laboratory.PT >= 14",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
    "label": false,
    "reason_1": "The predicted SQL computes the percentage of females among abnormal-PT patients older than 55[(F&pt>14&age>55)/(F&age>55)], while the gold SQL computes the percentage of all patients older than 55 who are both female and abnormal-PT[(F&pt>14&age>55)/(age>55)].",
    "reason_2": "Error WHERE condition",
    "evidence": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; "
  },
  {
    "question_id": 1204,
    "db_id": "thrombosis_prediction",
    "question": "How long did it take after patient number 821298 arrived at the hospital for the first time before her evaluation began?",
    "predicted_sql": "SELECT JULIANDAY(T2.`Examination Date`) - JULIANDAY(T1.`First Date`) AS days_diff FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = 821298 AND T2.`Examination Date` IS NOT NULL",
    "gold_sql": "SELECT STRFTIME('%d', T3.`Examination Date`) - STRFTIME('%d', T1.`First Date`) FROM Patient AS T1 INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.ID = 821298",
    "label": false,
    "reason_1": "GOLD FLASE",
    "reason_2": "GOLD FALSE. Gold SQL only subtracts day-of-month values, which fails across months or years.It might even be a negative number.Predicted SQL TRUE.",
    "evidence": "DATEDIFF(`Examination Date`, `First Date`)"
  },
  {
    "question_id": 730,
    "db_id": "superhero",
    "question": "List the superheroes from Marvel Comics who have the super power of 'Super Strength'.",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T4.power_name = 'Super Strength' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) AS percentage FROM publisher AS T1 INNER JOIN superhero AS T2 ON T1.id = T2.publisher_id INNER JOIN hero_power AS T3 ON T2.id = T3.hero_id INNER JOIN superpower AS T4 ON T3.power_id = T4.id WHERE T1.publisher_name = 'Marvel Comics'",
    "gold_sql": "SELECT superhero_name FROM superhero AS T1 WHERE EXISTS (SELECT 1 FROM hero_power AS T2 INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.id = T2.hero_id)AND EXISTS (SELECT 1 FROM publisher AS T4 WHERE T4.publisher_name = 'Marvel Comics' AND T1.publisher_id = T4.id)",
    "label": false,
    "reason_1": "Wrong return: should return the superhero instead of a percentage",
    "reason_2": "do not list name",
    "evidence": "the superheroes from Marvel Comics refers to publisher_name = 'Marvel Comics'; super power of \"Super Strength\" refers to power_name = 'Super Strength';"
  },
  {
    "question_id": 451,
    "db_id": "card_games",
    "question": "How many cards available in paper have a positive starting maximum hand size?",
    "predicted_sql": "SELECT COUNT(*) FROM cards WHERE cards.availability LIKE '%paper%' AND cards.hand LIKE '+%';",
    "gold_sql": "SELECT SUM(CASE WHEN availability = 'paper' AND hAND = '3' THEN 1 ELSE 0 END) FROM cards",
    "label": false,
    "reason_1": "not fit the evidence required",
    "reason_2": "hand=3 未满足条件",
    "evidence": "available in paper refers to availability like '%paper%'; have a positive starting maximum hand size refers to hand = '3'"
  },
  {
    "question_id": 562,
    "db_id": "codebase_community",
    "question": "For the post which got 1910 view counts, how many comments does it get?",
    "predicted_sql": "SELECT CommentCount FROM posts WHERE ViewCount = 1910",
    "gold_sql": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ViewCount = 1910",
    "label": true,
    "reason_1": "",
    "reason_2": "GOLD FALSE: Since the question is asking for how many comments, so should return SELECT COUNT(comments.Id)",
    "evidence": ""
  },
  {
    "question_id": 389,
    "db_id": "card_games",
    "question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
    "predicted_sql": "SELECT cards.name, rulings.date FROM cards INNER JOIN rulings ON cards.uuid = rulings.uuid WHERE cards.originalType = 'Creature - Elf';",
    "gold_sql": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'",
    "label": true,
    "reason_1": "",
    "reason_2": "GOLD FALSE: Should return the name of cards",
    "evidence": "Creature - Elf is the originalType;"
  },
  {
    "question_id": 1449,
    "db_id": "student_club",
    "question": "What is the name and major of members who had to spend more than a hundred dollars on an expense?",
    "predicted_sql": "SELECT T1.first_name, T1.last_name, T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE T3.cost > 100",
    "gold_sql": "SELECT DISTINCT T1.first_name, T1.last_name, T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T2.major_id = T1.link_to_major INNER JOIN expense AS T3 ON T1.member_id = T3.link_to_member WHERE T3.cost > 100",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "full name refers to first_name, last_name; major of members refers to major_name; spend more than a hundred dollars on an expense refers to cost > 100"
  },
  {
    "question_id": 801,
    "db_id": "superhero",
    "question": "Find the ratio between male superheroes and female superheroes.",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN superhero.gender_id = 1 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN superhero.gender_id = 2 THEN 1 ELSE 0 END) as ratio FROM superhero INNER JOIN gender ON superhero.gender_id = gender.id;",
    "gold_sql": "SELECT CAST(COUNT(CASE WHEN T2.gender = 'Male' THEN T1.id ELSE NULL END) AS REAL) / COUNT(CASE WHEN T2.gender = 'Female' THEN T1.id ELSE NULL END) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "ratio = DIVIDE(SUM(gender_id = 1) / SUM(gender_id = 2)); male superheroes refers to gender = 'Female'; female superheroes refers to gender = 'Male';"
  },
  {
    "question_id": 298,
    "db_id": "toxicology",
    "question": "Calculate the percentage of molecules containing carcinogenic compounds that element is hydrogen.",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T1.label = '+' AND T2.element = 'h' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id",
    "gold_sql": "SELECT CAST(COUNT(CASE WHEN T1.element = 'h' AND T2.label = '+' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id",
    "label": false,
    "reason_1": "Predicted SQL: Missing DISTINCT keyword. GOLD FALSE: Missing DISTINCT keyword. Note: Ambiguous question",
    "reason_2": "The denominator should be COUNT(T2.molecule_id). If DISTINCT is used, it will cause the meaning of the denominator to change to the number of numerators, resulting in incorrect semantics",
    "evidence": "hydrogen refers to element = 'h'; label = '+' mean molecules are carcinogenic; percentage = DIVIDE(SUM(label = '+' and element = 'h'), COUNT(molecule_id)) * 100.0"
  },
  {
    "question_id": 990,
    "db_id": "formula_1",
    "question": "What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.",
    "predicted_sql": "SELECT c.constructorRef, c.url  FROM constructorStandings cs  JOIN races r ON cs.raceId = r.raceId  JOIN constructors c ON cs.constructorId = c.constructorId  WHERE r.year = 2009 AND r.name = 'Singapore Grand Prix'  ORDER BY cs.points DESC  LIMIT 1",
    "gold_sql": "SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
    "label": false,
    "reason_1": "constructorStandings.points does not indicate the time taken in the competition.",
    "reason_2": "Wrong filter condition",
    "evidence": "the time of the champion shows in the format of \"minutes: seconds.millionsecond\" in which Max(time); constructor reference name refers to constructorRef; website refers to url"
  },
  {
    "question_id": 398,
    "db_id": "card_games",
    "question": "What is the  unconverted mana do all the cards created by Rob Alexander cost in total?",
    "predicted_sql": "SELECT SUM(CAST(REPLACE(REPLACE(manaCost, '{', ''), '}', '') AS INTEGER)) FROM cards WHERE artist = 'Rob Alexander'",
    "gold_sql": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
    "label": false,
    "reason_1": "GOLD FALSE: Should add manaCost IS NOT NULL",
    "reason_2": "non-readonly SQL blocked.",
    "evidence": "unconverted mana refer to manaCost; Rob Alexander refer to artist"
  },
  {
    "question_id": 1526,
    "db_id": "debit_card_specializing",
    "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
    "predicted_sql": "SELECT (t2012.Consumption - t2013.Consumption) / t2012.Consumption AS DecreaseRate FROM ( SELECT Consumption FROM yearmonth WHERE CustomerID IN ( SELECT CustomerID FROM transactions_1k WHERE `Date` = '2012-08-25' AND Amount = 634.8 ) AND `Date` = '201212' ) t2012, ( SELECT Consumption FROM yearmonth WHERE CustomerID IN ( SELECT CustomerID FROM transactions_1k WHERE `Date` = '2012-08-25' AND Amount = 634.8 ) AND `Date` = '201312' ) t2013",
    "gold_sql": "SELECT CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
    "label": false,
    "reason_1": "Missing aggregation: to compute the consumption for a year, need to aggregate all consumption records in that year",
    "reason_2": "should use price instead of amount",
    "evidence": "'2012/8/24' can be represented by '2012-08-24'; Consumption decrease rate = (consumption_2012 - consumption_2013) / consumption_2012"
  },
  {
    "question_id": 425,
    "db_id": "card_games",
    "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
    "predicted_sql": "SELECT number FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%'",
    "gold_sql": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "don't have multiple faces on a single card side is null"
  },
  {
    "question_id": 868,
    "db_id": "formula_1",
    "question": "Where is Malaysian Grand Prix held? Give the location coordinates.",
    "predicted_sql": "SELECT T2.lat, T2.lng FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Malaysian Grand Prix'",
    "gold_sql": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Malaysian Grand Prix'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "location coordinates refers to (lat, lng); Malaysian Grand Prix refers to races.name = 'Malaysian Grand Prix'"
  },
  {
    "question_id": 693,
    "db_id": "codebase_community",
    "question": "Identify the number of posts and comments left by the user, who has the latest created user account.",
    "predicted_sql": "SELECT COUNT(DISTINCT posts.Id) AS post_count, COUNT(DISTINCT comments.Id) AS comment_count FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId LEFT JOIN comments ON users.Id = comments.UserId ORDER BY users.CreationDate DESC LIMIT 1;",
    "gold_sql": "SELECT COUNT(T2.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN comments AS T3 ON T3.PostId = T2.Id ORDER BY T1.CreationDate DESC LIMIT 1",
    "label": false,
    "reason_1": "GOLD FALSE. gold SQL only counts that user’s posts which have at least one comment. the number of posts and comments was not returned.",
    "reason_2": "GOLD FALSE",
    "evidence": "the latest created user account refers to MAX(CreationDate);"
  },
  {
    "question_id": 761,
    "db_id": "superhero",
    "question": "Among the male superheroes, list the super hero names of superheroes with weight greater than the 79% average weight of all superheroes.",
    "predicted_sql": "SELECT s.superhero_name FROM superhero s JOIN gender g ON s.gender_id = g.id WHERE g.gender = 'Male' AND s.weight_kg > (SELECT AVG(weight_kg) * 0.79 FROM superhero)",
    "gold_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "super hero names refers to superhero_name;male superheros refers to gender = 'Male';Calculation = weight_kg > MULTIPLY(AVG(weight_kg), 0.79)"
  },
  {
    "question_id": 662,
    "db_id": "codebase_community",
    "question": "How many posts with votes that were created in 2011 have a bounty of 50?",
    "predicted_sql": "SELECT COUNT(PostId) FROM votes WHERE strftime('%Y', CreationDate) = '2011' AND BountyAmount = 50",
    "gold_sql": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.BountyAmount = 50 AND STRFTIME('%Y', T2.CreationDate) = '2011'",
    "label": false,
    "reason_1": "",
    "reason_2": "count votes instead of posts",
    "evidence": "created in 2012 refers YEAR(CreationDate) = 2011; BountyAmount = 50;"
  },
  {
    "question_id": 522,
    "db_id": "card_games",
    "question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.",
    "predicted_sql": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned'",
    "gold_sql": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "ranked 1st on EDHRec refers to edhrecRank = 1; banned refers to status = 'Banned'; play format refers to format; cards name refers to name"
  },
  {
    "question_id": 1034,
    "db_id": "european_football_2",
    "question": "List the players' api id who had the highest above average overall ratings in 2010.",
    "predicted_sql": "SELECT player_api_id FROM Player_Attributes WHERE date LIKE '2010%' AND overall_rating > ( SELECT AVG(overall_rating) FROM Player_Attributes WHERE date LIKE '2010%' )",
    "gold_sql": "SELECT p.player_api_id FROM Player_Attributes AS p WHERE SUBSTR(p.date, 1, 4) = '2010' AND p.overall_rating = (SELECT MAX(pa.overall_rating) FROM Player_Attributes AS pa WHERE SUBSTR(pa.date, 1, 4) = '2010')",
    "label": false,
    "reason_1": "do not use max",
    "reason_2": "Wrong filter condition, should use max(overall_rating) as provided in the evidence",
    "evidence": "highest above average overall ratings refers to MAX(overall_rating); in 2010 refers to substr(date,1,4) = '2010';"
  },
  {
    "question_id": 668,
    "db_id": "codebase_community",
    "question": "What is the display name of the user who acquired the highest amount of badges?",
    "predicted_sql": "SELECT T2.DisplayName FROM badges AS T1 JOIN users AS T2 ON T1.UserId = T2.Id GROUP BY T2.DisplayName ORDER BY COUNT(T1.Name) DESC LIMIT 1",
    "gold_sql": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T1.DisplayName ORDER BY COUNT(T1.Id) DESC LIMIT 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "highest amount of badges refers to MAX(COUNT(Name));"
  },
  {
    "question_id": 1480,
    "db_id": "debit_card_specializing",
    "question": "What was the gas consumption peak month for SME customers in 2013?",
    "predicted_sql": "SELECT T2.Date FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'SME' AND T2.Date LIKE '2013%' ORDER BY T2.Consumption DESC LIMIT 1",
    "gold_sql": "SELECT SUBSTR(T2.Date, 5, 2) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE SUBSTR(T2.Date, 1, 4) = '2013' AND T1.Segment = 'SME' GROUP BY SUBSTR(T2.Date, 5, 2) ORDER BY SUM(T2.Consumption) DESC LIMIT 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "Year 2013 can be presented as Between 201301 And 201312; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month."
  },
  {
    "question_id": 504,
    "db_id": "card_games",
    "question": "How many cards are there in the set 'World Championship Decks 2004' with the converted mana cost as '3'.",
    "predicted_sql": "SELECT COUNT(*) FROM sets s JOIN cards c ON s.code = c.setCode WHERE s.name = 'World Championship Decks 2004' AND c.convertedManaCost = 3",
    "gold_sql": "SELECT COUNT(id) FROM cards WHERE setCode IN ( SELECT code FROM sets WHERE name = 'World Championship Decks 2004' ) AND convertedManaCost = 3",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "the set 'World Championship Decks 2004' refers to name = 'World Championship Decks 2004'"
  },
  {
    "question_id": 621,
    "db_id": "codebase_community",
    "question": "What are the name of badges that users who have the lowest reputation obtained?",
    "predicted_sql": "SELECT DISTINCT badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.Reputation = (SELECT MIN(Reputation) FROM users) AND badges.Name IS NOT NULL;",
    "gold_sql": "SELECT T2.Name, T1.Reputation FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
    "label": true,
    "reason_1": "",
    "reason_2": "GOLD FALSE: missing DISTINCT keyword",
    "evidence": "lowest reputation refers to Min(Reputation); user refers to UserId"
  },
  {
    "question_id": 1168,
    "db_id": "thrombosis_prediction",
    "question": "The oldest SJS patient's medical laboratory work was completed on what date, and what age was the patient when they initially arrived at the hospital?",
    "predicted_sql": "SELECT t2.date, STRFTIME('%Y', t1.\"First Date\") - STRFTIME('%Y', t1.birthday) AS age FROM patient AS t1 INNER JOIN laboratory AS t2 ON t1.id = t2.id WHERE t1.diagnosis = 'SJS' ORDER BY t1.birthday ASC LIMIT 1",
    "gold_sql": "SELECT T1.Date, STRFTIME('%Y', T2.`First Date`) - STRFTIME('%Y', T2.Birthday),T2.Birthday FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SJS' AND T2.Birthday IS NOT NULL ORDER BY T2.Birthday ASC LIMIT 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "The larger the birthday value, the younger the person is, and vice versa; 'SJS' refers to diagnosis; (SUBTRACT(year(`First Date`)), year(Birthday)); age of the patients when they initially arrived at the hospital refers to year(Birthday)"
  },
  {
    "question_id": 218,
    "db_id": "toxicology",
    "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
    "predicted_sql": "SELECT (100 - (CAST(COUNT(DISTINCT CASE WHEN T2.element = 'f' THEN T1.molecule_id END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id))) AS percentage FROM molecule AS T1 LEFT JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+'",
    "gold_sql": "SELECT CAST(COUNT(DISTINCT CASE WHEN T1.element <> 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
    "label": false,
    "reason_1": "wrong condition, = 'f' and <> 'f'",
    "reason_2": "GOLD FALSE",
    "evidence": "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id)) where label = '+'; Should consider the distinct atoms when counting;"
  },
  {
    "question_id": 1159,
    "db_id": "thrombosis_prediction",
    "question": "For patient with albumin level lower than 3.5, list their ID, sex and diagnosis.",
    "predicted_sql": "SELECT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
    "gold_sql": "SELECT DISTINCT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.ALB < 3.5",
    "label": true,
    "reason_1": "",
    "reason_2": "No distinct",
    "evidence": "albumin level lower than 3.5 refers to ALB < 3.5;"
  }
]