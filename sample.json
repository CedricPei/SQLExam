[
  {
    "question_id": 306,
    "db_id": "toxicology",
    "question": "Which molecules have triple bonds and list all the elements they contain.",
    "predicted_sql": "SELECT atom.element, atom.molecule_id FROM atom INNER JOIN connected ON atom.atom_id = connected.atom_id INNER JOIN bond ON connected.bond_id = bond.bond_id WHERE bond.bond_type = '#' GROUP BY atom.molecule_id, atom.element",
    "gold_sql": "SELECT DISTINCT T1.molecule_id, T2.element FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#'",
    "label": false,
    "reason_1": "participate vs include",
    "reason_2": "Only selected the atoms in the triple bonds instead of all the elements in the molecule",
    "evidence": "triple bond refers to bond_type = '#'; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
  },
  {
    "question_id": 195,
    "db_id": "toxicology",
    "question": "What is the most common bond type?",
    "predicted_sql": "SELECT bond_type FROM bond GROUP BY bond_type ORDER BY COUNT(bond_type) DESC LIMIT 1",
    "gold_sql": "SELECT T.bond_type FROM ( SELECT bond_type, COUNT(bond_id) FROM bond GROUP BY bond_type ORDER BY COUNT(bond_id) DESC LIMIT 1 ) AS T",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "most common bond type refers MAX(COUNT(bond_type))"
  },
  {
    "question_id": 1426,
    "db_id": "student_club",
    "question": "List the last name of members with a major in environmental engineering and include its department and college name.",
    "predicted_sql": "SELECT member.last_name, major.department, major.college FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE major.major_name = 'Environmental Engineering';",
    "gold_sql": "SELECT T2.last_name, T1.department, T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "'Environmental Engineering' is the major_name;"
  },
  {
    "question_id": 402,
    "db_id": "card_games",
    "question": "What is the percentage of Story Spotlight cards that do not have a text box? List them by their ID.",
    "predicted_sql": "SELECT (CAST(COUNT(CASE WHEN isStorySpotlight = 1 AND isTextless = 1 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(*)) AS percentage, id FROM cards WHERE isStorySpotlight = 1 AND isTextless = 1",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
    "label": false,
    "reason_1": "The condition should be isTextless = 0, while Predicted SQL is isTextless = 1",
    "reason_2": "Error WHERE condition; Error SELECT calculation logic",
    "evidence": "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 0; Percentage = DIVIDE(SUM(count(id) where isStorylight = 1 AND isTextless = 0 ), SUM(count(id))) * 100"
  },
  {
    "question_id": 522,
    "db_id": "card_games",
    "question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.",
    "predicted_sql": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned'",
    "gold_sql": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "ranked 1st on EDHRec refers to edhrecRank = 1; banned refers to status = 'Banned'; play format refers to format; cards name refers to name"
  },
  {
    "question_id": 1187,
    "db_id": "thrombosis_prediction",
    "question": "How many patients who were examined between 1987/7/6 and 1996/1/31 had a GPT level greater than 30 and an ALB level less than 4? List them by their ID.",
    "predicted_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1987-07-06' AND '1996-01-31' AND T2.GPT > 30 AND T2.ALB < 4",
    "gold_sql": "SELECT DISTINCT ID FROM Laboratory WHERE Date BETWEEN '1987-07-06' AND '1996-01-31' AND GPT > 30 AND ALB < 4",
    "label": false,
    "reason_1": "GOLD FALSE",
    "reason_2": "There is no need to join with table Examination. And it is necessary to return the id instead of the count.",
    "evidence": "examined between 1987/7/6 and 1996/1/31 refers to Date BETWEEN '1987-07-06' AND '1996-01-31'; GPT level greater than 30 refers to GPT > 30; ALB level less than 4 ALB < 4"
  },
  {
    "question_id": 1523,
    "db_id": "debit_card_specializing",
    "question": "Which country was the card owner of No.667467 in?",
    "predicted_sql": "SELECT CASE WHEN T2.Currency = 'EUR' THEN 'SVK' WHEN T2.Currency = 'CZK' THEN 'CZE' END AS Country FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.CardID = 667467",
    "gold_sql": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.CardID = '667467'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": ""
  },
  {
    "question_id": 1087,
    "db_id": "european_football_2",
    "question": "Among the players whose height is over 180, how many of them have a volley score of over 70?",
    "predicted_sql": "SELECT COUNT(*) FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE p.height > 180 AND pa.volleys > 70",
    "gold_sql": "SELECT COUNT(DISTINCT t1.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 AND t2.volleys > 70",
    "label": false,
    "reason_1": "Missing DISTINCT keyword",
    "reason_2": "DISTINCT needs to be used to remove duplicate data.",
    "evidence": "height > 180; volley score refers to volleys; volleys > 70;"
  },
  {
    "question_id": 456,
    "db_id": "card_games",
    "question": "What's the list of all types for the card \"Molimo, Maro-Sorcerer\"?",
    "predicted_sql": "SELECT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'",
    "gold_sql": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "card \"Molimo, Maro-Sorcerer\" refers to name = 'Molimo, Maro-Sorcerer'; list of all types refers to subtypes,supertypes"
  },
  {
    "question_id": 898,
    "db_id": "formula_1",
    "question": "How old is the youngest Japanese driver? What is his name?",
    "predicted_sql": "SELECT drivers.forename, drivers.surname, CAST(STRFTIME('%Y', CURRENT_TIMESTAMP) AS INTEGER) - CAST(STRFTIME('%Y', drivers.dob) AS INTEGER) AS age FROM drivers WHERE drivers.nationality = 'Japanese' ORDER BY drivers.dob DESC LIMIT 1",
    "gold_sql": "SELECT STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', dob), forename , surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "date of birth refers to drivers.dob; The larger the birthday value, the younger the person is, and vice versa; Japanese refers to nationality = 'Japanese'; age = YEAR(CURRENT_TIMESTAMP) - YEAR(dob);"
  },
  {
    "question_id": 1450,
    "db_id": "student_club",
    "question": "In the events with more than forty incomes, list the city and country in which the event is happening.",
    "predicted_sql": "SELECT T1.location, T5.city, T5.county FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN income AS T3 ON T3.link_to_member = T2.link_to_member INNER JOIN zip_code AS T5 ON T1.location = T5.zip_code GROUP BY T1.location, T5.city, T5.county HAVING COUNT(T3.income_id) > 40",
    "gold_sql": "SELECT DISTINCT T3.city, T3.county FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip WHERE T1.amount > 40",
    "label": false,
    "reason_1": "Wrong Join and filter condition",
    "reason_2": "Predicted SQL calculates that the number of income entries COUNT(T3.income_id) is greater than 40, not incomes",
    "evidence": "more than fifty incomes refers to income > 40"
  },
  {
    "question_id": 662,
    "db_id": "codebase_community",
    "question": "How many posts with votes that were created in 2011 have a bounty of 50?",
    "predicted_sql": "SELECT COUNT(PostId) FROM votes WHERE strftime('%Y', CreationDate) = '2011' AND BountyAmount = 50",
    "gold_sql": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.BountyAmount = 50 AND STRFTIME('%Y', T2.CreationDate) = '2011'",
    "label": false,
    "reason_1": "",
    "reason_2": "count votes instead of posts",
    "evidence": "created in 2012 refers YEAR(CreationDate) = 2011; BountyAmount = 50;"
  },
  {
    "question_id": 1235,
    "db_id": "thrombosis_prediction",
    "question": "What are the patient's diagnosis for those who has lower red blood blood cell? State their ID and age.",
    "predicted_sql": "SELECT T1.ID, T1.Diagnosis, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) AS Age FROM Patient AS T1 JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
    "gold_sql": "SELECT DISTINCT T1.Diagnosis, T1.ID , STRFTIME('%Y', CURRENT_TIMESTAMP) -STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RBC < 3.5",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "patient's diagnosis refers to Diagnosis; lower red blood cell refers to RBC < 3.5; age = SUBTRACT(year(current_timestamp), year(Birthday)); "
  },
  {
    "question_id": 233,
    "db_id": "toxicology",
    "question": "Please list top two bonds that happened with the molecule TR006 in alphabetical order.",
    "predicted_sql": "SELECT bond.bond_id FROM bond WHERE bond.molecule_id = 'TR006' ORDER BY bond.bond_id ASC LIMIT 2",
    "gold_sql": "SELECT DISTINCT T2.bond_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.molecule_id = 'TR006' ORDER BY T2.bond_id LIMIT 2",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "TR006 is the molecule id"
  },
  {
    "question_id": 213,
    "db_id": "toxicology",
    "question": "What type of bond is there between the atoms TR004_8 and TR004_20?",
    "predicted_sql": "SELECT T2.bond_type FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T1.atom_id = 'TR004_8' AND T1.atom_id2 = 'TR004_20'",
    "gold_sql": "SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20' OR T2.atom_id2 = 'TR004_8' AND T2.atom_id = 'TR004_20'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "type of bond refers to bond_type; between the atoms TR004_8 and TR004_20 refers to atom_id = 'TR004_8' AND atom_id2 = 'TR004_20' OR another way around"
  },
  {
    "question_id": 1261,
    "db_id": "thrombosis_prediction",
    "question": "How many patients with a normal RF don't have thrombosis?",
    "predicted_sql": "SELECT COUNT(*) FROM Examination INNER JOIN Laboratory ON Examination.ID = Laboratory.ID WHERE Laboratory.RF < 20 AND Examination.Thrombosis = 0;",
    "gold_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RF < 20 AND T1.Thrombosis = 0",
    "label": false,
    "reason_1": "should use distinct",
    "reason_2": "no distinct count",
    "evidence": "normal RF refers to RF < 20; don't have thrombosis refers to Thrombosis = '0';"
  },
  {
    "question_id": 453,
    "db_id": "card_games",
    "question": "What's the unconverted mana cost of the card \"Ancestor's Chosen\"?",
    "predicted_sql": "SELECT convertedManaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
    "gold_sql": "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
    "label": false,
    "reason_1": "wrong column",
    "reason_2": "Error SELECT",
    "evidence": "card \"Ancestor's Chosen\" refers to name = 'Ancestor`s Chosen'"
  },
  {
    "question_id": 1465,
    "db_id": "student_club",
    "question": "Which budget category does the expense 'Posters' fall to?",
    "predicted_sql": "SELECT budget.category FROM expense INNER JOIN budget ON expense.link_to_budget = budget.budget_id WHERE expense.expense_description = 'Posters';",
    "gold_sql": "SELECT DISTINCT T2.category FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id WHERE T1.expense_description = 'Posters'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "'Posters' refers to expense description"
  },
  {
    "question_id": 562,
    "db_id": "codebase_community",
    "question": "For the post which got 1910 view counts, how many comments does it get?",
    "predicted_sql": "SELECT CommentCount FROM posts WHERE ViewCount = 1910",
    "gold_sql": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ViewCount = 1910",
    "label": true,
    "reason_1": "",
    "reason_2": "GOLD FALSE: Since the question is asking for how many comments, so should return SELECT COUNT(comments.Id)",
    "evidence": ""
  },
  {
    "question_id": 507,
    "db_id": "card_games",
    "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T2.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid) AS percentage FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T1.language = 'Portuguese (Brazil)'",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "Brazil Portuguese translation refers to language = 'Portuguese (Brazil)'; only available online refers to isOnlineOnly = 1; percentage of online only Brazil Portuguese in all Brazil Portuguese cards refers to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)))*100"
  },
  {
    "question_id": 1013,
    "db_id": "formula_1",
    "question": "What is the lap record for the Austrian Grand Prix Circuit?",
    "predicted_sql": "SELECT MIN(lt.time) FROM laptimes lt JOIN races r ON lt.raceId = r.raceId WHERE r.name = 'Austrian Grand Prix'",
    "gold_sql": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.fastestLapTime FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL) SELECT MIN(fastest_lap_times.fastestLapTime) as lap_record FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "lap record means the fastest time recorded which refers to time"
  },
  {
    "question_id": 284,
    "db_id": "toxicology",
    "question": "Determine the bond type that is formed in the chemical compound containing element Carbon.",
    "predicted_sql": "SELECT bond.bond_type FROM atom JOIN bond ON atom.molecule_id = bond.molecule_id WHERE atom.element = 'te';",
    "gold_sql": "SELECT DISTINCT T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c'",
    "label": false,
    "reason_1": "Error condition",
    "reason_2": "Predicted SQL used the wrong filtering condition atom.element = 'te', which should be element = 'c'.",
    "evidence": "Carbon refers to element = 'c'; double bond refers to bond_type = ' = '; single bond refers to bond_type = '-'; triple bond refers to bond_type = '#';"
  },
  {
    "question_id": 400,
    "db_id": "card_games",
    "question": "Lists the set code of all cards translated into Spanish.",
    "predicted_sql": "SELECT DISTINCT setcode FROM set_translations WHERE language = 'Spanish'",
    "gold_sql": "SELECT setCode FROM set_translations WHERE language = 'Spanish'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "Spanish refer to language; set code refers to setCode"
  },
  {
    "question_id": 762,
    "db_id": "superhero",
    "question": "Which power do superheroes have the most of?",
    "predicted_sql": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T2.power_name) DESC LIMIT 1",
    "gold_sql": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T1.hero_id) DESC LIMIT 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "power that superheroes have the most refers to MAX(COUNT(power_name))"
  },
  {
    "question_id": 640,
    "db_id": "codebase_community",
    "question": "Calculate the difference in view count from post posted by Mornington and view count from posts posted by Amos.",
    "predicted_sql": "SELECT SUM(CASE WHEN users.DisplayName = 'mornington' THEN posts.ViewCount ELSE 0 END) - SUM(CASE WHEN users.DisplayName = 'Amos' THEN posts.ViewCount ELSE 0 END) FROM posts JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName IN ('mornington', 'Amos')",
    "gold_sql": "SELECT SUM(IIF(T1.DisplayName = 'Mornington', T3.ViewCount, 0)) - SUM(IIF(T1.DisplayName = 'Amos', T3.ViewCount, 0)) AS diff FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId",
    "label": false,
    "reason_1": "Missing JOIN",
    "reason_2": "wrong computation euqation",
    "evidence": "calculation = SUBTRACT(SUM(ViewCount where DisplayName = 'Mornington'), SUM(ViewCount where DisplayName = 'Amos'));"
  },
  {
    "question_id": 854,
    "db_id": "formula_1",
    "question": "What is the coordinates location of the circuits for Australian grand prix?",
    "predicted_sql": "SELECT T2.lat, T2.lng FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Australian Grand Prix'",
    "gold_sql": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Australian Grand Prix'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "coordinate position/location refers to lat, lng; circuits for Australian grand prix refers to races.name = 'Australian Grand Prix'"
  },
  {
    "question_id": 1022,
    "db_id": "european_football_2",
    "question": "What is the preferred foot when attacking of the player with the lowest potential?",
    "predicted_sql": "SELECT Player_Attributes.preferred_foot FROM Player_Attributes WHERE Player_Attributes.potential = (SELECT MIN(Player_Attributes.potential) FROM Player_Attributes);",
    "gold_sql": "SELECT preferred_foot FROM Player_Attributes WHERE penalties AND potential = (SELECT MIN(potential) FROM Player_Attributes)",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "preferred foot when attacking refers to preferred_foot; lowest potential refers to MIN(potential);"
  },
  {
    "question_id": 1241,
    "db_id": "thrombosis_prediction",
    "question": "For patients with abnormal platelet level, state the number of patients with lower than normal range. How is it compare to the number of patients with higher than normal range?",
    "predicted_sql": "SELECT SUM(CASE WHEN PLT < 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN PLT > 400 THEN 1 ELSE 0 END) FROM Laboratory",
    "gold_sql": "SELECT SUM(CASE WHEN T2.PLT <= 100 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.PLT >= 400 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
    "label": false,
    "reason_1": "GOLD FALSE",
    "reason_2": "wrong condition, evidence require >= and <=",
    "evidence": "abnormal platelet level refers to PLT <= 100 or PLT >= 400; platelet level lower than normal range refers to PLT < 100; calculation = SUBTRACT(SUM(PLT < 100), SUM(PLT > 400)); platelet level higher than normal range refers to PLT > 400;"
  },
  {
    "question_id": 451,
    "db_id": "card_games",
    "question": "How many cards available in paper have a positive starting maximum hand size?",
    "predicted_sql": "SELECT COUNT(*) FROM cards WHERE cards.availability LIKE '%paper%' AND cards.hand LIKE '+%';",
    "gold_sql": "SELECT SUM(CASE WHEN availability = 'paper' AND hAND = '3' THEN 1 ELSE 0 END) FROM cards",
    "label": false,
    "reason_1": "hand=3 not satisfied",
    "reason_2": "not fit the evidence required",
    "evidence": "available in paper refers to availability like '%paper%'; have a positive starting maximum hand size refers to hand = '3'"
  },
  {
    "question_id": 515,
    "db_id": "card_games",
    "question": "When was the oldest mythic card released and what are its legal play formats?",
    "predicted_sql": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate ASC LIMIT 1",
    "gold_sql": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' AND T1.originalReleaseDate = (SELECT MIN(originalReleaseDate) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal')",
    "label": false,
    "reason_1": "Missing originalReleaseDate IS NOT NULL & should not use order by limit 1",
    "reason_2": "do not consider null",
    "evidence": "the oldest card refers to MIN(originalReleaseDate); mythic card refers to rarity = 'mythic'; legal play refers to status = 'legal'; play format refers to format"
  }
]