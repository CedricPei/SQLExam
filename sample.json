[
  {
    "question_id": 1034,
    "db_id": "european_football_2",
    "question": "List the players' api id who had the highest above average overall ratings in 2010.",
    "predicted_sql": "SELECT player_api_id FROM Player_Attributes WHERE date LIKE '2010%' AND overall_rating > ( SELECT AVG(overall_rating) FROM Player_Attributes WHERE date LIKE '2010%' )",
    "gold_sql": "SELECT p.player_api_id FROM Player_Attributes AS p WHERE SUBSTR(p.date, 1, 4) = '2010' AND p.overall_rating = (SELECT MAX(pa.overall_rating) FROM Player_Attributes AS pa WHERE SUBSTR(pa.date, 1, 4) = '2010')",
    "label": false,
    "reason_1": "Wrong filter condition, should use max(overall_rating) as provided in the evidence",
    "reason_2": "do not use max",
    "evidence": "highest above average overall ratings refers to MAX(overall_rating); in 2010 refers to substr(date,1,4) = '2010';"
  },
  {
    "question_id": 1475,
    "db_id": "debit_card_specializing",
    "question": "How many customers in KAM had a consumption of less than 30,000 for the year 2012?",
    "predicted_sql": "SELECT COUNT(customers.CustomerID) FROM customers INNER JOIN yearmonth ON customers.CustomerID = yearmonth.CustomerID WHERE customers.Segment = 'KAM' AND yearmonth.Date >= '201201' AND yearmonth.Date <= '201212' AND yearmonth.Consumption < 30000",
    "gold_sql": "SELECT COUNT(*) FROM ( SELECT T2.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' AND SUBSTRING(T2.Date, 1, 4) = '2012' GROUP BY T2.CustomerID HAVING SUM(T2.Consumption) < 30000 ) AS t1",
    "label": false,
    "reason_1": "Should calculate the total consumption of the year",
    "reason_2": "Predicted SQL does not use GROUP BY CustomerID, so it returns the number of records instead of the number of customers",
    "evidence": "Year 2012 can be presented as Between 201201 And 201212, which means between January and December in 2012"
  },
  {
    "question_id": 38,
    "db_id": "california_schools",
    "question": "What are the webpages for the Los Angeles County school that has between 2,000 and 3,000 test takers?",
    "predicted_sql": "SELECT DISTINCT T3.Website FROM satscores AS T1 INNER JOIN schools AS T3 ON T1.cds = T3.CDSCode WHERE T1.cname = 'Los Angeles' AND T1.NumTstTakr BETWEEN 2000 AND 3000",
    "gold_sql": "SELECT T2.Website FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumTstTakr BETWEEN 2000 AND 3000 AND T2.County = 'Los Angeles'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": ""
  },
  {
    "question_id": 264,
    "db_id": "toxicology",
    "question": "What are the labels for TR000, TR001 and TR002?",
    "predicted_sql": "SELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002')",
    "gold_sql": "SELECT molecule_id, T.label FROM molecule AS T WHERE T.molecule_id IN ('TR000', 'TR001', 'TR002')",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "TR000, TR001 and TR002 are molecule id; label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic"
  },
  {
    "question_id": 453,
    "db_id": "card_games",
    "question": "What's the unconverted mana cost of the card \"Ancestor's Chosen\"?",
    "predicted_sql": "SELECT convertedManaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
    "gold_sql": "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
    "label": false,
    "reason_1": "wrong column",
    "reason_2": "Error SELECT",
    "evidence": "card \"Ancestor's Chosen\" refers to name = 'Ancestor`s Chosen'"
  },
  {
    "question_id": 126,
    "db_id": "financial",
    "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T1.date LIKE '1993%' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Decin'",
    "gold_sql": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
    "label": false,
    "reason_1": "No distinct",
    "reason_2": "Logical error, the COUNT(T1.account_id) includes records which are not in 1993.",
    "evidence": "A2 contains the information about district."
  },
  {
    "question_id": 1178,
    "db_id": "thrombosis_prediction",
    "question": "What was the gender of the first AORTITIS diagnosed patient?",
    "predicted_sql": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' ORDER BY `First Date` LIMIT 1",
    "gold_sql": "SELECT SEX FROM Patient WHERE Diagnosis = 'AORTITIS' AND `First Date` IS NOT NULL ORDER BY `First Date` ASC LIMIT 1",
    "label": false,
    "reason_1": "Predicted SQL does NOT filter the case where 'First Date' IS NOT NULL.",
    "reason_2": "Missing NOT NULL",
    "evidence": "gender means SEX; 'AORTITIS' refers to Diagnosis;"
  },
  {
    "question_id": 421,
    "db_id": "card_games",
    "question": "Please list top three unknown power cards that have promotional types for arena league in alphabetical order.",
    "predicted_sql": "SELECT name FROM cards WHERE (power IS NULL OR power = '*') AND promoTypes LIKE '%arenaleague%' ORDER BY name LIMIT 3",
    "gold_sql": "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "unknown power cards refers to power is null or power = '*'; promotional types for arena league refers to promoTypes = 'arenaleague'"
  },
  {
    "question_id": 1472,
    "db_id": "debit_card_specializing",
    "question": "In 2012, who had the least consumption in LAM?",
    "predicted_sql": "SELECT customers.CustomerID FROM yearmonth INNER JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE customers.Segment = 'LAM' AND yearmonth.Date BETWEEN '201201' AND '201212' ORDER BY yearmonth.Consumption ASC LIMIT 1;",
    "gold_sql": "SELECT T1.CustomerID FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND SUBSTR(T2.Date, 1, 4) = '2012' GROUP BY T1.CustomerID ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
    "label": false,
    "reason_1": "Error consumption calculation",
    "reason_2": "no sum",
    "evidence": "Year 2012 can be presented as Between 201201 And 201212; The first 4 strings of the Date values in the yearmonth table can represent year."
  },
  {
    "question_id": 854,
    "db_id": "formula_1",
    "question": "What is the coordinates location of the circuits for Australian grand prix?",
    "predicted_sql": "SELECT T2.lat, T2.lng FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.name = 'Australian Grand Prix'",
    "gold_sql": "SELECT DISTINCT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'Australian Grand Prix'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "coordinate position/location refers to lat, lng; circuits for Australian grand prix refers to races.name = 'Australian Grand Prix'"
  },
  {
    "question_id": 1450,
    "db_id": "student_club",
    "question": "In the events with more than forty incomes, list the city and country in which the event is happening.",
    "predicted_sql": "SELECT T1.location, T5.city, T5.county FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN income AS T3 ON T3.link_to_member = T2.link_to_member INNER JOIN zip_code AS T5 ON T1.location = T5.zip_code GROUP BY T1.location, T5.city, T5.county HAVING COUNT(T3.income_id) > 40",
    "gold_sql": "SELECT DISTINCT T3.city, T3.county FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN zip_code AS T3 ON T3.zip_code = T2.zip WHERE T1.amount > 40",
    "label": false,
    "reason_1": "Wrong Join and filter condition",
    "reason_2": "Predicted SQL calculates that the number of income entries COUNT(T3.income_id) is greater than 40, not incomes",
    "evidence": "more than fifty incomes refers to income > 40"
  },
  {
    "question_id": 281,
    "db_id": "toxicology",
    "question": "Tally the toxicology element of the 4th atom of each molecule that was carcinogenic.",
    "predicted_sql": "SELECT atom.element, COUNT(*) FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.label = '+' AND SUBSTRING(atom.atom_id, 7, 1) = '4' GROUP BY atom.element",
    "gold_sql": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND SUBSTR(T1.atom_id, -1) = '4' AND LENGTH(T1.atom_id) = 7",
    "label": false,
    "reason_1": "GOLD FALSE",
    "reason_2": "extra 'na'",
    "evidence": "label = '+' means molecules are carcinogenic; 4th atom of each molecule refers to substr(atom_id, 7, 1) = '4'; "
  },
  {
    "question_id": 786,
    "db_id": "superhero",
    "question": "How many heroes have the highest attribute value in strength?",
    "predicted_sql": "SELECT COUNT(*) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = (SELECT MAX(T3.attribute_value) FROM hero_attribute AS T3 INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T4.attribute_name = 'Strength')",
    "gold_sql": "SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T2.attribute_name = 'Strength' AND T1.attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )",
    "label": true,
    "reason_1": "",
    "reason_2": "ground truth false",
    "evidence": "highest attribute value in strength refers to MAX(attribute_value) WHERE attribute_name = 'Strength';"
  },
  {
    "question_id": 67,
    "db_id": "california_schools",
    "question": "What is the total amount of Community College District closure in 1989 in the city of San Francisco?",
    "predicted_sql": "SELECT COUNT(*)  FROM schools  WHERE schools.City = 'San Francisco'  AND schools.DOCType = 'Community College District'  AND strftime('%Y', schools.ClosedDate) = '1989'",
    "gold_sql": "SELECT COUNT(School) FROM schools WHERE strftime('%Y', ClosedDate) = '1989' AND City = 'San Francisco' AND DOCType = 'Community College District'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": ""
  },
  {
    "question_id": 599,
    "db_id": "codebase_community",
    "question": "What are the post history type IDs for post ID 3720 and how many unique users have commented on the post?",
    "predicted_sql": "SELECT PostHistoryTypeId FROM postHistory WHERE PostId = 3720 UNION SELECT COUNT(DISTINCT UserId) AS UniqueUserCount FROM comments WHERE PostId = 3720",
    "gold_sql": "SELECT T1.PostHistoryTypeId, (SELECT COUNT(DISTINCT UserId) FROM comments WHERE PostId = 3720) AS NumberOfUsers FROM postHistory AS T1 WHERE T1.PostId = 3720",
    "label": false,
    "reason_1": "Predicted SQL: Wrong return format\nGOLD FALSE: Wrong return format (Ambiguous output)",
    "reason_2": "lack second answer",
    "evidence": ""
  },
  {
    "question_id": 398,
    "db_id": "card_games",
    "question": "What is the  unconverted mana do all the cards created by Rob Alexander cost in total?",
    "predicted_sql": "SELECT SUM(CAST(REPLACE(REPLACE(manaCost, '{', ''), '}', '') AS INTEGER)) FROM cards WHERE artist = 'Rob Alexander'",
    "gold_sql": "SELECT manaCost FROM cards WHERE artist = 'Rob Alexander'",
    "label": false,
    "reason_1": "non-readonly SQL blocked.",
    "reason_2": "GOLD FALSE: Should add manaCost IS NOT NULL",
    "evidence": "unconverted mana refer to manaCost; Rob Alexander refer to artist"
  },
  {
    "question_id": 1177,
    "db_id": "thrombosis_prediction",
    "question": "Was the total cholesterol status for the patient id 2927464 on 1995-9-4 at the normal level?",
    "predicted_sql": "SELECT Laboratory.`T-CHO` < 250 AS is_normal FROM Laboratory WHERE Laboratory.ID = 2927464 AND Laboratory.Date = '1995-09-04'",
    "gold_sql": "SELECT CASE WHEN `T-CHO` < 250 THEN 'Normal' ELSE 'Abnormal' END FROM Laboratory WHERE ID = 2927464 AND Date = '1995-09-04'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "total cholesterol normal level refers to N < 250"
  },
  {
    "question_id": 86,
    "db_id": "california_schools",
    "question": "What is the administrator's last name that oversees the school with Charter number 40? Indicate the district, the county where the school is situated, and the name of the school.",
    "predicted_sql": "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '40'",
    "gold_sql": "SELECT AdmLName1, District, County, School FROM schools WHERE CharterNum = '0040'",
    "label": false,
    "reason_1": "CharterNum is not written in the correct format. Two zeros should be added",
    "reason_2": "Error WHERE condition value",
    "evidence": ""
  },
  {
    "question_id": 1491,
    "db_id": "debit_card_specializing",
    "question": "Which country has more \"value for money\" gas stations? Please give a total number of \"value for money\" gas stations in each country.",
    "predicted_sql": "SELECT gasstations.country, COUNT(gasstations.gasstationid) AS totalstations FROM gasstations WHERE gasstations.segment = 'Value for money' GROUP BY gasstations.country",
    "gold_sql": "SELECT Country , ( SELECT COUNT(GasStationID) FROM gasstations WHERE Segment = 'Value for money' ) FROM gasstations WHERE Segment = 'Value for money' GROUP BY Country ORDER BY COUNT(GasStationID) DESC LIMIT 1",
    "label": false,
    "reason_1": "GOLD FALSE",
    "reason_2": "FALSE GOLD. The question need data in each country, gold return a sum.",
    "evidence": ""
  },
  {
    "question_id": 711,
    "db_id": "codebase_community",
    "question": "Among products comments with 0 score, what is the total number of users ages 40 years old?",
    "predicted_sql": "SELECT COUNT(DISTINCT T1.UserId) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40",
    "gold_sql": "SELECT COUNT(DISTINCT T1.id) FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Score = 0 AND T2.Age = 40",
    "label": false,
    "reason_1": "ground truth false",
    "reason_2": "FALSE GOLD. userID not commend id",
    "evidence": ""
  },
  {
    "question_id": 20,
    "db_id": "california_schools",
    "question": "How many schools in Amador which the Low Grade is 9 and the High Grade is 12?",
    "predicted_sql": "SELECT COUNT(CDSCode) FROM frpm WHERE `County Name` = 'Amador' AND `Low Grade` = '9' AND `High Grade` = '12'",
    "gold_sql": "SELECT COUNT(T1.`School Name`) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'Amador' AND T1.`Low Grade` = 9 AND T1.`High Grade` = 12",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": ""
  },
  {
    "question_id": 197,
    "db_id": "toxicology",
    "question": "Calculate the average number of oxygen atoms in single-bonded molecules.",
    "predicted_sql": "SELECT AVG(oxygen_count) FROM (SELECT COUNT(CASE WHEN T2.element = 'o' THEN 1 ELSE NULL END) AS oxygen_count FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-' GROUP BY T1.molecule_id)",
    "gold_sql": "SELECT AVG(oxygen_count) FROM (SELECT T1.molecule_id, COUNT(T1.element) AS oxygen_count FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id  WHERE T2.bond_type = '-' AND T1.element = 'o'  GROUP BY T1.molecule_id) AS oxygen_counts",
    "label": false,
    "reason_1": "include the atoms without o",
    "reason_2": "Predicted SQL: Repeated Counting\nGOLD FALSE: Repeated Counting",
    "evidence": "single-bonded molecules refers to bond_type = '-' ; average number of oxygen atom = AVG(element = 'o')"
  },
  {
    "question_id": 1094,
    "db_id": "european_football_2",
    "question": "How much higher in percentage is Ariel Borysiuk's overall rating than that of Paulin Puel?",
    "predicted_sql": "SELECT CAST((aborysiuk.overall_rating - ppuel.overall_rating) AS REAL) * 100 / ppuel.overall_rating AS percentage_difference FROM player_attributes AS aborysiuk INNER JOIN player AS p1 ON aborysiuk.player_api_id = p1.player_api_id INNER JOIN player_attributes AS ppuel ON ppuel.player_api_id = (SELECT player_api_id FROM player WHERE player_name = 'Paulin Puel') WHERE p1.player_name = 'Ariel Borysiuk'",
    "gold_sql": "SELECT (SUM(CASE WHEN t1.player_name = 'Ariel Borysiuk' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Paulin Puel' THEN t2.overall_rating ELSE 0 END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
    "label": false,
    "reason_1": "Wrong agressive function",
    "reason_2": "player_attributes twice",
    "evidence": "how much higher in percentage = MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100);"
  },
  {
    "question_id": 389,
    "db_id": "card_games",
    "question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
    "predicted_sql": "SELECT cards.name, rulings.date FROM cards INNER JOIN rulings ON cards.uuid = rulings.uuid WHERE cards.originalType = 'Creature - Elf';",
    "gold_sql": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'",
    "label": true,
    "reason_1": "",
    "reason_2": "GOLD FALSE: Should return the name of cards",
    "evidence": "Creature - Elf is the originalType;"
  },
  {
    "question_id": 133,
    "db_id": "financial",
    "question": "In 1996, which districts have the highest unemployment rate? List their branch location and district name.",
    "predicted_sql": "SELECT A2 FROM district WHERE A13 = ( SELECT MAX(A13) FROM district )",
    "gold_sql": "SELECT district_id, A2 FROM district ORDER BY A13 DESC LIMIT 1",
    "label": false,
    "reason_1": "no branch information in predicted sql",
    "reason_2": "lack branch location required by question",
    "evidence": "A2 refers to district names; A13 refers to unemploymant rate in 1996"
  },
  {
    "question_id": 1315,
    "db_id": "student_club",
    "question": "How many students of the Student_Club have attended the event \"Women's Soccer\"?",
    "predicted_sql": "SELECT COUNT(DISTINCT link_to_member) AS number_of_students FROM attendance WHERE link_to_event = (SELECT event_id FROM event WHERE event_name = 'Women''s Soccer')",
    "gold_sql": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'Women''s Soccer'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "Women's Soccer is an event name"
  },
  {
    "question_id": 252,
    "db_id": "toxicology",
    "question": "What are the atoms that can bond with the atom that has the element lead?",
    "predicted_sql": "SELECT T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'pb'",
    "gold_sql": "SELECT T2.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T1.element = 'pb'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "atom that has the element lead refers to atom_id where element = 'pb'"
  },
  {
    "question_id": 1197,
    "db_id": "thrombosis_prediction",
    "question": "When was the medical information on patient number 48473 first documented, and what disease did she have?",
    "predicted_sql": "SELECT Description, Diagnosis FROM Patient WHERE ID = 48473",
    "gold_sql": "SELECT `First Date`, Diagnosis FROM Patient WHERE ID = 48473",
    "label": true,
    "reason_1": "",
    "reason_2": "FALSE GOLD, lack of decription",
    "evidence": "medical information first documented refers to Description; disease refers to diagnosis; patient number refers to id"
  },
  {
    "question_id": 846,
    "db_id": "formula_1",
    "question": "Please list the reference names of the drivers who are eliminated in the first period in race number 20.",
    "predicted_sql": "SELECT DISTINCT t2.driverref FROM qualifying AS t1 INNER JOIN drivers AS t2 ON t1.driverid = t2.driverid WHERE t1.raceid = 20 ORDER BY t1.q1 DESC LIMIT 5",
    "gold_sql": "SELECT T2.driverRef FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 20 ORDER BY T1.q1 DESC LIMIT 5",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "driver reference name refers to driverRef; first qualifying period refers to q1; drivers who are eliminated in the first qualifying period refers to 5 drivers with MAX(q1); race number refers to raceId;"
  },
  {
    "question_id": 507,
    "db_id": "card_games",
    "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
    "predicted_sql": "SELECT CAST(SUM(CASE WHEN T2.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.uuid) AS percentage FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T1.language = 'Portuguese (Brazil)'",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
    "label": false,
    "reason_1": "Pred operates on cards instead of sets",
    "reason_2": "wrong granularity",
    "evidence": "Brazil Portuguese translation refers to language = 'Portuguese (Brazil)'; only available online refers to isOnlineOnly = 1; percentage of online only Brazil Portuguese in all Brazil Portuguese cards refers to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)))*100"
  },
  {
    "question_id": 1524,
    "db_id": "debit_card_specializing",
    "question": "What's the nationality of the customer who spent 548.4 in 2012/8/24?",
    "predicted_sql": "SELECT T1.Country FROM gasstations AS T1 INNER JOIN transactions_1k AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Date = '2012-08-24' AND T2.Amount = 548.4",
    "gold_sql": "SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-24' AND T1.Price = 548.4",
    "label": false,
    "reason_1": "Error condition",
    "reason_2": "wrong filter column, amount & price",
    "evidence": "'2012/8/24' can be represented by '2012-08-24'"
  },
  {
    "question_id": 1526,
    "db_id": "debit_card_specializing",
    "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
    "predicted_sql": "SELECT (t2012.Consumption - t2013.Consumption) / t2012.Consumption AS DecreaseRate FROM ( SELECT Consumption FROM yearmonth WHERE CustomerID IN ( SELECT CustomerID FROM transactions_1k WHERE `Date` = '2012-08-25' AND Amount = 634.8 ) AND `Date` = '201212' ) t2012, ( SELECT Consumption FROM yearmonth WHERE CustomerID IN ( SELECT CustomerID FROM transactions_1k WHERE `Date` = '2012-08-25' AND Amount = 634.8 ) AND `Date` = '201312' ) t2013",
    "gold_sql": "SELECT CAST(SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTR(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTR(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
    "label": false,
    "reason_1": "should use price instead of amount",
    "reason_2": "Missing aggregation: to compute the consumption for a year, need to aggregate all consumption records in that year",
    "evidence": "'2012/8/24' can be represented by '2012-08-24'; Consumption decrease rate = (consumption_2012 - consumption_2013) / consumption_2012"
  },
  {
    "question_id": 1478,
    "db_id": "debit_card_specializing",
    "question": "Which segment had the least consumption?",
    "predicted_sql": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Consumption IS NOT NULL ORDER BY T2.Consumption ASC LIMIT 1",
    "gold_sql": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Segment ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
    "label": false,
    "reason_1": "Predicted SQL merely identifies the segments with the minimum value, rather than the total Consumption being the smallest.",
    "reason_2": "Error consumption calculation",
    "evidence": ""
  },
  {
    "question_id": 1285,
    "db_id": "thrombosis_prediction",
    "question": "When is the latest patient's medical data recorded? This patient should have an abnormal level of lactate dehydrogenase.",
    "predicted_sql": "SELECT MAX(`Date`) AS latest_date FROM Laboratory WHERE ID IN ( SELECT ID FROM Patient ORDER BY `First Date` DESC LIMIT 1 ) AND LDH >= 500",
    "gold_sql": "SELECT T1.`First Date` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH >= 500 ORDER BY T1.`First Date` DESC LIMIT 1",
    "label": false,
    "reason_1": "Predicted SQL first identifies the latest patient and then looks for anomalies, but the latest patient is not necessarily abnormal",
    "reason_2": "Error MAX function",
    "evidence": "latest patient refers to ID with MAX('First Date'); abnormal level of lactate dehydrogenase refers to LDH > = 500;"
  },
  {
    "question_id": 304,
    "db_id": "toxicology",
    "question": "List all carcinogenic molecules and their elements.",
    "predicted_sql": "SELECT m.molecule_id, a.element  FROM molecule m  JOIN atom a  ON m.molecule_id = a.molecule_id  WHERE m.label = '+'  GROUP BY m.molecule_id, a.element",
    "gold_sql": "SELECT DISTINCT T2.molecule_id, T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "label = '+' mean molecules are carcinogenic; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium"
  },
  {
    "question_id": 894,
    "db_id": "formula_1",
    "question": "What is the best lap time recorded? List the driver and race with such recorded lap time.",
    "predicted_sql": "SELECT T2.forename, T2.surname, T3.name, T1.milliseconds FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceId = T3.raceId WHERE T1.milliseconds IS NOT NULL ORDER BY T1.milliseconds ASC LIMIT 1",
    "gold_sql": "SELECT T2.milliseconds, T1.forename, T1.surname, T3.name FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId ORDER BY T2.milliseconds ASC LIMIT 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "the best lap time refers to min(milliseconds); List the driver refers to drivers.forename and drivers.surname; List the race refers to races.name"
  },
  {
    "question_id": 762,
    "db_id": "superhero",
    "question": "Which power do superheroes have the most of?",
    "predicted_sql": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T2.power_name) DESC LIMIT 1",
    "gold_sql": "SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id GROUP BY T2.power_name ORDER BY COUNT(T1.hero_id) DESC LIMIT 1",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "power that superheroes have the most refers to MAX(COUNT(power_name))"
  },
  {
    "question_id": 621,
    "db_id": "codebase_community",
    "question": "What are the name of badges that users who have the lowest reputation obtained?",
    "predicted_sql": "SELECT DISTINCT badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.Reputation = (SELECT MIN(Reputation) FROM users) AND badges.Name IS NOT NULL;",
    "gold_sql": "SELECT T2.Name, T1.Reputation FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Reputation = (SELECT MIN(Reputation) FROM users)",
    "label": true,
    "reason_1": "GOLD FALSE: missing DISTINCT keyword",
    "reason_2": "",
    "evidence": "lowest reputation refers to Min(Reputation); user refers to UserId"
  },
  {
    "question_id": 595,
    "db_id": "codebase_community",
    "question": "Which user have only one post history per post and having at least 1000 views?",
    "predicted_sql": "SELECT postHistory.UserId FROM postHistory INNER JOIN users ON postHistory.UserId = users.Id WHERE users.Views >= 1000 GROUP BY postHistory.UserId HAVING COUNT(DISTINCT postHistory.PostId) = 1",
    "gold_sql": "SELECT T2.UserId FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.ViewCount >= 1000 GROUP BY T2.UserId HAVING COUNT(DISTINCT T2.PostHistoryTypeId) = 1",
    "label": false,
    "reason_1": "Error JOIN",
    "reason_2": "Wrong condition column.",
    "evidence": "having at least 1000 view refers to Views > = 1000; user refers to UserId"
  },
  {
    "question_id": 1033,
    "db_id": "european_football_2",
    "question": "What is the average height of players born between 1990 and 1995?",
    "predicted_sql": "SELECT AVG(height) FROM Player WHERE birthday >= '1990-01-01 00:00:00' AND birthday < '1996-01-01 00:00:00'",
    "gold_sql": "SELECT SUM(height) / COUNT(id) FROM Player WHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "average height = DIVIDE(SUM(height), COUNT(id)); players born between 1990 and 1995 refers to birthday > = '1990-01-01 00:00:00' AND birthday < '1996-01-01 00:00:00';"
  },
  {
    "question_id": 418,
    "db_id": "card_games",
    "question": "What kind of printing is on the card that Daren Bader created?",
    "predicted_sql": "SELECT cards.availability FROM cards WHERE cards.artist = 'Daren Bader';",
    "gold_sql": "SELECT DISTINCT availability FROM cards WHERE artist = 'Daren Bader'",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "kind of printing refers to availability; Daren Bader created refers to artist = 'Daren Bader'"
  },
  {
    "question_id": 465,
    "db_id": "card_games",
    "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
    "predicted_sql": "SELECT COUNT(*) > 0 FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.name = 'Ancestor''s Chosen' AND foreign_data.language = 'Korean'",
    "gold_sql": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
    "label": false,
    "reason_1": "should use set level instead of card level",
    "reason_2": "wrong condition uuid and setCode",
    "evidence": "set of cards with \"Ancestor''s Chosen\" in it refers to name = 'Ancestor''s Chosen'; Korean version refers to language = 'Korean'"
  },
  {
    "question_id": 244,
    "db_id": "toxicology",
    "question": "Is the molecule with the most double bonds carcinogenic?",
    "predicted_sql": "SELECT m.label FROM molecule m JOIN ( SELECT molecule_id, COUNT(*) AS double_bond_count FROM bond WHERE bond_type = '=' GROUP BY molecule_id ORDER BY double_bond_count DESC LIMIT 1 ) AS most_double_bonds ON m.molecule_id = most_double_bonds.molecule_id",
    "gold_sql": "SELECT T1.label FROM molecule AS T1 INNER JOIN (SELECT T.molecule_id, COUNT(T.bond_type) AS bond_count FROM bond AS T WHERE T.bond_type = '=' GROUP BY T.molecule_id HAVING bond_count = (SELECT MAX(bond_count) FROM (SELECT molecule_id, COUNT(bond_type) AS bond_count FROM bond WHERE bond_type = '=' GROUP BY molecule_id) AS subquery) ORDER BY bond_count DESC) AS T2 ON T1.molecule_id = T2.molecule_id",
    "label": true,
    "reason_1": "",
    "reason_2": "",
    "evidence": "double bond refers to bond_type = ' = '; label = '+' mean molecules are carcinogenic"
  },
  {
    "question_id": 562,
    "db_id": "codebase_community",
    "question": "For the post which got 1910 view counts, how many comments does it get?",
    "predicted_sql": "SELECT CommentCount FROM posts WHERE ViewCount = 1910",
    "gold_sql": "SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.ViewCount = 1910",
    "label": true,
    "reason_1": "",
    "reason_2": "GOLD FALSE: Since the question is asking for how many comments, so should return SELECT COUNT(comments.Id)",
    "evidence": ""
  },
  {
    "question_id": 942,
    "db_id": "formula_1",
    "question": "What is the average fastest lap time in seconds for Lewis Hamilton in all the Formula_1 races?",
    "predicted_sql": "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 4, 2) AS REAL) * 60 + CAST(SUBSTR(T2.fastestLapTime, 7) AS REAL)) AS average_fastest_lap_time_seconds FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.forename = 'Lewis' AND T1.surname = 'Hamilton'",
    "gold_sql": "SELECT AVG(CAST(SUBSTR(T2.fastestLapTime, 1, INSTR(T2.fastestLapTime, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(T2.fastestLapTime, INSTR(T2.fastestLapTime, ':') + 1) AS REAL)) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.surname = 'Hamilton' AND T1.forename = 'Lewis'",
    "label": false,
    "reason_1": "wrong string processing",
    "reason_2": "Error calculation",
    "evidence": "average fastest lap time = avg(fastestLapTime); The time is recorded on 'MM:SS.mmm'"
  },
  {
    "question_id": 1486,
    "db_id": "debit_card_specializing",
    "question": "Is it true that more SMEs pay in Czech koruna than in euros? If so, how many more?",
    "predicted_sql": "SELECT SUM(CASE WHEN T2.Currency = 'CZK' THEN T1.Amount ELSE 0 END) - SUM(CASE WHEN T2.Currency = 'EUR' THEN T1.Amount ELSE 0 END) AS AmountDifference FROM transactions_1k AS T1 JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'SME'",
    "gold_sql": "SELECT SUM(Currency = 'CZK') - SUM(Currency = 'EUR') FROM customers WHERE Segment = 'SME'",
    "label": false,
    "reason_1": "the question require the quantity of SMEs difference rather than value amount.",
    "reason_2": "clear definition of more smes",
    "evidence": "Amount of more SMEs = Total of SMEs pay using Currency CZK - Total of SMEs pay using Currency EUR"
  },
  {
    "question_id": 1015,
    "db_id": "formula_1",
    "question": "In which Formula_1 race was the lap record for the Austrian Grand Prix Circuit set?",
    "predicted_sql": "SELECT T3.name FROM races AS T1 INNER JOIN lapTimes AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T1.circuitId = T3.circuitId WHERE T1.name = 'Austrian Grand Prix' ORDER BY T2.milliseconds LIMIT 1",
    "gold_sql": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL ) SELECT T2.name FROM races AS T2 INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN results AS T1 on T2.raceId = T1.raceId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix'",
    "label": false,
    "reason_1": "use results",
    "reason_2": "wrong condition, fastest_lap_times and millisenconds",
    "evidence": "lap record means the fastest time recorded which refers to time"
  },
  {
    "question_id": 451,
    "db_id": "card_games",
    "question": "How many cards available in paper have a positive starting maximum hand size?",
    "predicted_sql": "SELECT COUNT(*) FROM cards WHERE cards.availability LIKE '%paper%' AND cards.hand LIKE '+%';",
    "gold_sql": "SELECT SUM(CASE WHEN availability = 'paper' AND hAND = '3' THEN 1 ELSE 0 END) FROM cards",
    "label": false,
    "reason_1": "not fit the evidence required",
    "reason_2": "hand=3 not satisfied",
    "evidence": "available in paper refers to availability like '%paper%'; have a positive starting maximum hand size refers to hand = '3'"
  },
  {
    "question_id": 861,
    "db_id": "formula_1",
    "question": "What is his number of the driver who finished 0:01:54 in the Q3 of qualifying race No.903?",
    "predicted_sql": "SELECT number FROM qualifying WHERE q3 LIKE '1:54%' AND raceId = 903",
    "gold_sql": "SELECT T2.number FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 903 AND T1.q3 LIKE '1:54%'",
    "label": true,
    "reason_1": "",
    "reason_2": "no limit driver",
    "evidence": "race number refers to raceId; finished 0:0M:SS in the Q3 refers to q3 LIKE 'M:SS%'"
  },
  {
    "question_id": 205,
    "db_id": "toxicology",
    "question": "Identify by their ID the molecules in which there is carbon.",
    "predicted_sql": "SELECT atom.molecule_id FROM atom WHERE atom.element = 'si';",
    "gold_sql": "SELECT T.molecule_id FROM atom AS T WHERE T.element = 'c'",
    "label": false,
    "reason_1": "Error condition",
    "reason_2": "Predicted SQL used the wrong filtering condition element = 'si'; it should have been element = 'c'.",
    "evidence": "carbon refers to element = 'c';"
  }
]