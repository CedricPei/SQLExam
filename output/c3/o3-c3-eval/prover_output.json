[
  {
    "question_id": 5,
    "result": {
      "expected_answer": "A single integer: the number of schools whose SAT average Math score exceeds 400 and whose Virtual field is 'F' (exclusively virtual).",
      "sql_description": "Counts (COUNT(*)) all schools joined with their SAT scores where AvgScrMath is less than 400 and Virtual = 'F'.",
      "reason": "The query uses AvgScrMath < 400 instead of > 400, contradicting the required condition of greater than 400. Anchor on score direction is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 17,
    "result": {
      "expected_answer": "Charter numbers of schools whose average writing score is greater than 499, ordered (ranked) by that average writing score from highest to lowest; charter numbers must be non-NULL.",
      "sql_description": "Gets charter numbers for schools whose average writing score equals exactly 499 and leaves them unordered; does not exclude NULL charter numbers.",
      "reason": "Violates key anchors: uses equality instead of greater-than filter (>499), omits ordering/ranking by score, and does not ensure charter numbers are non-NULL.",
      "verdict": false
    }
  },
  {
    "question_id": 25,
    "result": {
      "expected_answer": "List each school located in the city of Riverside whose mean SAT Average Math score (averaged over its records) is greater than 400, and show the funding type for each such school.",
      "sql_description": "Joins schools with satscores, filters rows where schools.city = 'Riverside', groups by school code, keeps groups whose AVG(AvgScrMath) > 400, and returns the FundingType column for those groups.",
      "reason": "Query filters and computes the correct metric but only returns FundingType; it does not return the schools’ names, which the question explicitly asks for (\"Name schools … what is the funding type\"). Required anchor (school names) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 26,
    "result": {
      "expected_answer": "Names of high schools located in Monterey (city or county) whose FRPM Count for ages 15-17 exceeds 800, together with each school’s full address: Street, City, State, and Zip.",
      "sql_description": "Joins schools and frpm, keeps rows where City = ‘Monterey’ and Free Meal Count (Ages 5-17) > 800, returning School, Street, City and Zip.",
      "reason": "Missing required anchors: (1) no filter identifying high schools; (2) uses Free Meal Count instead of FRPM Count (free OR reduced meals); (3) output omits State so address is not ‘full’. Therefore query does not satisfy the question.",
      "verdict": false
    }
  },
  {
    "question_id": 32,
    "result": {
      "expected_answer": "List of the eligible free or reduced-price meal rates (i.e., Percent (%) Eligible FRPM (K-12) or FRPM Count (K-12)/Enrollment (K-12)) for the five schools serving grades 1-12 (K-12) that have the highest free-or-reduced meal counts, restricted to schools whose School Ownership Code (SOC) equals 66.",
      "sql_description": "Selects Percent (%) Eligible Free (K-12) from schools joined to frpm where schools.Charter = 66 and GSoffered = '1-12', orders by Free Meal Count (K-12) descending, limits to 5 rows.",
      "reason": "1) Uses Charter = 66 instead of SOC = 66, so required ownership code anchor is wrong.\n2) Filters on grade span ‘1-12’ but not ‘K-12’; acceptable only if data uses that exact code (uncertain).\n3) Orders by Free Meal Count, not FRPM Count, and returns Percent Eligible Free, not the required FRPM rate. Multiple key anchors (ownership code, FRPM vs free) are missing or incorrect, so the query does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 31,
    "result": {
      "expected_answer": "The two values of Percent (%) Eligible Free (K-12) that correspond to the schools ranked 10th and 11th in Enrollment (K-12) after sorting all schools in descending order of enrollment.",
      "sql_description": "Returns the Percent (%) Eligible Free (K-12) for the top 11 schools when ordered by Enrollment (K-12) descending; includes ranks 1 through 11.",
      "reason": "The query does not isolate the 10th and 11th positions; it returns the first eleven rows. Missing OFFSET to skip the first nine schools, so required anchor (exact ranks 10 and 11) is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 41,
    "result": {
      "expected_answer": "Names of exclusively virtual schools (Virtual = 'F') that rank within the top 5 highest average SAT reading scores inside their own county; this evaluation must be done separately for every county.",
      "sql_description": "Joins SAT scores with schools, keeps exclusively virtual schools, globally orders all of them by average reading score, and returns only the first 5 rows overall.",
      "reason": "The query applies a single global ranking and LIMIT 5 instead of ranking within each county. Missing the county-partition anchor ‘top 5 in their respective counties’.",
      "verdict": false
    }
  },
  {
    "question_id": 48,
    "result": {
      "expected_answer": "A numeric ratio: (number of schools in Orange County with StatusType = 'Merged' and DOCType = 'Unified School District') divided by (number of schools in Orange County with StatusType = 'Merged' and DOCType = 'Elementary School District').",
      "sql_description": "Counts merged schools in the schools table filtered to county = 'Orange'; numerator is those whose DOCType is 'Unified School District', denominator is those whose DOCType is 'Elementary School District', then returns their quotient.",
      "reason": "All required anchors are present: StatusType='Merged', county restricted to Orange, differentiation by district type (Unified vs Elementary). Division yields the requested ratio. Interpreting both groups as within Orange County is reasonable and not contradicted.",
      "verdict": true,
      "evidence": "sql_result shows column ratio_merged_schools with value 0 (row 0)."
    }
  },
  {
    "question_id": 47,
    "result": {
      "expected_answer": "A single number: (number of schools opened in 1980 in Alameda County with DOC = 52) divided by 12, i.e., the average schools opened per month in 1980.",
      "sql_description": "Counts rows where county = 'Alameda', District = 52, and year(opendate) = 1980, then divides that count by 12.",
      "reason": "Required anchor 'DOC = 52' is mis‐applied: query filters on the District column instead of the DOC column, so it does not restrict to Elementary School District. Hence the logic does not match the question.",
      "verdict": false
    }
  },
  {
    "question_id": 85,
    "result": {
      "expected_answer": "For any school where the administrator’s first name is Alusine, return that school’s district code together with the calculated Percent (%) Eligible Free (K-12) (Free Meal Count ÷ Enrollment × 100).",
      "sql_description": "Joins schools with frpm on CDSCode, keeps rows whose AdmFName1 equals 'Alusine', calculates (Free Meal Count / Enrollment)*100, and outputs the associated District Code plus this percentage.",
      "reason": "All explicit anchors are satisfied: administrator first name filter, correct percentage formula, and inclusion of district code. Output columns match what the question requests.",
      "verdict": true,
      "evidence": "sql_result shows columns [District Code, Percent Eligible Free (K-12)] with one row (64857, 70.15…), matching the requested information."
    }
  },
  {
    "question_id": 77,
    "result": {
      "expected_answer": "List each school in Los Angeles County whose GSserved is Kindergarten–9th grade together with that school’s Percent (%) Eligible FRPM (Ages 5-17) value (FRPM Count ÷ Enrollment for ages 5-17, or directly the stored percentage).",
      "sql_description": "Finds schools in Los Angeles with GSserved = 'K-9', joins to FRPM and SAT tables, then outputs the school name and (PercentEligibleFRPM(Ages5-17) / enroll12 * 100).",
      "reason": "Percent (%) Eligible FRPM (Ages 5-17) is already stored or should be computed as FRPM Count ÷ Enrollment within the FRPM table. The query instead divides that percentage by an unrelated SAT enrollment value and multiplies by 100, producing an incorrect metric. It also requires a SAT record, potentially omitting valid schools. Anchor for correct percentage calculation is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 93,
    "result": {
      "expected_answer": "The number of distinct male clients whose home district is in the region \"North Bohemia\" (district.A3) and whose district’s average salary (district.A11) exceeds 8000.",
      "sql_description": "Joins client-district-account-trans, restricts to male clients in districts with region = 'north Bohemia', groups by each client and retains only those whose own average transaction amount is greater than 8000, then counts the remaining groups.",
      "reason": "Uses AVG(trans.amount) instead of the district field A11 to impose the >8000 condition, and therefore filters on the wrong attribute; also requires clients to have transaction records. The mandatory anchor \"district average salary (A11) > 8000\" is missing/incorrectly implemented.",
      "verdict": false
    }
  },
  {
    "question_id": 99,
    "result": {
      "expected_answer": "Account id(s) whose account opening date is in 1993 and which, among all such accounts that have a loan with duration > 12 months, possess the single highest approved loan amount (return the account id(s) that tie for that top amount).",
      "sql_description": "For each account in the loan table, it selects the maximum loan amount where that loan’s duration > 12 and the LOAN approval date starts with 1993, returning one row per account.",
      "reason": "1) Uses loan.date instead of account.date, so the 1993 anchor applies to loan approval date, not account opening date.\n2) Returns every qualifying account with its own max amount instead of restricting to the account(s) with the overall highest amount.\nBoth required anchors (correct 1993 field and ‘highest approved amount’ global filter) are not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 87,
    "result": {
      "expected_answer": "List of administrator email addresses for schools that 1) are in San Bernardino County, 2) belong to the San Bernardino City Unified district, 3) opened between 2009-01-01 and 2010-12-31, and 4) have a school type of either “Intermediate/Middle Schools (Public)” (SOC 62) or “Unified School”.",
      "sql_description": "Selects AdmEmail1 from schools where MailCity = 'San Bernardino', District = 'San Bernardino City Unified', SOCType equals either 'Intermediate/Middle Schools (Public)' or 'Unified School', and OpenDate is between 2009-01-01 and 2010-12-31.",
      "reason": "All requested constraints (district, county implicitly via unique district, opening date range, target school types) are effectively met and the query returns administrator email(s). The required field (email address) is correctly selected.",
      "verdict": true,
      "evidence": "sql_result contains column AdmEmail1 with value a.lucero@realjourney.org (row 0)."
    }
  },
  {
    "question_id": 116,
    "result": {
      "expected_answer": "A single numeric value: the percentage increase [(balance on 1998-12-27 − balance on 1993-03-22) / balance on 1993-03-22 * 100] for the account belonging to the first loan approved on 1993-07-05.",
      "sql_description": "1) Picks one account_id with a loan dated 1993-07-05 (LIMIT 1).\n2) Retrieves the balance on 1993-07-05 for that account.\n3) Retrieves the balance on 1993-03-22 for that same account.\n4) Returns the intersection of the two balance sets (i.e., a balance value that is identical on both dates).",
      "reason": "Query uses the wrong comparison date (1993-07-05 instead of 1998-12-27) and never computes a percentage increase; it merely lists any balance common to the two chosen dates. Required anchors (date 1998-12-27 and increase-rate calculation) are missing.",
      "verdict": false
    }
  },
  {
    "question_id": 39,
    "result": {
      "expected_answer": "The mean (average) value of the NumTstTakr field for schools located in Fresno whose OpenDate falls within 1980.",
      "sql_description": "Joins satscores with schools on the school code, keeps rows where schools.City = 'Fresno' and schools.OpenDate is between 1980-01-01 and 1980-12-31, then returns AVG(numtsttakr).",
      "reason": "All explicit anchors are satisfied: city is Fresno, OpenDate is restricted to the 1980 window, and the measure averaged is NumTstTakr. Although multiple SAT score rows per school could exist, the question does not specify per-school aggregation, so averaging across the filtered records is a reasonable interpretation.",
      "verdict": true,
      "evidence": "sql_result shows one column AVG(numtsttakr) with value 203.8"
    }
  },
  {
    "question_id": 36,
    "result": {
      "expected_answer": "Full name(s) (first and last) of the administrator(s) of the school whose NumGE1500 value is the highest among all schools.",
      "sql_description": "Joins satscores with schools, then orders rows by NumTstTakr descending first, NumGE1500 descending second, taking the first row; returns that school’s name plus the first administrator’s first and last names.",
      "reason": "Required anchor is the maximum NumGE1500. Query prioritises NumTstTakr, so it may pick a school that does not have the highest NumGE1500. Also returns only AdmFName1/AdmLName1, omitting other administrators. Anchor violation makes the answer incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 45,
    "result": {
      "expected_answer": "For every school whose administrator is Ricci Ulrich, return the school name together with its average SAT writing score.",
      "sql_description": "Joins satscores with schools by school code, keeps rows where the first administrator’s first and last names are Ricci and Ulrich, then groups by the school name and outputs that name plus the average of AvgScrWrite for that school.",
      "reason": "Uses the appropriate administrator fields as an anchor, joins to get writing scores, aggregates per school, and outputs the required pairs. This satisfies the question’s requirements; averaging across possible multiple records per school is a reasonable interpretation of “average writing score.”",
      "verdict": true,
      "evidence": "Result columns: sname ('Buchanan High') and AVG(satscores.avgscrwrite) (507.0) show the expected school-score pair."
    }
  },
  {
    "question_id": 94,
    "result": {
      "expected_answer": "Return two things: 1) the account_id(s) that belong to female client(s) who are simultaneously the oldest among all female clients and whose district has the lowest A11 (average salary); 2) a numeric value giving the difference between the highest and the lowest district average salary (gap = max(A11) − min(A11)).",
      "sql_description": "The query chooses ONE female client with the earliest birth_date (ties arbitrarily), fetches all accounts that merely reside in her district, then demands that this same district be both the minimum-salary district and the maximum-salary district, producing no rows. It never calculates the salary gap.",
      "reason": "Missing anchors: (a) correct linking of account to its female owner, (b) ensuring the client is also in the lowest-salary district, (c) calculation of the gap value. Additionally it imposes an impossible condition that one district be both lowest and highest salary, so returns empty result.",
      "verdict": false
    }
  },
  {
    "question_id": 50,
    "result": {
      "expected_answer": "Return the name of the school that ranks 7th highest in AvgScrMath across all schools and its postal/mailing street address.",
      "sql_description": "Finds schools with SAT scores, orders them by AvgScrMath descending, then takes the row after skipping the first 5 (i.e., 6th highest) and outputs sname and the physical Street column.",
      "reason": "Anchor mis-handled: OFFSET 5 yields the 6th highest school, not the 7th. Therefore the query does not target the requested rank.",
      "verdict": false
    }
  },
  {
    "question_id": 100,
    "result": {
      "expected_answer": "A single integer: the count of female clients born before 1950, whose district name is 'Sokolov', and who have opened at least one account.",
      "sql_description": "Counts rows in client joined to district where gender = 'F', birth_date < 1950-01-01, and district name equals the literal 'Slokolov'. Does not reference any account table.",
      "reason": "The query omits the required anchor that the customer has an opened account; it only filters by client attributes. It also filters on 'Slokolov', which may miss the intended district 'Sokolov'. Therefore it does not satisfy the question requirements.",
      "verdict": false
    }
  },
  {
    "question_id": 136,
    "result": {
      "expected_answer": "Count of loans (records in loan table) whose approval date is between 1995-01-01 and 1997-12-31, amount ≥ 250,000, and whose linked account has frequency = 'POPLATEK MESICNE' (monthly statements).",
      "sql_description": "Counts distinct loan_ids satisfying the date, amount and frequency filters AND additionally requires loan.status = 'approved'.",
      "reason": "The status filter introduces a non-existent value ('approved'); according to schema, status takes codes A–D. This eliminates all valid loans, so the query does not capture the requested set and returns 0 even if qualifying loans exist. Required anchor (approved loans) is already implicit for all rows; adding wrong literal contradicts schema.",
      "verdict": false
    }
  },
  {
    "question_id": 79,
    "result": {
      "expected_answer": "Identify whether San Diego or Santa Barbara has the larger number of exclusively-virtual schools (Virtual = 'F') and give that county together with the count.",
      "sql_description": "Counts Virtual='F' schools separately for San Diego and Santa Barbara, then returns only the higher of the two counts (single numeric value) with no county identifier.",
      "reason": "Query omits the county name, so it does not say *which* county has the larger number, a required anchor of the question.",
      "verdict": false
    }
  },
  {
    "question_id": 125,
    "result": {
      "expected_answer": "For every loan with status 'D' (running and client in debt), return the name or identifier of its district (and possibly the state/region if that is what 'state' refers to) together with the percentage change in unemployment from 1995 (A12) to 1996 (A13).",
      "sql_description": "Finds loans with status 'D', joins to their district, then outputs the 1995 unemployment rate (A12) and the computed percentage increment to 1996.",
      "reason": "The query returns A12 (1995 unemployment rate) instead of the district identifier/name and omits any state/region field. Required anchor \"district\" (and possibly state) is missing from the output, so it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 83,
    "result": {
      "expected_answer": "1) A single total count of schools that are magnet programs, serve grade span K-8, and have NSLP Provision Status = 'Multiple Provision Types'. 2) For those K-8 magnet schools, a list of each city plus how many such schools are in that city.",
      "sql_description": "Returns, for each city, the number of schools whose Magnet flag = 1 and whose GSoffered contains 'K-8'. It does not filter on NSLP Provision Status and does not compute an overall total.",
      "reason": "The query omits the required anchor \"Multiple Provision Types\" (NSLP Provision Status) and therefore counts many schools that do not satisfy this condition. It also does not provide the overall count requested in the first part of the question.",
      "verdict": false
    }
  },
  {
    "question_id": 92,
    "result": {
      "expected_answer": "The numeric count of districts whose average salary (column district.A11) is greater than 6000 and less than 10000, restricting to districts that have at least one female client.",
      "sql_description": "Joins district with client, keeps only female clients, groups by district, and returns each district_id whose average of client.birth_date is between 6000 and 10000.",
      "reason": "Uses client.birth_date instead of district.A11, so the salary condition is not checked at all; also returns individual district_ids instead of the requested count. Required anchor on average salary is missing and wrong field used.",
      "verdict": false
    }
  },
  {
    "question_id": 169,
    "result": {
      "expected_answer": "A single numeric value representing the percentage growth of the total approved loan amount for male clients from 1996 to 1997.",
      "sql_description": "Computes two separate totals: SUM(amount) for 1997 rows and, in a sub-query, SUM(amount) for 1996 rows, both restricted to records joined to a male client through l.account_id = c.client_id; outputs the two sums but no growth-rate calculation.",
      "reason": "The question asks for the growth rate (percentage change), but the SQL only returns the two yearly totals without performing the growth-rate formula. Required anchor (growth calculation) is missing, so the answer is incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 152,
    "result": {
      "expected_answer": "Average (mean) of 1995 crime counts (A15) for every region/district that 1) has more than 4000 crimes in 1995 and 2) has at least one account whose opening date is in 1997 or later.",
      "sql_description": "Takes the mean of A15 in table district where A15 > 4000 and the district id appears in any account whose date string’s first four characters are lexicographically >= '1997'.",
      "reason": "The date is stored in YYMMDD format (e.g., 970101). Using substr(date,1,4) yields a value like '9701', which is compared to the string '1997'. Because '9xxx' > '1xxx', the predicate wrongly accepts virtually all 1990-s dates (93, 94, 95, 96, etc.), not only 1997+. Thus the mandatory anchor ‘accounts opened starting from 1997’ is not enforced.",
      "verdict": false
    }
  },
  {
    "question_id": 98,
    "result": {
      "expected_answer": "Account IDs whose loans were approved in 1997, have the minimum approved amount among those 1997 loans, and whose account frequency is the weekly issuance 'POPLATEK TYDNE'.",
      "sql_description": "Finds account_ids from the loan table with approval dates in 1997 whose loan amount equals the minimum amount among all 1997 loans; does not consider the account's frequency.",
      "reason": "Fails to apply the required weekly issuance anchor (frequency = 'POPLATEK TYDNE'). Therefore it may include accounts that are not weekly issuance accounts.",
      "verdict": false
    }
  },
  {
    "question_id": 115,
    "result": {
      "expected_answer": "A single percentage value: (number of male clients / total clients * 100) for the one district in the region 'south Bohemia' that has the largest value in column A4 (number of inhabitants).",
      "sql_description": "Computes the percentage of male clients among all clients whose district belongs to region 'south Bohemia'; it aggregates across every south-Bohemia district without selecting the one with the highest A4.",
      "reason": "Missing required anchor: does not restrict to the south-Bohemia branch with the biggest number of inhabitants (max A4). Therefore it answers a broader question than asked.",
      "verdict": false
    }
  },
  {
    "question_id": 173,
    "result": {
      "expected_answer": "1) The number of times account_id 3 made a transaction whose purpose (k_symbol) corresponds to requesting an account statement (likely k_symbol = 'SLUZBY'). 2) The purpose (k_symbol description) associated with debits whose total amount equals 3539 for account 3.",
      "sql_description": "Counts transactions and sums their amounts for account_id = 3 where type = 'SI' and k_symbol = 'SLIPOVANI'; returns the count as statement_request_frequency and the sum as total_debit.",
      "reason": "Uses a non-existent or irrelevant type value ('SI') and an unrecognised k_symbol ('SLIPOVANI'); thus misses the required anchor for statement requests. It does not return the aim (k_symbol) of the 3539 debit, only a sum. Therefore it fails to satisfy both parts of the question.",
      "verdict": false
    }
  },
  {
    "question_id": 194,
    "result": {
      "expected_answer": "Each client_id and the client's current age for clients who both 1) hold a high-level (gold) credit card (card.type = 'gold') and 2) are eligible for loans, i.e., their disposition type is 'OWNER'.",
      "sql_description": "Joins client → disp → card, keeps rows where card.type = 'gold', then returns client_id and an age calculation. It does NOT restrict disp.type to 'OWNER'.",
      "reason": "The required anchor disp.type = 'OWNER' (eligibility for loans) is missing, so non-eligible clients can appear in the result.",
      "verdict": false
    }
  },
  {
    "question_id": 198,
    "result": {
      "expected_answer": "A single numeric value representing the average number of single (bond_type='-') bonds found in each carcinogenic (label='+') molecule.",
      "sql_description": "For every molecule whose label is '+', it counts how many of its bonds are single bonds (bond_type='-'); then it averages those counts across all such molecules, returning that average.",
      "reason": "Query applies the carcinogenic filter, counts only single bonds, groups by molecule, and averages the per-molecule counts. This directly yields the requested average number of single bonds per carcinogenic molecule, matching a reasonable interpretation of the question.",
      "verdict": true,
      "evidence": "sql_result shows one column AVG(single_bonded) with value 20.25, i.e., the computed average."
    }
  },
  {
    "question_id": 95,
    "result": {
      "expected_answer": "Account IDs for those clients who are simultaneously the overall youngest (i.e., have the most recent birth_date) and whose district’s A11 value equals the highest average salary recorded in the district table.",
      "sql_description": "Returns account.account_id for clients whose account_id happens to equal client_id, who have the MIN(birth_date) within each district (oldest clients), and then joins to every district without restricting to the global highest A11 (the subquery merely re-lists each district’s own A11).",
      "reason": "Violates both required anchors: 1) Uses MIN(birth_date), selecting oldest instead of youngest; 2) Does not restrict to districts with the highest average salary—join condition keeps all districts. Thus the result set does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 119,
    "result": {
      "expected_answer": "Return each account created in 1993 whose statements are issued after each transaction (frequency = 'POPLATEK PO OBRATU'); for every such account show: 1) account_id, 2) the district name (A2), 3) the district region (A3).",
      "sql_description": "Finds accounts whose creation date equals the literal string '1993', forces a join to card (wrongly on account_id = card.disp_id) and requires card.issued to be after every transaction date, also filters frequency = 'POPLATEK PO OBRATU'. Returns the account id with its district name and region.",
      "reason": "Misses anchors and mis-joins: 1) creation year filter is wrong; date column stores YYMMDD so comparing to '1993' will match none. 2) Statement-after-transaction should be captured by frequency alone; the extra condition card.issued > trans.date is unjustified and uses an incorrect join field, excluding correct rows. Therefore the query does not correctly retrieve the requested accounts.",
      "verdict": false
    }
  },
  {
    "question_id": 200,
    "result": {
      "expected_answer": "List of molecule_id values for molecules that (1) have at least one bond with bond_type = '#' (triple bond) and (2) are labeled '+' (carcinogenic). No further numerical restriction.",
      "sql_description": "Finds carcinogenic molecules having triple bonds, but then keeps only those whose joined rows count to exactly 3 (because of HAVING COUNT(bond.bond_id) = 3, inflated by the join with connected/atom).",
      "reason": "Adds an unjustified anchor: exactly three matching rows (effectively three triple-bond records). Molecules with one, two, four, etc. triple bonds are wrongly excluded, so the query does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 207,
    "result": {
      "expected_answer": "List of element symbols that participate in any bond whose bond_type is '=' (double bond). Both atoms connected by such bonds should be considered.",
      "sql_description": "Gets the element for atoms where the atom is the FIRST endpoint (connected.atom_id) of bonds whose bond_type value equals the literal ' = ' (space-padded). It does not consider atoms appearing as connected.atom_id2.",
      "reason": "1) Uses literal ' = ' (with spaces) so likely misses all double bonds whose value is exactly '='; execution shows empty result. 2) Even if bond_type matched, it only captures elements linked through connected.atom_id, omitting elements that appear only in connected.atom_id2, so the returned set can be incomplete. Required anchor (include both atoms of each double bond) is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 112,
    "result": {
      "expected_answer": "The name of the district (column A2 in table district) where the female client born on 1976-01-29 opened her account; i.e., the district of her account(s).",
      "sql_description": "Finds the client with gender='F' and birth_date='1976-01-29', then returns the district names of ALL accounts whose district_id equals that client’s district_id (without verifying that those accounts belong to her), yielding many duplicate rows.",
      "reason": "Missing anchor: account ownership linkage. The query never ties the selected account rows to the specific client (e.g., via a disposition/owner link or client_id). It merely matches on district_id, so it can include accounts of other clients in the same district. Therefore it does not reliably answer which district *her* account is in.",
      "verdict": false
    }
  },
  {
    "question_id": 129,
    "result": {
      "expected_answer": "The ten districts with the highest total value of withdrawal (type = 'VYDAJ', i.e., non-credit-card) transactions during January 1996, optionally accompanied by those totals.",
      "sql_description": "Aggregates the sum of amounts for all transactions with type = 'VYDAJ' and date starting with '1996-01', groups by district name (district.A2), orders the sums descending, and returns the first 10 districts with their totals.",
      "reason": "Query applies the required date (January 1996) and withdrawal type filter, aggregates by district name, orders by total withdrawal value, and limits to ten results—matching a reasonable interpretation that “top” refers to largest summed withdrawal amounts.",
      "verdict": true,
      "evidence": "sql_result columns: A2 (district names) and total_withdrawal; 10 rows returned, ordered descending."
    }
  },
  {
    "question_id": 118,
    "result": {
      "expected_answer": "A single percentage value: (number of accounts with loan amount <100,000 whose loan status is 'C') divided by (total number of accounts with loan amount <100,000) times 100.",
      "sql_description": "Counts loans with amount<100,000 and status='C' and divides that same count by itself, returning 100%.",
      "reason": "Denominator should include all loans (or accounts) with amount<100,000 regardless of status, but query restricts denominator to status='C', guaranteeing 100%, so it does not compute the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 128,
    "result": {
      "expected_answer": "The 9 districts with the greatest number of female account holders, listed from highest to lowest, returning each district name (A2) together with that count.",
      "sql_description": "Counts rows produced by joining district with ALL female clients in that district and ALL accounts in the same district, then groups by district name, orders by that multiplied count descending, and returns the first 10 districts.",
      "reason": "1) The join multiplies female-client rows by all accounts in the district, so the figure is not the number of female account holders but an inflated product of clients × accounts. 2) It outputs 10 rows instead of the requested 9. Both violate explicit anchors (correct count measure and top-9 requirement).",
      "verdict": false
    }
  },
  {
    "question_id": 215,
    "result": {
      "expected_answer": "A single integer: the number of distinct atoms whose element is iodine (i) or sulfur (s) that participate in single bonds (bond_type='-'). Atoms should be counted no matter whether they appear as the first or second endpoint of the bond.",
      "sql_description": "Counts distinct atom.atom_id where the atom element is 'i' or 's' and the atom is listed in connected.atom_id for a bond whose type is '-' (single). It ignores atoms that appear only in connected.atom_id2.",
      "reason": "The query enforces bond_type '-' and distinct atoms, but it only matches atoms when they occur in connected.atom_id, omitting those that appear solely in connected.atom_id2. Thus it can under-count, failing to consider all relevant atoms.",
      "verdict": false
    }
  },
  {
    "question_id": 226,
    "result": {
      "expected_answer": "The share (in percent) of TR008’s bonds whose bond_type is '=' (double bond) – i.e. 100 * (number of '=' bonds / total bonds) – expressed with five decimal places.",
      "sql_description": "Counts bonds for TR008 whose bond_type equals the literal string ' = ' (with spaces) and divides by the total bond count, returning the result as percent.",
      "reason": "The required anchor bond_type='=' is mistyped as ' = ' (with spaces). This risks excluding every true double-bond row, so the query may not compute the intended percentage. Anchor violation → reject.",
      "verdict": false
    }
  },
  {
    "question_id": 231,
    "result": {
      "expected_answer": "For molecule TR010: 1) the bond type (single '-', double '=' or triple '#') that appears most frequently among its bonds; 2) whether TR010 is carcinogenic ('carcinogenic' if label '+', otherwise 'non-carcinogenic').",
      "sql_description": "Looks at molecule TR018 (not TR010), groups by molecule label, returns the lexicographically MAX bond_type and carcinogenic status derived from the label.",
      "reason": "Violates two required anchors: uses wrong molecule_id (TR018 instead of TR010) and does not compute the majority bond type (uses MAX instead of highest count). Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 159,
    "result": {
      "expected_answer": "All transaction IDs (or full transaction rows) for which the client 3356 is linked to the account and the transaction’s operation equals 'VYBER' (withdrawal in cash).",
      "sql_description": "Selects trans.trans_id for transactions on accounts of client 3356 where trans.type = 'VYBER'.",
      "reason": "Question requires filtering by operation = 'VYBER'; the query filters by type = 'VYBER', which is a different column (type holds PRIJEM/VYDAJ). Thus required anchor on operation is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 239,
    "result": {
      "expected_answer": "The number of bonds (rows in connected) involving atom_id matching pattern 'TR%_19', counting it whether the atom appears in atom_id or atom_id2.",
      "sql_description": "Counts rows in connected where atom_id equals the single atom_id returned from atom table for pattern 'TR%_19'. It ignores rows where the atom is in atom_id2.",
      "reason": "Required anchor: include connections where atom appears either as atom_id or atom_id2. Predicted SQL only covers one column, so may undercount. Therefore does not fully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 186,
    "result": {
      "expected_answer": "Percentage = (number of male clients whose accounts have frequency 'POPLATEK TYDNE') / (total number of clients whose accounts have frequency 'POPLATEK TYDNE') * 100.",
      "sql_description": "Counts ALL clients (any gender) with 'POPLATEK TYDNE' and divides by total number of male clients in the whole database, then multiplies by 100.",
      "reason": "Missing male-gender filter in numerator and wrong denominator (should be all weekly-statement clients, not all male clients). Required anchors for both numerator and denominator are violated.",
      "verdict": false
    }
  },
  {
    "question_id": 168,
    "result": {
      "expected_answer": "A single numeric percentage: (number of female clients) / (total clients) among those whose accounts are in districts where average salary (A11) > 10000.",
      "sql_description": "Counts all female clients (without restricting to high-salary districts) and divides by a count of all clients with accounts whose district supposedly has A11 > 10000 (but the subquery lacks the district join).",
      "reason": "Missing anchor: The numerator is not limited to districts with average salary > 10000, and the subquery reference to district.a11 is invalid/unjoined. Therefore it does not compute the required percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 201,
    "result": {
      "expected_answer": "A single numeric percentage representing (carbon atoms / all atoms) × 100 for molecules that contain at least one double bond.",
      "sql_description": "Counts distinct carbon atoms in molecules whose IDs appear in bond records with bond_type '=' and divides by the total distinct atoms in the same set of molecules, multiplying by 100.",
      "reason": "Uses element='c' for carbon, restricts molecules via bond_type '=', and computes the requested ratio; all required anchors are present.",
      "verdict": true,
      "evidence": "Returns one column with the computed percentage (NULL here because denominator is 0 in the sample data)."
    }
  },
  {
    "question_id": 244,
    "result": {
      "expected_answer": "Return whether the molecule(s) that have the highest number of double bonds are carcinogenic – i.e., output their label (‘+’ for yes, ‘-’ for no) or an explicit yes/no.",
      "sql_description": "Counts double bonds per molecule, keeps only those whose count equals the global maximum, BUT then filters to label ‘+’. It returns ‘+’ if at least one top-double-bond molecule is carcinogenic; otherwise it returns no rows.",
      "reason": "The extra filter molecule.label = '+' prevents the query from returning ‘-’. If the top molecule is not carcinogenic, the correct answer should be ‘-’ (or ‘no’), but this query would output nothing, giving an indeterminate result. Therefore it does not reliably answer the yes/no question.",
      "verdict": false
    }
  },
  {
    "question_id": 189,
    "result": {
      "expected_answer": "List the account_id values of female ('F') clients whose birth_date is the earliest among all females AND who also live in the district(s) with the lowest average salary (column A11). If several clients tie on both criteria, include all their account numbers.",
      "sql_description": "Retrieves the single client_id of the chronologically oldest female client (earliest birth_date), ignoring average salary and not returning account numbers.",
      "reason": "Missing required anchors: 1) lowest average salary (A11) not considered; 2) returns client_id not account numbers; 3) may exclude ties by LIMIT 1.",
      "verdict": false
    }
  },
  {
    "question_id": 212,
    "result": {
      "expected_answer": "Element name(s) whose atoms appear the fewest times among all atoms that belong to molecules labeled as non-carcinogenic (‘-’).",
      "sql_description": "Counts how many atoms of each element occur in molecules with label ‘-’; orders these counts ascending and returns the element with the smallest count (and its count).",
      "reason": "Matches the required filter (label='-'), performs the correct aggregation (COUNT per element) and selects the minimal count. Returns the element, fulfilling the question. Tie-breaking not specified, so LIMIT 1 is acceptable.",
      "verdict": true,
      "evidence": "element=ca, num_elements=1 (row 0)"
    }
  },
  {
    "question_id": 227,
    "result": {
      "expected_answer": "Percentage of molecules in the molecule table whose label is '+', expressed as a percentage with three decimal digits (e.g., 44.315%).",
      "sql_description": "Counts molecules with label '+' and divides by total count, multiplies by 100 to get a percentage; returns this value as column percent.",
      "reason": "Query correctly applies the required filter on label '+', computes percentage over all molecules, and returns the numeric percentage. Formatting to exactly three decimals is a presentation issue, not a logical one, so requirement is satisfied.",
      "verdict": true,
      "evidence": "sql_result shows column percent with value 44.314869 (row 0), matching the requested metric."
    }
  },
  {
    "question_id": 263,
    "result": {
      "expected_answer": "The percentage of chlorine atoms among all atoms that participate in single (‘-’) bonds across the database.",
      "sql_description": "Counts distinct atoms that are part of a single bond; divides the number of those whose element is 'cl' by the total number of such atoms, returning the percentage.",
      "reason": "Query enforces bond_type='-' through bond table, checks element='cl', and computes (chlorine atoms / all atoms in single bonds)*100. DISTINCT avoids multiple counting of the same atom when involved in multiple single bonds, a reasonable interpretation. All required anchors (chlorine, single bond, percentage) are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows one column `percent` with value ≈3.59, matching the requested percentage."
    }
  },
  {
    "question_id": 197,
    "result": {
      "expected_answer": "A numeric value: the average count of oxygen (element = 'o') atoms per molecule, considering only molecules that have single bonds (bond_type='-').",
      "sql_description": "Joins atom, molecule, bond, connected to produce rows of each (atom, bond) pair, then computes AVG of a 1/0 flag that is 1 when the bond is single and the atom is oxygen, else 0—effectively the fraction of all (atom–bond) connections that satisfy both conditions.",
      "reason": "Does not compute oxygen count per molecule nor restrict denominator to single-bond molecules; it averages a binary flag over atom-bond pairs, yielding a proportion, not the required average number of oxygen atoms per molecule. Single-bond filter is only in the CASE, so rows from other bond types dilute the average.",
      "verdict": false
    }
  },
  {
    "question_id": 219,
    "result": {
      "expected_answer": "The percentage of triple bonds among all bonds within carcinogenic (+) molecules, i.e., (number of bonds of type '#') / (total number of bonds) * 100, considering only molecules whose label is '+'.",
      "sql_description": "Joins molecule and bond, keeps only rows where bond_type='#' and molecule is '+'. Counts\n1) numerator: number of such rows (all of them)\n2) denominator: distinct molecules in those rows.\nReturns (row count *100 / distinct molecule count) giving average number of triple bonds per carcinogenic molecule.",
      "reason": "Denominator should be total bonds (or total triple-bond molecules depending on interpretation), not distinct molecules. Numerator counts bonds, denominator counts molecules, producing an unrelated ratio (>100%). Required anchor of comparing triple bonds to total bonds is missing/incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 232,
    "result": {
      "expected_answer": "Alphabetical list of the first three molecule_ids whose molecule.label = '-' (non-carcinogenic) and that contain at least one bond with bond_type = '-' (a single bond).",
      "sql_description": "Finds molecules joined to a bond where bond_type = 'single', keeps those with molecule.label <> '-', orders by molecule.label and returns the first three labels.",
      "reason": "Violates required anchors: (1) uses bond_type 'single' instead of the symbol '-' for single bonds, (2) filters out non-carcinogenic molecules by requiring label != '-' rather than label = '-', and (3) returns label instead of molecule_id. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 240,
    "result": {
      "expected_answer": "A list of the element symbols present in molecule TR004 (e.g., C, H, O, etc.).",
      "sql_description": "Selects the element field from atom rows whose molecule_id equals 'TR004'; returns every atom’s element for that molecule (duplicates possible).",
      "reason": "Query applies the required molecule anchor (TR004) and retrieves the relevant element values. Even if duplicates appear, the list still contains all elements, satisfying the request.",
      "verdict": true,
      "evidence": "sql_result shows rows with elements s, n, o, c, h, p (among duplicates) – the symbols present for TR004."
    }
  },
  {
    "question_id": 206,
    "result": {
      "expected_answer": "List the element(s) of each atom participating in bond TR004_8_9 – i.e., the elements of both atoms linked by that bond.",
      "sql_description": "Finds atoms where atom.atom_id equals connected.atom_id for bond_id='TR004_8_9', then returns their element values.",
      "reason": "The query only looks at connected.atom_id, ignoring connected.atom_id2, so it can miss the element of the second atom in the bond. It thus fails to guarantee retrieval of both bond atoms’ elements.",
      "verdict": false
    }
  },
  {
    "question_id": 228,
    "result": {
      "expected_answer": "Percentage of atoms in molecule TR206 that are hydrogen, expressed to exactly four decimal places.",
      "sql_description": "Counts hydrogen atoms and total atoms for molecule TR206, divides and multiplies by 100 to yield a percentage without formatting control.",
      "reason": "Core calculation is correct, but the explicit anchor “with four decimal places” is unmet because the query omits rounding/formatting (returns 45.454545, not four-decimal precision).",
      "verdict": false
    }
  },
  {
    "question_id": 234,
    "result": {
      "expected_answer": "The number (count) of bonds in molecule TR009 whose bond_id shows that either first or second atom is 12, i.e., bond_id like 'TR009_12_%' or 'TR009_%_12'.",
      "sql_description": "Counts all rows in bond table where molecule_id is 'TR009'; pattern TR009_% matches every bond in that molecule, without filtering for atom 12.",
      "reason": "Missing required anchor: involvement of atom 12. Query returns total bonds (24) instead of only those involving atom 12.",
      "verdict": false
    }
  },
  {
    "question_id": 213,
    "result": {
      "expected_answer": "The bond_type (e.g., '-', '=', '#') for the bond connecting atoms TR004_8 and TR004_20, regardless of which atom is stored as atom_id or atom_id2.",
      "sql_description": "Returns bond.bond_type where connected.atom_id = 'TR004_8' AND connected.atom_id2 = 'TR004_20' (one specific ordering).",
      "reason": "Question requires handling either ordering of the two atoms (TR004_8–TR004_20 or TR004_20–TR004_8). Predicted SQL checks only one direction, so it may miss the correct bond when stored reversed. Missing required anchor for reversed order.",
      "verdict": false
    }
  },
  {
    "question_id": 242,
    "result": {
      "expected_answer": "All molecule identifiers that are carcinogenic (label '+') and have at least one atom whose atom_id characters 7-8 are between '21' and '25'.",
      "sql_description": "Finds molecules whose label is '+' and that contain atoms with SUBSTR(atom_id,7,2) between '21' and '25', but returns only the molecule.label column (a constant '+').",
      "reason": "Query returns the label value '+' instead of the requested molecule identifiers, so the answer content is incorrect despite correct filtering logic.",
      "verdict": false
    }
  },
  {
    "question_id": 344,
    "result": {
      "expected_answer": "Names of all card printings whose rarity is mythic and whose legality status for the gladiator format is Banned.",
      "sql_description": "Joins cards with legalities, filters rows where rarity='mythic', format='gladiator', status='Banned', and returns the card name column.",
      "reason": "All required anchors (rarity mythic, format gladiator, status Banned) are correctly applied. Although duplicates appear, the result set still contains every qualifying card and no extraneous ones, satisfying a reasonable interpretation of 'list'.",
      "verdict": true,
      "evidence": "sql_result rows: name column shows e.g., 'Oko, Thief of Crowns', 'Nexus of Fate'; all meet mythic rarity & banned in gladiator."
    }
  },
  {
    "question_id": 220,
    "result": {
      "expected_answer": "Three element symbols associated with molecule TR000, chosen as the top-three elements (interpreted as the three distinct elements with the highest occurrence in that molecule) and then shown in alphabetical order.",
      "sql_description": "Returns the first three rows from atom for TR000 after alphabetically sorting all atom rows; duplicates are possible because it does not aggregate or use DISTINCT.",
      "reason": "Query does not determine the top elements by frequency and may output duplicates, potentially omitting a different third element. Required anchor of selecting the three distinct highest-frequency elements is not met.",
      "verdict": false
    }
  },
  {
    "question_id": 245,
    "result": {
      "expected_answer": "A single numeric value: the average count of bonds connected to each iodine atom (element = 'i'). This is computed as total bonds associated with iodine atoms divided by the total number of iodine atoms.",
      "sql_description": "For every iodine atom it counts ALL bonds in the same molecule (using only molecule_id), then averages these per-atom counts. Thus each iodine atom gets the molecule’s total bond count, not the bonds actually involving that atom.",
      "reason": "Required anchor: bond–atom association. The query links bonds to atoms only via molecule_id, so bonds that do not involve the specific iodine atom are included. If a molecule contains more than one iodine atom the average is inflated (returns total bonds per molecule, not per atom). Therefore it does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 247,
    "result": {
      "expected_answer": "All element values for atoms whose atom_id does not appear in either connected.atom_id or connected.atom_id2 (i.e., atoms with no recorded bonds).",
      "sql_description": "Returns element from atom where atom_id is not present in the connected table’s atom_id column; it ignores appearances in connected.atom_id2.",
      "reason": "Question requires excluding atoms that participate in any bond. The query only checks one of the two columns that can record a bond, so atoms appearing solely in connected.atom_id2 will be incorrectly treated as non-bonded. Missing anchor: exclusion from connected.atom_id2.",
      "verdict": false
    }
  },
  {
    "question_id": 230,
    "result": {
      "expected_answer": "A list identifying: 1) every distinct chemical element present in molecule TR060 and 2) the molecule’s carcinogenic label (+ or -).",
      "sql_description": "Fetches all distinct element values from atom where molecule_id = 'TR060' and unions them with the single label value from molecule for the same id, returning them together in one column.",
      "reason": "Query retrieves exactly the required two kinds of information (elements and the label) for TR060. Question does not mandate separate columns or particular formatting, so a combined list suffices.",
      "verdict": true,
      "evidence": "sql_result shows one column: '-', 'c', 'cl', 'h', 'n', 'o'—label first row, remaining rows elements—covering both requested pieces."
    }
  },
  {
    "question_id": 253,
    "result": {
      "expected_answer": "All chemical element symbols for every atom that participates in any triple bond (bond_type = '#'); i.e., both atoms connected by each triple bond.",
      "sql_description": "Finds atoms whose id equals connected.atom_id, joins to bond, filters for triple bonds, and outputs their element symbols; it ignores atoms referenced in connected.atom_id2.",
      "reason": "Query omits the second atom in each triple bond (connected.atom_id2), so it lists only half of the elements involved, failing the complete requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 255,
    "result": {
      "expected_answer": "The percentage (to five decimal places) of bonds with bond_type '-' whose molecule has label '+'. This is: (count of single bonds in carcinogenic molecules) / (total count of single bonds) * 100.",
      "sql_description": "Counts carcinogenic single bonds in the numerator, but divides by the total number of all bonds (any type). Returns the resulting fraction, not multiplied by 100 and not formatted.",
      "reason": "Required anchor bond_type='-' must restrict both numerator and denominator. Denominator includes non-single bonds, so proportion is wrong. Also lacks *100 for percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 273,
    "result": {
      "expected_answer": "Percentage (ratio*100) of chlorine atoms among all atoms belonging to carcinogenic (label='+') molecules.",
      "sql_description": "Counts chlorine atoms in carcinogenic molecules and divides by number of DISTINCT carcinogenic molecules, returning average chlorine-atoms-per-molecule percentage.",
      "reason": "Denominator should be total number of atoms in carcinogenic molecules, not number of molecules. Using COUNT(DISTINCT molecule_id) miscomputes the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 349,
    "result": {
      "expected_answer": "Return the card (name) and its artist that has the highest number of entries in the rulings table; additionally include the card’s isPromo flag (0 or 1). No restriction on whether it is a promo.",
      "sql_description": "Selects the card whose uuid has the greatest ruling count, but then further restricts the result to rows where isPromo = 1, returning name, artist and isPromo.",
      "reason": "The query imposes an extra filter (isPromo = 1) not required by the question. If the true top-ruled card is not promotional, it will be excluded, giving an empty or incorrect answer. Thus the logic does not universally satisfy the question’s requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 327,
    "result": {
      "expected_answer": "List of molecule_id values (or other identifiers of molecules) for molecules labeled '-' (non-carcinogenic) that have more than 5 atoms.",
      "sql_description": "Finds molecules with label '-', counts their atoms, keeps those with atom count >5, but returns only the label field (always '-') and the count per molecule, omitting the molecule_id.",
      "reason": "Missing required anchor: molecule identifier. The query does not output which molecules satisfy the condition, only the repeated label and counts, so it cannot answer \"Which molecules\".",
      "verdict": false
    }
  },
  {
    "question_id": 366,
    "result": {
      "expected_answer": "The rules text (format/rule) of the playing card \"Benalish Knight\".",
      "sql_description": "Fetches the name and the rules text (text column) for rows whose name equals 'Benalish Knight' in the cards table.",
      "reason": "Question asks for the rule of the specified card, which corresponds to the text column. Query correctly filters by the card name and returns that column; extra name column is harmless.",
      "verdict": true,
      "evidence": "Result rows include columns [name, text]; e.g., row0 text begins \"Flash (You may cast this spell any time ...\", matching the card’s rules text."
    }
  },
  {
    "question_id": 248,
    "result": {
      "expected_answer": "List the elements (or atom identifiers) for all atoms that participate in a triple (bond_type = '#') bond in molecule TR041.",
      "sql_description": "Finds atoms whose id matches connected.atom_id for bonds of type '#' in molecule TR447 and returns their element symbols.",
      "reason": "Uses molecule_id = 'TR447' instead of required 'TR041', so misses the anchor molecule TR041. Also only captures one side of each bond, but wrong molecule is already fatal.",
      "verdict": false
    }
  },
  {
    "question_id": 281,
    "result": {
      "expected_answer": "For every carcinogenic molecule (label '+'), locate its 4th atom (atom_id’s 7th character = '4') and produce a tally – i.e., counts grouped by the element of that atom (element → frequency).",
      "sql_description": "Returns a list of element values for atoms whose id indicates they are the 4th atom of carcinogenic molecules, but joins through connected/bond so each atom may appear multiple times and no COUNT/GROUP BY is applied.",
      "reason": "Query does not tally; it only lists elements and can contain duplicate rows caused by extra joins. Required aggregation (counts per element) anchor is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 402,
    "result": {
      "expected_answer": "A numeric percentage value of Story Spotlight cards that lack a text box, together with the IDs of those cards.",
      "sql_description": "Returns the IDs of cards where isStorySpotlight = 1 and isTextless = 0 (via an INTERSECT that does nothing extra). No percentage is computed.",
      "reason": "The query omits the requested percentage and only lists IDs. Consequently it fails the explicit percentage anchor. (Filter choice on isTextless is also questionable but not decisive after the missing percentage.)",
      "verdict": false
    }
  },
  {
    "question_id": 347,
    "result": {
      "expected_answer": "List every card illustrated by artist Stephen Daniel, providing the ruling text for each, and indicate for each card whether it has missing/degraded properties (hasContentWarning = 1).",
      "sql_description": "Returns names and ruling texts of cards whose artist is exactly 'Stephen Daniele'. It does not include any information about hasContentWarning.",
      "reason": "Missing required anchor: the query does not report whether each card has missing/degraded properties (hasContentWarning). Additionally, the artist filter may use a different spelling (‘Stephen Daniele’) than requested (‘Stephen Daniel’).",
      "verdict": false
    }
  },
  {
    "question_id": 352,
    "result": {
      "expected_answer": "Return the percentage obtained by dividing the number of rows (cards) whose language is 'Chinese Simplified' by the total number of rows in foreign_data, multiplied by 100.",
      "sql_description": "Counts rows where language = 'Chinese Simplified', divides by total row count, and multiplies by 100 to output that percentage.",
      "reason": "Fulfills required filter on language and computes the requested percentage exactly as described in the evidence (SUM over condition / COUNT(id) * 100). No missing anchors.",
      "verdict": true,
      "evidence": "sql_result column percentage = 8.772787 (row 0)."
    }
  },
  {
    "question_id": 409,
    "result": {
      "expected_answer": "A single integer: the number of cards whose format is 'premodern', that have a ruling exactly \"This is a triggered mana ability.\", and whose side column is NULL (i.e., single-faced cards).",
      "sql_description": "Counts all cards that have the specified ruling text and side IS NULL, without applying any condition related to the card’s format or set. The join to sets is unused for filtering.",
      "reason": "Missing required anchor: the question explicitly limits to cards in the premodern format, but the query applies no such filter. Therefore it may over- or under-count and does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 358,
    "result": {
      "expected_answer": "The borderColor value (e.g., black, white, etc.) for the card whose name is exactly \"Ancestor's Chosen\".",
      "sql_description": "Retrieves the borderColor column from the cards table for rows whose name equals \"Ancestor's Chosen\".",
      "reason": "The query applies the required name filter and returns the requested borderColor. Multiple rows are acceptable because they all show the same value, which is sufficient to identify the card’s border color.",
      "verdict": true,
      "evidence": "sql_result shows column borderColor with rows 0-3 all = 'black'."
    }
  },
  {
    "question_id": 416,
    "result": {
      "expected_answer": "A single numeric value: the percentage of all cards lacking power (power NULL or \"*\") that are in French.",
      "sql_description": "Calculates count of cards whose power is NULL or '*' and that have a French entry in foreign_data, divides by total number of cards whose power is NULL or '*' across the whole table, and multiplies by 100 to yield the percentage.",
      "reason": "All required anchors are present: (1) filters numerator by language='French' via foreign_data, (2) restricts both numerator and denominator to cards with missing/unknown power, (3) computes percentage. Possible duplicate rows per card are not ruled out by the question and thus acceptable.",
      "verdict": true,
      "evidence": "sql_result shows column 'percentage' with value 47.956719 (row 0) matching expected single numeric output."
    }
  },
  {
    "question_id": 405,
    "result": {
      "expected_answer": "Number of distinct sets whose block is 'Commander' and which have a Portuguese (Brasil) translation.",
      "sql_description": "Counts rows in the join of sets and set_translations where sets.block = 'Commander' and language = 'Portuguese (Brasil)'.",
      "reason": "All required anchors (Commander block, Portuguese (Brasil) language) are present. Assuming each qualifying set has at most one Portuguese translation row, row count equals set count, so the query answers the question. Even if some duplication existed, it would still enumerate translations, which is a plausible interpretation of “translated sets.”",
      "verdict": true,
      "evidence": "sql_result shows column count(*): value 0 -> hence zero qualifying translated sets."
    }
  },
  {
    "question_id": 440,
    "result": {
      "expected_answer": "The foreign language(s) that the card named \"A Pedra Fellwar\" is printed in.",
      "sql_description": "Retrieves the language column from foreign_data for rows where name equals 'A Pedra Fellwar'.",
      "reason": "Query applies the required name filter and returns the associated language; duplicates do not alter the answer. Anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result rows show language column all as 'Portuguese (Brazil)' (rows 0-5)."
    }
  },
  {
    "question_id": 412,
    "result": {
      "expected_answer": "Foreign (French) name(s) of cards where cards.layout = 'normal', cards.borderColor = 'black', cards.artist = 'Matthew D. Wilson', cards.type contains 'Creature', with foreign_data.language = 'French'.",
      "sql_description": "Returns foreign_data.name for cards joined to foreign_data that match normal layout, black border color, artist Matthew D. Wilson, and type exactly 'Creature'. No filter on foreign_data.language.",
      "reason": "Required anchor language='French' is missing, so query may return names in all languages and not necessarily French.",
      "verdict": false
    }
  },
  {
    "question_id": 473,
    "result": {
      "expected_answer": "A yes/no determination of whether the card \"Adarkar Valkyrie\" is marked as foreign-only (isForeignOnly = 1), i.e., only available outside the United States.",
      "sql_description": "Selects rows for \"Adarkar Valkyrie\" whose availability column equals the string '1', returning the card name(s).",
      "reason": "Uses the wrong column (availability instead of isForeignOnly) and does not output a boolean answer. Empty result does not constitute a correct yes/no evaluation.",
      "verdict": false
    }
  },
  {
    "question_id": 459,
    "result": {
      "expected_answer": "The name of the card, either \"Serra Angel\" or \"Shrine Keeper\", that has the larger convertedManaCost value (higher mana value).",
      "sql_description": "Fetches the two specified cards, orders them by convertedManaCost descending, returns the top row (highest cost) with its cost.",
      "reason": "Query restricts to the two target cards and picks the one with the greater convertedManaCost, satisfying the comparison asked. LIMIT 1 is acceptable since only the higher-cost card is requested and the question does not specify tie handling.",
      "verdict": true,
      "evidence": "Returned columns: name, convertedManaCost; first row shows Serra Angel with cost 5.0, indicating it is the higher-cost card in the data."
    }
  },
  {
    "question_id": 371,
    "result": {
      "expected_answer": "The numeric percentage of Story Spotlight cards that have French as their language.",
      "sql_description": "Counts Story Spotlight card rows whose joined foreign_data row is in French, divides by the total Story Spotlight card rows, and multiplies by 100.",
      "reason": "Query applies required anchors (isStorySpotlight = 1, language = 'French') and computes French count / total count * 100. Potential duplicate-row issue is negligible because each card printing (uuid) has at most one French entry; thus result reflects the intended percentage.",
      "verdict": true,
      "evidence": "sql_result shows column percentage with value 83.653846 (row 0)."
    }
  },
  {
    "question_id": 468,
    "result": {
      "expected_answer": "Return the translation string that is the Simplified Chinese version of the set name \"Eighth Edition\" (i.e., what that set is called in Simplified Chinese).",
      "sql_description": "Looks up the set code for the set whose English name is \"Eighth Edition\" and then returns the translation where language equals the literal string \"Simplified Chinese\".",
      "reason": "The question requires the row where language is the database’s label for Simplified Chinese. Evidence says that label is \"Chinese Simplified\", but the SQL filters on \"Simplified Chinese\". Hence it misses the required anchor and yields no rows.",
      "verdict": false
    }
  },
  {
    "question_id": 474,
    "result": {
      "expected_answer": "The number (count) of sets that have an Italian translation and whose baseSetSize is less than 10.",
      "sql_description": "Returns the names of sets that have an Italian translation and baseSetSize < 10, without aggregating; no count is produced.",
      "reason": "Query satisfies language and size anchors but fails to compute the requested count; it lists rows instead of returning the number of such sets.",
      "verdict": false
    }
  },
  {
    "question_id": 408,
    "result": {
      "expected_answer": "The number of cards whose power is unknown (either NULL or the string '*') and whose text mentions the phrase 'triggered ability'.",
      "sql_description": "Counts rows in cards where power IS NULL and the text contains 'triggered ability'.",
      "reason": "The query omits the second category of unknown power (power='*'). Therefore it excludes cards with power='*', so the count can be lower than required.",
      "verdict": false
    }
  },
  {
    "question_id": 391,
    "result": {
      "expected_answer": "Names of cards whose originalType is 'Artifact', colors is 'B' (black), and which have at least one foreign_data entry in a non-English language.",
      "sql_description": "Joins cards with foreign_data, keeps rows where originalType='Artifact', colors='B', and the foreign language is not English, then returns cards.name.",
      "reason": "All required anchors are present: Artifact (as specified), black color, and presence of a non-English translation. Though duplicates appear because multiple foreign languages per card, the set of returned names is correct and no extra cards are introduced.",
      "verdict": true,
      "evidence": "sql_result shows only two card names (Executioner's Capsule, Immortal Coil) repeated across rows; both satisfy the stated conditions."
    }
  },
  {
    "question_id": 530,
    "result": {
      "expected_answer": "A list of every card illustrated by Allen Williams together with their frame style (frameVersion). Additionally, identify which of those cards are banned (status = 'Banned'); i.e., the full set of Allen-Williams cards, clearly indicating any banned ones.",
      "sql_description": "Returns only the frameVersion and name for cards where artist is Allen Williams AND the card is banned (status='Banned'). It omits all Allen Williams cards that are not banned.",
      "reason": "Query filters to banned cards, so it does not list ALL Allen Williams cards and frame styles. Thus it fails the primary requirement and only partially addresses the second.",
      "verdict": false
    }
  },
  {
    "question_id": 472,
    "result": {
      "expected_answer": "A single integer: the count of sets whose block is 'Ice Age' and that have at least one entry in set_translations with language = 'Italian' and a non-NULL translation value.",
      "sql_description": "Counts rows in sets with block = 'Ice Age' whose code appears in any set_translations row where language = 'Italian' (translation value not checked).",
      "reason": "Required anchor \"translation IS NOT NULL\" is not enforced; sets with Italian rows lacking a translation would be mistakenly included. Therefore the query may over-count.",
      "verdict": false
    }
  },
  {
    "question_id": 565,
    "result": {
      "expected_answer": "Determine whether the post that received the comment from user 23853 at 2013-07-12 09:08:18 was well-finished (ClosedDate NOT NULL) or not.",
      "sql_description": "Finds the post linked to that exact comment and returns its id only when the post’s ClosedDate IS NULL (i.e., not well-finished); if the post is well-finished, the query returns no rows.",
      "reason": "The query correctly identifies the target comment via UserId and CreationDate anchors and inspects ClosedDate. By emitting a row only when ClosedDate is NULL, the presence/absence of a result unambiguously indicates the well-finished status, satisfying the question’s requirement.",
      "verdict": true,
      "evidence": "Result set columns: [Id]; empty result ⇒ post was well-finished, non-empty ⇒ not well-finished."
    }
  },
  {
    "question_id": 522,
    "result": {
      "expected_answer": "All cards whose edhrecRank equals 1 together with every play format in which each of those cards is banned (status = 'Banned'). Output columns: card name and banned format.",
      "sql_description": "Joins cards to legalities on uuid, then keeps rows where edhrecRank = 1 and legality status is 'Banned', returning the card name and the corresponding format.",
      "reason": "Query applies both required anchors (edhrecRank = 1 and status = 'Banned') and outputs the requested fields. Extra duplicates do not violate the question. Therefore it satisfactorily answers the question.",
      "verdict": true,
      "evidence": "sql_result shows rows with name='Sol Ring' and formats 'duel', 'legacy' (columns: name, format), confirming correct constraint application."
    }
  },
  {
    "question_id": 487,
    "result": {
      "expected_answer": "A numeric percentage: (number of cards in set \"Coldsnap\" whose cardKingdomFoilId IS NOT NULL and cardKingdomId IS NOT NULL) divided by total number of cards in the set, times 100.",
      "sql_description": "Counts cards whose setCode = 'Coldsnap' where cardKingdomFoilId equals cardKingdomId (and cardKingdomId is not NULL) and divides by the total number of cards with setCode = 'Coldsnap'.",
      "reason": "Fails two required anchors: 1) set identification – evidence specifies name = 'Coldsnap', not setCode; 2) definition of \"incredibly powerful\" – should require both IDs to be NOT NULL, not equality between them. Therefore the computed percentage does not match the question’s criteria.",
      "verdict": false
    }
  },
  {
    "question_id": 531,
    "result": {
      "expected_answer": "Identify whether Harlan or Jarrod Dixon has the higher reputation (returning either just the higher-reputation user’s name or both names with their reputations for comparison).",
      "sql_description": "Filters users to the two display names then aggregates to one row, computing the maximum reputation across both but also selects a single (non-aggregated) DisplayName value without GROUP BY.",
      "reason": "Because there is no GROUP BY, the single DisplayName returned is indeterminate; it is not guaranteed to be the user corresponding to the maximum reputation. Thus the query may label the wrong person as higher-reputation and does not reliably answer the comparison question.",
      "verdict": false
    }
  },
  {
    "question_id": 529,
    "result": {
      "expected_answer": "Names of sets whose set code appears in set_translations with language Korean but does NOT appear with language Japanese.",
      "sql_description": "Finds set codes that have at least one Korean translation, excludes any set codes that have a Japanese translation, then returns the corresponding set names from sets.",
      "reason": "Query applies both required anchors (presence of Korean, absence of Japanese) and returns the set names, matching the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows column [name] and zero rows, consistent with having no qualifying sets."
    }
  },
  {
    "question_id": 584,
    "result": {
      "expected_answer": "All texts of comments on the specified post, but only from users who have also edited that post (i.e., commenter’s user id appears among editors in postHistory for the post).",
      "sql_description": "Returns texts of every comment on the post that has at least one postHistory row with Comment = 'Edited'; does NOT restrict the comment’s author to be one of the editors because it never links postHistory.UserId to comments.UserId.",
      "reason": "Missing the crucial anchor that the comment author must be an editor of the post. The JOIN to postHistory is not tied to the comment user, so the query may include comments from users who never edited the post. Therefore it does not satisfy the question requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 539,
    "result": {
      "expected_answer": "Display name(s) of the owner(s) of the post whose Title is exactly \"Eliciting priors from experts\".",
      "sql_description": "Selects OwnerDisplayName from posts where Title matches \"Eliciting priors from experts\".",
      "reason": "Query applies the necessary title filter and returns the owner display name, matching the question’s requirement. No additional anchors are missing.",
      "verdict": true,
      "evidence": "Returned column OwnerDisplayName with value None (row 0), indicating post has no stored display name."
    }
  },
  {
    "question_id": 533,
    "result": {
      "expected_answer": "A single number: the count of users whose LastAccessDate is later than 2014-09-01 (exclusive).",
      "sql_description": "Counts every row in users where LastAccessDate > '2014-09-01 00:00:00', returning that count.",
      "reason": "Query applies the required date filter and returns only the quantity requested; aligns exactly with the question’s condition (after 2014/9/1).",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(*) = 5146 (row 0)."
    }
  },
  {
    "question_id": 595,
    "result": {
      "expected_answer": "List the user Ids where the user has at least 1000 profile views (users.Views >= 1000) and, for every post the user owns, there is only one associated postHistory record (i.e., exactly one row in postHistory for each (user, post) pair).",
      "sql_description": "Joins users to their posts and to postHistory rows that match both the same user and post, groups by user id, then keeps groups having exactly one distinct postHistory row in total and where the joined post’s ViewCount is at least 1000.",
      "reason": "1) Uses posts.ViewCount instead of users.Views, violating the explicit 1000-views anchor.\n2) Condition COUNT(DISTINCT posthistory.id)=1 enforces exactly one history row overall, not one per post, so the ‘one post history per post’ requirement is not satisfied.\n3) Non-aggregated posts.ViewCount in HAVING would ignore duplicate posts, compounding the logic error. Required anchors are missing or misused.",
      "verdict": false
    }
  },
  {
    "question_id": 586,
    "result": {
      "expected_answer": "Display name(s) of user(s) who cast a vote that placed a bounty of 50 on any post whose title contains the word \"variance\".",
      "sql_description": "Looks up votes with BountyAmount = 50, joins to the related posts whose Title contains the substring 'variance', then returns the DisplayName of the user who cast each such vote.",
      "reason": "Query applies the required bounty amount filter and the title-substring filter, links the vote to the user, and outputs the users’ display names, matching all anchors in the question.",
      "verdict": true,
      "evidence": "sql_result shows two rows with column \"User\" containing values (row0: chl, row1: shabbychef) which fit the requested answer format."
    }
  },
  {
    "question_id": 563,
    "result": {
      "expected_answer": "The number of favorites (FavoriteCount) for the post that received the comment made by user 3025 at 2014-04-23 20:29:39.",
      "sql_description": "Finds the PostId of the comment whose UserId = 3025 and CreationDate = '2014/4/23 20:29:39.0', then retrieves FavoriteCount for that post from posts.",
      "reason": "Correctly joins comments to posts via PostId, applies both required anchors (user 3025 and exact timestamp), and returns the desired FavoriteCount. No missing or extra constraints.",
      "verdict": true,
      "evidence": "Result set column FavoriteCount (no rows in sample execution, but query logic matches requirements)."
    }
  },
  {
    "question_id": 640,
    "result": {
      "expected_answer": "A single numeric value: total view counts of all posts authored by user(s) named \"Mornington\" minus the total view counts of all posts authored by user(s) named \"Amos\".",
      "sql_description": "Joins posts with users, sums viewcount for posts whose user displayname = 'Mornington', sums viewcount for posts whose displayname = 'Amos', subtracts the latter from the former and returns the difference as viewcount_difference.",
      "reason": "All required anchors (Mornington, Amos, ViewCount, subtraction order Mornington−Amos) are present and correctly implemented, producing the requested single difference value.",
      "verdict": true,
      "evidence": "sql_result rows[0].viewcount_difference = -497"
    }
  },
  {
    "question_id": 571,
    "result": {
      "expected_answer": "The ratio (count of posts created by user 24) divided by (count of votes those posts have received). One numeric value.",
      "sql_description": "Selects all posts whose OwnerUserId = 24, left-joins to votes on post id, counts distinct post ids for the numerator, counts vote ids for the denominator, and returns their quotient as post_vote_comparison.",
      "reason": "Uses the correct anchor (OwnerUserId = 24), counts the intended quantities (posts and votes on those posts), and outputs their ratio. Ambiguity about whether votes should be cast by the user or received is resolved by evidence favoring received votes; query matches this interpretation.",
      "verdict": true,
      "evidence": "sql_result shows a single column post_vote_comparison with one row (value 0), matching expected format."
    }
  },
  {
    "question_id": 672,
    "result": {
      "expected_answer": "A single number: the count of distinct users located in the United Kingdom whose combined FavoriteCount across all their posts is at least 4.",
      "sql_description": "Groups posts by user in the UK, keeps only those users whose post-favorites sum to ≥4, then outputs COUNT(DISTINCT users.id) for every remaining group. Because the aggregate is evaluated inside each group, it produces one row per user, each with the value 1.",
      "reason": "The query satisfies the location and favorite-sum anchors but fails to return the required overall count. Instead of one scalar result, it emits one row per qualifying user; consumers must manually count the rows to obtain the answer, which violates the explicit ‘how many’ requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 598,
    "result": {
      "expected_answer": "A single numeric value representing (percentage of all Student badges awarded in 2010) minus (percentage awarded in 2011), expressed as a percentage (percentage-point difference).",
      "sql_description": "Filters badges to rows where name = 'Student'; counts rows from 2010 and 2011 separately, divides each by the total number of Student badges, subtracts the 2011 share from the 2010 share, multiplies by 100, and rounds to two decimals.",
      "reason": "All required anchors are present: badge name filter, separate year conditions (2010 and 2011), and the percentage-difference formula exactly as specified in evidence. Therefore the query answers the question.",
      "verdict": true,
      "evidence": "percentage_difference column row0 = -9.54"
    }
  },
  {
    "question_id": 719,
    "result": {
      "expected_answer": "A single numeric count of distinct superheroes who possess the power 'Super Strength' and whose height_cm is greater than 200.",
      "sql_description": "Retrieves a list of superhero_name values (one per matching row in hero_power) where power_name = 'Super Strength' and height_cm > 200; does not aggregate or deduplicate.",
      "reason": "The query returns names instead of the requested count, and it may include duplicate rows for heroes with multiple matching power records. Thus it does not directly answer the 'how many' question.",
      "verdict": false
    }
  },
  {
    "question_id": 665,
    "result": {
      "expected_answer": "A single numeric value: the total number of post links created in 2010 whose source post has at most 2 answers, divided by 12 (average per month).",
      "sql_description": "Counts postLinks rows where pl.CreationDate is in 2010 and the linked post’s AnswerCount ≤ 2, then divides that count by 12 (rounded). Returns this average as avg_monthly_links.",
      "reason": "All required anchors are present: year 2010 restriction on link creation date, posts limited to AnswerCount ≤2 via join, and the result averaged over 12 months. Thus the query answers the question.",
      "verdict": true,
      "evidence": "avg_monthly_links column in result = 8.0"
    }
  },
  {
    "question_id": 462,
    "result": {
      "expected_answer": "The Italian-language name of the card \"Ancestor's Chosen\".",
      "sql_description": "Finds the card row where cards.name = 'Ancestor''s Chosen', joins to its foreign_data rows, restricts to language = 'Italian', and returns the foreign name.",
      "reason": "Question is interpreted as asking for the Italian name of the card, not its set. SQL correctly filters by the card and language and returns that name; no required anchors are missing.",
      "verdict": true,
      "evidence": "sql_result shows column name with value \"Prescelto dell'Antenata\" (rows 0-1)."
    }
  },
  {
    "question_id": 728,
    "result": {
      "expected_answer": "A ranking (descending) of eye colours among Marvel Comics superheroes, e.g. each eye colour with the number of Marvel superheroes having it, ordered from most to least common (or superheroes themselves sorted by the frequency of their eye-colour group).",
      "sql_description": "Counts only the number of Marvel superheroes whose eye colour is exactly 'Blue' and returns that single number (126). No ranking, no other colours or superheroes are included.",
      "reason": "Query omits required ranking and ignores all eye colours except blue, so it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 477,
    "result": {
      "expected_answer": "Identify which of the three named artists – Jeremy Jarvis, Aaron Miller, and Chippy – appear as the artist of at least one card in the set named \"Coldsnap\"; return those artist names.",
      "sql_description": "Looks up the code of the set whose name is 'Coldsnap', then selects the artist field from cards whose setCode matches that code and whose artist is Jeremy Jarvis, Aaron Miller, or Chippy.",
      "reason": "The query anchors on the correct set via its name, restricts to the three specified artists, and returns the matching artist names. Duplicates do not violate the question. Hence it answers the question.",
      "verdict": true,
      "evidence": "sql_result shows artist column with rows: 'Jeremy Jarvis' (rows 0-2) and 'Chippy' (rows 3-4), indicating those two artists have cards in Coldsnap while Aaron Miller does not."
    }
  },
  {
    "question_id": 758,
    "result": {
      "expected_answer": "Hair colour(s) of superhero(s) with race = human and height_cm = 185.",
      "sql_description": "Selects colour.colour via join on hair_colour_id for superheroes where height_cm = 185 and associated race record has race = 'Human'.",
      "reason": "Query applies both required filters (height 185, race human) and fetches the hair colour via correct join; returns matching colours, satisfying question.",
      "verdict": true,
      "evidence": "sql_result colour column shows values such as Blond, Brown, Black (rows 0-10) corresponding to heroes that meet the criteria."
    }
  },
  {
    "question_id": 629,
    "result": {
      "expected_answer": "A single numeric value: the ratio (votes in 2010) divided by (votes in 2011).",
      "sql_description": "Returns two separate counts: one for votes in 2010 (count_2010) and one for votes in 2011 (count_2011). Does not compute their ratio.",
      "reason": "Required anchor: ratio (division of the two counts) is missing; query only supplies the two raw counts.",
      "verdict": false
    }
  },
  {
    "question_id": 639,
    "result": {
      "expected_answer": "The numeric percentage (e.g., 12.3 or 0.123) representing the share of posts written by the user whose DisplayName is 'Community' that are tagged with the R language (TagName = 'r').",
      "sql_description": "Counts all posts whose owner is the user with DisplayName 'Community' (TotalPosts) and separately counts those joined to a tags row where TagName = 'r' via tags.ExcerptPostId = posts.Id (RLanguagePosts). Returns the two raw counts, not their ratio.",
      "reason": "The query does not compute the requested percentage; it only returns two counts. Moreover, it relies on tags.ExcerptPostId, which does not map regular post–tag relationships, so even the RLanguagePosts count is likely incorrect. Missing required anchor: percentage calculation.",
      "verdict": false
    }
  },
  {
    "question_id": 685,
    "result": {
      "expected_answer": "Provide two items about the post titled (or with text) 'Computer Game Datasets': 1) its total view count (ViewCount), and 2) the display name of the user who most recently posted such a post (i.e., the latest instance by creation/activity date).",
      "sql_description": "Returns one row where total_views is the sum of ViewCount for all posts whose Title matches 'Computer game datasets'. Also returns OwnerDisplayName from one of those rows (without specifying which). It does not pick the latest post and may mix aggregated and non-aggregated columns.",
      "reason": "The query ignores the 'last time' requirement; OwnerDisplayName is not tied to the most recent post and may be arbitrary when multiple rows exist. Mixing SUM(viewcount) with an ungrouped OwnerDisplayName is semantically incorrect. Thus it does not reliably supply the correct user name.",
      "verdict": false
    }
  },
  {
    "question_id": 775,
    "result": {
      "expected_answer": "Percentage = (number of female superheroes whose skin colour is Blue) ÷ (total number of female superheroes) × 100.",
      "sql_description": "Counts female superheroes whose EYE colour is Blue, divides by total female superheroes, multiplies by 100.",
      "reason": "Required anchor: Blue must be checked on skin_colour_id as per evidence; query uses eye_colour_id, so the subset counted is wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 710,
    "result": {
      "expected_answer": "A single integer: the count of comments whose score is 0 on posts that have exactly one comment (CommentCount = 1).",
      "sql_description": "Counts all rows in comments with Score = 0 where the comment’s PostId is in the set of post IDs whose CommentCount equals 1.",
      "reason": "All required anchors are present: Score = 0 filter and Post.CommentCount = 1 filter. The query returns exactly the requested count, so it answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with COUNT(*) column, value 10997, supplying the requested count."
    }
  },
  {
    "question_id": 829,
    "result": {
      "expected_answer": "Identify whether DC Comics or Marvel Comics has a larger number of superheroes and give the numerical difference between their counts.",
      "sql_description": "Counts superheroes for each publisher separately, returning two columns: dc_heroes and marvel_heroes, but does not calculate their difference or state which publisher is larger.",
      "reason": "Query provides the counts but omits the required \"difference\" calculation and does not explicitly indicate which publisher has more superheroes. Required anchor (difference) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 723,
    "result": {
      "expected_answer": "A single integer: the number of superheroes whose eye colour is Blue and who possess the superpower named \"Agility\" (distinct heroes).",
      "sql_description": "Retrieves superhero_name rows for heroes whose eye_colour = 'Blue' and who have a linked superpower named 'Agility'. It does not aggregate; it outputs one row per matching hero-power link (duplicates possible).",
      "reason": "Question asks for a count, but the query returns a list of names and may include duplicates because DISTINCT or COUNT is not used. Therefore it does not directly answer \"how many\" and may over-count if used as a proxy.",
      "verdict": false
    }
  },
  {
    "question_id": 857,
    "result": {
      "expected_answer": "Latitude and longitude coordinates of the circuit that hosts the Abu Dhabi Grand Prix.",
      "sql_description": "Joins races with circuits, filters rows where race name is 'Abu Dhabi Grand Prix', and outputs the circuit's lat and lng (one row per race instance).",
      "reason": "Correct anchor (races.name) applied and requested fields (lat, lng) selected; duplicates do not alter the correct coordinate pair.",
      "verdict": true,
      "evidence": "lat=24.4672, lng=54.6031 appears in all returned rows."
    }
  },
  {
    "question_id": 730,
    "result": {
      "expected_answer": "A list (names or ids) of all superheroes published by Marvel Comics who possess the super power named 'Super Strength'.",
      "sql_description": "Calculates the percentage of Marvel Comics superheroes that have the power 'Super Strength' by dividing the count of such heroes by the total number of Marvel heroes.",
      "reason": "Instead of listing the qualifying superheroes, the query returns a single percentage value. It does not provide the requested list.",
      "verdict": false
    }
  },
  {
    "question_id": 865,
    "result": {
      "expected_answer": "The driver (name/ref) with the earliest date of birth among those whose result time is not NULL in race 592.",
      "sql_description": "Joins drivers with results, keeps rows where raceId = 592 and time IS NOT NULL, orders by dob ascending (earliest first) and returns the first driverRef.",
      "reason": "Matches required anchors: race 592, only finishers (time not NULL), oldest determined by earliest dob, returns that driver. Columns chosen (driverRef) satisfy identity request.",
      "verdict": true,
      "evidence": "sql_result shows driverRef='beltoise' in row 0."
    }
  },
  {
    "question_id": 743,
    "result": {
      "expected_answer": "Two-part answer: 1) the percentage of all superheroes whose alignment is 'Bad' (act in own self-interest / own moral code) out of the whole superhero table; 2) the number of those Bad-alignment superheroes whose publisher is Marvel Comics.",
      "sql_description": "Computes (Bad superheroes / all superheroes) * 100 as percentage. Does NOT calculate or return the count of Bad superheroes published by Marvel Comics.",
      "reason": "Question explicitly asks to indicate how many of the Bad-alignment superheroes were published by Marvel Comics. The query omits this requirement; missing the Marvel publisher anchor and the count field.",
      "verdict": false
    }
  },
  {
    "question_id": 753,
    "result": {
      "expected_answer": "Names of superheroes whose height_cm is between 170 and 190 inclusive and whose eye colour entry in the colour table equals the literal string 'No Colour'.",
      "sql_description": "Selects superhero_name from superhero where height_cm is between 170 and 190 and eye_colour_id is NULL (i.e., no foreign-key value).",
      "reason": "Question explicitly anchors on eye colour value 'No Colour' (via colour table). The SQL instead checks for NULL eye_colour_id, ignoring the required colour='No Colour'. Required anchor missing.",
      "verdict": false
    }
  },
  {
    "question_id": 760,
    "result": {
      "expected_answer": "A numeric percentage indicating what fraction of superheroes whose height is between 150 and 180 cm are published by Marvel Comics.",
      "sql_description": "Counts superheroes with height 150-180 cm and publisher_id 13, divides by total superheroes in that height range, multiplies by 100, rounds to two decimals.",
      "reason": "Query correctly filters by height range, identifies Marvel via publisher_id = 13, computes percentage over the correct base set, and returns a single rounded numeric result as requested.",
      "verdict": true,
      "evidence": "percentage_published_by_marvel column row0 = 60.87"
    }
  },
  {
    "question_id": 872,
    "result": {
      "expected_answer": "Abbreviated driver code(s) for the driver whose Q3 lap time starts with 1:33 (i.e., 0:01:33) in race 45.",
      "sql_description": "Finds drivers whose qualifying record for raceId 45 has q3 exactly equal to the string '0:01:33' and returns their code.",
      "reason": "The question/evidence specifies matching the Q3 time pattern \"1:33…\" (q3 LIKE '1:33%') rather than the exact literal '0:01:33'. Using strict equality risks missing the correct row because times typically include fractions (e.g., '1:33.247'). Required anchor on the time pattern is therefore mis-implemented; query may return no driver even when one exists.",
      "verdict": false
    }
  },
  {
    "question_id": 880,
    "result": {
      "expected_answer": "Percentage difference in Paul di Resta’s fastest-lap speed between race 853 and race 854, computed as (speed_853 − speed_854) / speed_853 * 100.",
      "sql_description": "Lists fastestLapSpeed values for every driver in race 853; no driver filter, no race 854, no percentage calculation.",
      "reason": "Misses required anchors: driver = Paul di Resta, race 854, and percentage calculation.",
      "verdict": false
    }
  },
  {
    "question_id": 894,
    "result": {
      "expected_answer": "The row(s) containing the single best (minimum) lap time overall, expressed in milliseconds, along with the corresponding driver’s full name (forename + surname) and the name of the race where it occurred.",
      "sql_description": "Computes MIN(time) (a text column) from laptimes and returns that value together with an arbitrary driverId and raceId taken from the ungrouped table.",
      "reason": "Required anchors missing: it does not join to drivers or races so driver and race names are absent; it minimises the text 'time' column instead of the numeric 'milliseconds'; ungrouped driverId and raceId are undefined. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 786,
    "result": {
      "expected_answer": "The count of superheroes whose Strength attribute equals the maximum Strength value among all heroes.",
      "sql_description": "Finds the maximum Strength value, then counts distinct superhero names whose Strength attribute equals that max value. Returns that count.",
      "reason": "Query correctly filters by Strength, matches heroes at the max value, and counts them, satisfying the question’s requirements.",
      "verdict": true,
      "evidence": "Returned column COUNT(DISTINCT superhero.superhero_name) with value 62 (row 0)."
    }
  },
  {
    "question_id": 557,
    "result": {
      "expected_answer": "Percentage (0–100) of all posts with Score > 5 whose owner’s Age is greater than 65.",
      "sql_description": "Joins posts to users, keeps only posts whose Score > 20, then computes 100 * (count of posts owned by users aged >65) / (total count of those posts).",
      "reason": "Required anchor Score > 5 is mis-implemented as Score > 20, excluding many qualifying posts; therefore the computed percentage does not correspond to the asked set.",
      "verdict": false
    }
  },
  {
    "question_id": 898,
    "result": {
      "expected_answer": "Return the age (in years) of the youngest driver whose nationality is Japanese and the corresponding driver’s name.",
      "sql_description": "Calculates age for each Japanese driver as (2022 - birth-year + 1), takes the minimum of those ages, and returns that minimum age together with an arbitrary forename from the filtered rows (no GROUP BY). Result shown: age 37, name Kamui.",
      "reason": "1) Age formula hard-codes 2022+1 = 2023 instead of CURRENT year, but even ignoring that, 2) using MIN(age) with a non-aggregated forename returns an arbitrary name not guaranteed to belong to the youngest driver. In the dataset the youngest Japanese driver is Yuki Tsunoda (age low 20s), but the query outputs Kamui (age 37). Required anchors (youngest, correct driver) are not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 928,
    "result": {
      "expected_answer": "DriverRef of the driver who finished first (position = 1) in the 2007 Canadian Grand Prix race.",
      "sql_description": "Returns driverRef of drivers whose standing position is 1 in the 2008 Australian Grand Prix.",
      "reason": "SQL uses wrong race (Australian Grand Prix) and wrong year (2008) instead of Canadian Grand Prix 2007, violating required anchors.",
      "verdict": false
    }
  },
  {
    "question_id": 797,
    "result": {
      "expected_answer": "List of superhero names whose eye colour is Blue and whose hair colour is Brown.",
      "sql_description": "Returns superhero_name from superhero records whose eye_colour_id = 7 and hair_colour_id = 9, after inner-joining to race, alignment and hero_attribute (the latter demands that each selected hero has at least one attribute, and creates duplicates).",
      "reason": "The extra inner join to hero_attribute imposes an unnecessary condition that a hero must have at least one attribute row. This can omit superheroes who satisfy the colour criteria but lack attribute entries, so the result set may be incomplete. Therefore the query does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 587,
    "result": {
      "expected_answer": "For posts whose Tags column contains '<humor>', return the average view count across those posts and, for each such post, its title and any comment text (with potentially multiple rows per comment).",
      "sql_description": "Joins posts to tags via posts.id = tags.ExcerptPostId, filters tags.TagName = 'humor', then groups by post title and comment, outputting AVG(p.viewcount) (which equals the post’s viewcount).",
      "reason": "The query does not correctly identify posts tagged '<humor>'. Posts are not linked to the tags table by ExcerptPostId; the tag is stored in posts.Tags. Thus required anchor \"posts tagged as '<humor>'\" is missing/incorrect, so results (empty or wrong) do not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 937,
    "result": {
      "expected_answer": "The finishing time (results.time) of the driver who finished 2nd at the 2008 Chinese Grand Prix.",
      "sql_description": "Gets the time of the driver in position 2 for the 2008 Australian Grand Prix.",
      "reason": "Uses the Australian Grand Prix instead of the required Chinese Grand Prix; key anchor (race name) is wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 948,
    "result": {
      "expected_answer": "A single numeric value: the maximum points scored in any constructorResults entry by constructors whose nationality is British.",
      "sql_description": "Computes the average (AVG) of points across all constructorResults rows joined with constructors where nationality is 'British'.",
      "reason": "Uses AVG rather than MAX, thus returns an average not the maximum requested. Violates required 'maximum points' anchor.",
      "verdict": false,
      "evidence": ""
    }
  },
  {
    "question_id": 825,
    "result": {
      "expected_answer": "The textual gender (e.g., \"Female\", \"Male\", etc.) of every superhero who possesses the power \"Phoenix Force\".",
      "sql_description": "Joins superheroes with their powers and selects superhero.gender_id (an integer key) for rows where power_name = 'Phoenix Force'.",
      "reason": "Query returns the surrogate key gender_id instead of the gender text, so it does not provide the requested gender information.",
      "verdict": false
    }
  },
  {
    "question_id": 854,
    "result": {
      "expected_answer": "Latitude and longitude coordinates of any circuit(s) that hosted the Australian Grand Prix.",
      "sql_description": "Joins races with circuits, filters races where name = 'Australian Grand Prix', and returns the lat and lng of the corresponding circuits.",
      "reason": "Correctly anchors on race name and outputs the required coordinate columns. Returning multiple identical rows is harmless; it still provides the needed coordinates.",
      "verdict": true,
      "evidence": "sql_result shows lat and lng columns with value pairs (-34.9272, 138.617) for all rows."
    }
  },
  {
    "question_id": 955,
    "result": {
      "expected_answer": "For each year earlier than 1975 (year < 1975), list the average finishing time of the winner (champion) of all races held in that year, expressed in seconds.",
      "sql_description": "Joins races, driverStandings and results. Keeps rows where driverStandings.position = 1, results.time is not null, then converts the results.time string with strftime('%s') and averages it per races.year. Does not restrict years to < 1975.",
      "reason": "1) Required anchors missing/incorrect: a) no filter year<1975, b) champion should be the race winner (results.position=1) not driverStandings.position=1, c) conversion with strftime on a duration string produces wrong values. Therefore query does not correctly compute the requested averages.",
      "verdict": false
    }
  },
  {
    "question_id": 846,
    "result": {
      "expected_answer": "The list of driver reference names (drivers.driverRef) for the five slowest drivers in the Q1 session of raceId = 20 (i.e., those eliminated after the first qualifying period).",
      "sql_description": "Joins qualifying with drivers, but filters rows where qualifyId = 'q1' (mistakenly treating qualifyId as the Q1 session) and raceId = 18, then orders by q1 time descending and returns the first 5 driverRef values.",
      "reason": "Missing and incorrect anchors: raceId should be 20 but query uses 18; it constrains qualifyId rather than selecting all drivers of race 20. Therefore it does not target the required dataset.",
      "verdict": false
    }
  },
  {
    "question_id": 859,
    "result": {
      "expected_answer": "The Q1 time achieved by driver Bruno Senna in qualifying for race 354.",
      "sql_description": "Finds the row in qualifying with raceId 354 and the driver whose forename is 'Bruno' and surname 'Senna', returning his q1 time (along with name fields).",
      "reason": "Query applies correct driver and race anchors and returns the q1 field, so it provides the requested information despite also returning name columns.",
      "verdict": true,
      "evidence": "Row0: q1=1:23.796"
    }
  },
  {
    "question_id": 963,
    "result": {
      "expected_answer": "A single integer: the number of distinct French drivers who have at least one lap with time strictly under 120 seconds (120,000 ms).",
      "sql_description": "Counts distinct drivers whose nationality is exactly 'French' and whose lapTimes.time string value is lexicographically smaller than the literal string '02:00.00'.",
      "reason": "The threshold must be applied numerically (<120 s). Comparing the textual time column lexicographically is unreliable and, as evidenced by the 0 result, fails to capture laps that are in fact <120 s. The milliseconds numeric field— or a numeric cast—should have been used. Required anchor (proper numeric comparison to <120 s) is missing, so the query does not correctly answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 637,
    "result": {
      "expected_answer": "List of all tag names that appear on posts authored by user DisplayName='Mark Meckes' where those posts have zero comments (CommentCount = 0).",
      "sql_description": "Finds posts written by Mark Meckes, keeps those whose id is absent from the comments table, then returns TagName values whose ExcerptPostId equals the post id.",
      "reason": "Tag extraction is wrong: joining tags.ExcerptPostId = posts.Id retrieves tags whose excerpt/wiki post was authored by Mark, not the tags attached to his normal posts. Therefore the query does not list the tags used on Mark’s comment-less posts, missing a required anchor (post-tag association).",
      "verdict": false
    }
  },
  {
    "question_id": 1003,
    "result": {
      "expected_answer": "A single integer: the number of Accident-status results attained by the driver who has the most such accidents across all Canadian Grand Prix races.",
      "sql_description": "1) Finds a driver with the most total RESULTS rows (any status) in Canadian Grand Prix races.\n2) Picks only ONE race called \"Canadian Grand Prix\" (first row found).\n3) Counts how many Accident rows that driver has in THAT SINGLE race.\nResult returned: 0.",
      "reason": "Driver selection ignores Accident filter, so may pick wrong driver; accident count is restricted to one race instead of all Canadian GP races. Missing required anchors: correct driver identification based on accidents and correct aggregation across all Canadian GP events.",
      "verdict": false
    }
  },
  {
    "question_id": 866,
    "result": {
      "expected_answer": "Return the driver (e.g., driverRef or name) who recorded a lap time of 0:01:27 in race 161 together with that driver’s introduction website (url).",
      "sql_description": "Looks in lapTimes for rows where raceId = 161 and the time string is exactly '0:01:27'; joins to drivers and returns driverRef and url.",
      "reason": "The question/evidence says lap times like 0:01:27 are stored as strings beginning with '1:27' (e.g., '1:27.xxx'); the filter should therefore be LIKE '1:27%' rather than an exact match on '0:01:27'. The query’s equality condition is too restrictive and will not find the intended lap, so it fails to retrieve the correct driver and website.",
      "verdict": false
    }
  },
  {
    "question_id": 1029,
    "result": {
      "expected_answer": "List (team name and their buildUpPlaySpeed value) for the four distinct teams that have the highest build-up play speed among all teams.",
      "sql_description": "Selects every Team_Attributes row joined with Team, orders by buildUpPlaySpeed descending, returns the first 4 rows (team name and speed). It does not collapse multiple seasons, so the same team can appear multiple times.",
      "reason": "Question asks for the top 4 TEAMS, implying four distinct teams. The query ranks individual season records, not teams, so one team could occupy multiple slots. It therefore fails to guarantee the required distinct-team anchor even though the sample result happens to show four different teams.",
      "verdict": false
    }
  },
  {
    "question_id": 897,
    "result": {
      "expected_answer": "The full name (forename and surname) and nationality of the driver who has the highest total number of wins, together with that driver’s maximum points scored in a single driverStandings record (MAX(points)).",
      "sql_description": "Finds each driver, counts how many driverStandings rows they have (COUNT(wins)), orders by that count to pick the driver with the most rows, and returns the driver’s forename, surname, nationality and the average of their points (AVG(points)).",
      "reason": "Anchors violated: 1) ‘most winning’ should be based on total wins (e.g., SUM(wins) or MAX(wins)), but the query orders by COUNT(wins), effectively by number of records. 2) It should return the driver’s maximum points, but it returns the average points. Therefore it does not answer the question requirements.",
      "verdict": false
    }
  },
  {
    "question_id": 683,
    "result": {
      "expected_answer": "Percentage of posts created in 2011 whose owner’s reputation is greater than 1000, i.e., (posts with CreationDate in 2011 AND owner Reputation > 1000) / (all posts with CreationDate in 2011) * 100.",
      "sql_description": "Calculates (posts whose OWNER was CREATED in 2011 and has Reputation > 1000) divided by ALL posts in the database, returning that ratio as a percentage.",
      "reason": "Missing required anchor on posts’ CreationDate year 2011; denominator should be 2011 posts only, not all posts. Adds wrong anchor on users’ CreationDate. Therefore it computes a different percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 1035,
    "result": {
      "expected_answer": "IDs (team_fifa_api_id) for every team whose buildUpPlaySpeed value is greater than 50 and less than 60.",
      "sql_description": "Fetches team_fifa_api_id from Team_Attributes where buildUpPlaySpeed is between 51 and 59 inclusive (i.e., >50 and <60).",
      "reason": "The query applies the correct numeric range and returns the requested column; duplicates are not disallowed by the question.",
      "verdict": true,
      "evidence": "Returned column team_fifa_api_id includes values such as 434, 77, 614, etc. (rows 0-19), all coming from records with speed 51-59."
    }
  },
  {
    "question_id": 904,
    "result": {
      "expected_answer": "The name (or ID) of the single race and its season year in which Michael Schumacher recorded his overall fastest lap time (i.e., the minimum lap time/milliseconds among all his race results).",
      "sql_description": "Finds Schumacher’s driverId, searches results rows where fastestLap equals 1, orders those rows by fastestLapTime ascending, keeps the first row, takes its raceId, and returns that raceId and the corresponding year from races.",
      "reason": "Adds an unjustified filter fastestLap = 1, so it does not look across all Schumacher results. It does not minimise milliseconds as required by evidence, and it returns raceId instead of race name. Query produced no rows, showing the logic fails. Required anchors (global minimum lap time) are missing.",
      "verdict": false
    }
  },
  {
    "question_id": 895,
    "result": {
      "expected_answer": "The average lap time (typically using the milliseconds column) of driver Lewis Hamilton during the 2009 Malaysian Grand Prix.",
      "sql_description": "Computes AVG(time) for laps where driver = Sebastian Vettel (driverref='vettel') and race = 2009 Chinese Grand Prix.",
      "reason": "Predicted SQL violates required anchors: driver should be Lewis Hamilton, not Sebastian Vettel; race should be the 2009 Malaysian Grand Prix, not the Chinese Grand Prix. Therefore it answers a different question.",
      "verdict": false
    }
  },
  {
    "question_id": 724,
    "result": {
      "expected_answer": "Names of every superhero whose eye colour is Blue and hair colour is Blond, with no other requirements.",
      "sql_description": "Selects superhero names whose eye colour is Blue AND hair colour is Blond AND who possess the superpower 'Agility'.",
      "reason": "Adds an explicit anchor (must have Agility power) that is not asked for, so it omits blue-eyed, blond-haired heroes lacking that power; result is incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 933,
    "result": {
      "expected_answer": "The finishing rank (positionOrder) that Lewis Hamilton achieved in the 2008 Chinese Grand Prix.",
      "sql_description": "Looks up Lewis Hamilton’s positionOrder in the results table for the 2008 Australian Grand Prix, using a sub-query that incorrectly compares driverId to the string \"Lewis Hamilton\".",
      "reason": "Fails the required anchor \"Chinese Grand Prix\" (uses Australian Grand Prix instead) and mismatches driverId. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1040,
    "result": {
      "expected_answer": "Names of the 10 tallest players (height > 180) with the highest average heading_accuracy, sorted by that average descending.",
      "sql_description": "Joins Player and Player_Attributes, keeps players whose Player.height > 180, groups rows by player_name, orders the groups by the average heading_accuracy in descending order, and returns the first 10 names.",
      "reason": "Query applies the required height filter, correctly aggregates heading_accuracy per player, sorts descending, and limits to 10 names. Grouping by name instead of id is acceptable given typical uniqueness and doesn’t violate any explicit constraint.",
      "verdict": true,
      "evidence": "sql_result shows 10 rows with column player_name ordered as required (e.g., Michael Ballack, Fernando Llorente, ...)."
    }
  },
  {
    "question_id": 945,
    "result": {
      "expected_answer": "The quantity (integer) of circuits whose location is Adelaide and country is Australia.",
      "sql_description": "Counts rows in circuits where country='Australia' and location='Melbourne'.",
      "reason": "Uses Melbourne instead of Adelaide, violating the required location anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 738,
    "result": {
      "expected_answer": "List of superhero names (one per hero) whose Durability attribute value is below 50.",
      "sql_description": "Counts distinct superhero names having Durability attribute value < 50, returning a single integer (368).",
      "reason": "Question asks for the superheroes themselves, not the count. SQL returns only the number, omitting required list.",
      "verdict": false
    }
  },
  {
    "question_id": 930,
    "result": {
      "expected_answer": "The name of the race where Lewis Hamilton achieved his best (smallest) value in the results.rank column, i.e., the race with his highest rank.",
      "sql_description": "Joins results with races and drivers, filters to Lewis Hamilton, orders his records by results.rank ascending (best first) and returns the first race name.",
      "reason": "Uses the specified rank field, finds its minimum for Lewis Hamilton, and outputs the corresponding race name. All required anchors (driver full name, ranking metric, race name) are present.",
      "verdict": true,
      "evidence": "sql_result column: name → row0: 'Belgian Grand Prix'"
    }
  },
  {
    "question_id": 954,
    "result": {
      "expected_answer": "The percentage of race participations by Japanese drivers between 2007 and 2009 that ended with a recorded finish time (results.time IS NOT NULL).",
      "sql_description": "Counts Japanese-driver rows in results whose race is 2007-2009 and whose race record (races.time) is NOT NULL, then divides by a count of an outer-column ‘driverid’ inside races for 2007-2009, yielding 100.0.",
      "reason": "Uses races.time instead of results.time to identify completed races, so completion anchor is wrong. Denominator subquery neither restricts to Japanese drivers nor counts result rows; it references a non-existent driverid column in races, giving an invalid basis for the percentage. Therefore the query does not compute the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 962,
    "result": {
      "expected_answer": "A single percentage value: (number of drivers who took part in races between 2000-2005, were born before 1985, and completed more than 50 laps) divided by (total number of drivers who took part in races between 2000-2005) times 100.",
      "sql_description": "Counts result rows (not distinct drivers) with laps>50 in races 2000-2005 and divides by the total number of drivers born before 1985 in the whole drivers table, returning that ratio *100.",
      "reason": "Denominator anchor is wrong: it should count drivers appearing in races 2000-2005, but the query counts all drivers born before 1985 regardless of participation or year. Therefore the percentage is computed against an incorrect base population.",
      "verdict": false
    }
  },
  {
    "question_id": 1078,
    "result": {
      "expected_answer": "Return the player (among Aaron Lennon and Abdelaziz Barrada) whose birthday is earlier, i.e., the older of the two.",
      "sql_description": "Fetches both players, orders them by birthday ascending (earlier date first, hence older first), and returns the first row (player_name and birthday).",
      "reason": "Correctly applies the older-means-earlier rule; returns the single older player. Extra birthday column is still relevant to age comparison.",
      "verdict": true,
      "evidence": "sql_result shows (player_name, birthday) with Aaron Lennon 1987-04-16 → selected as older."
    }
  },
  {
    "question_id": 761,
    "result": {
      "expected_answer": "The superhero_name values for male superheroes whose weight_kg is greater than 0.79 times the average weight_kg of all superheroes.",
      "sql_description": "Returns superhero.full_name for male superheroes with weight_kg above 0.79 * AVG(weight_kg) across the entire table.",
      "reason": "Violates explicit anchor: question/evidence map 'super hero names' to column superhero_name, but query selects full_name. Other conditions are fine but required column is wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 972,
    "result": {
      "expected_answer": "List the driverId and code for drivers whose date of birth is in the year 1971 and who recorded the fastest lap of a race (reasonable interpretation: rank = 1 for fastestLap).",
      "sql_description": "Selects driverId and code for drivers whose dob equals the literal string '1971' and whose fastestLapTime field is not NULL in any results row.",
      "reason": "1) DOB anchor: compares full date to the string '1971', so it will return nothing or wrong rows; does not filter to the 1971 birth year.\n2) Fastest-lap anchor: only checks that fastestLapTime is non-NULL, not that the driver actually achieved the fastest lap of a race (e.g., rank = 1). Both required anchors are mishandled.",
      "verdict": false
    }
  },
  {
    "question_id": 989,
    "result": {
      "expected_answer": "Return the driver (champion) who finished 1st in the 2008 Canadian Grand Prix and give his recorded finish time.",
      "sql_description": "Joins races with results and drivers, filters to the 2008 Canadian Grand Prix and position = 1, then outputs the driver's forename, surname, and results.time.",
      "reason": "Query applies the race name, year, and winner (position 1) anchors exactly as required and returns the requested driver identity plus finish time.",
      "verdict": true,
      "evidence": "Row0: forename=Robert, surname=Kubica, time=1:36:24.227"
    }
  },
  {
    "question_id": 772,
    "result": {
      "expected_answer": "The list of eye, hair, and skin colour names for every superhero whose gender is 'Female' and whose publisher is 'Dark Horse Comics'.",
      "sql_description": "Selects eye, hair, and skin colour strings by joining the superhero table to the colour table three times and filtering rows where gender is 'Female' and publisher is 'Dark Horse Comics'.",
      "reason": "Query applies all explicit anchors (gender and publisher) and returns exactly the requested three colour columns. This satisfies the question; any superheroes with NULL colour ids would be excluded, which is acceptable for a colour list.",
      "verdict": true,
      "evidence": "sql_result shows columns eye_colour, hair_colour, skin_colour with 5 rows (e.g., Green/Blond/No Colour, Brown/Brown/No Colour, …), matching requested output format."
    }
  },
  {
    "question_id": 940,
    "result": {
      "expected_answer": "A single integer: the count of distinct drivers who finished (time not null) the 2008 Chinese Grand Prix and, having at least one race record, thus participated in Formula 1.",
      "sql_description": "Counts distinct drivers (results.driverid) with non-NULL time in the 2008 Australian Grand Prix (races.year = 2008 AND races.name = 'Australian Grand Prix').",
      "reason": "Wrong race anchor: query filters Australian Grand Prix instead of Chinese Grand Prix, so it does not measure the requested event.",
      "verdict": false
    }
  },
  {
    "question_id": 1002,
    "result": {
      "expected_answer": "Return the full name (forename+surname), nationality, and the race name of the very first race that the youngest driver (latest DOB) ever entered.",
      "sql_description": "Finds the driver whose DOB equals the minimum DOB (oldest driver), then lists all races that driver has results in, producing duplicates. It does not pick the first race chronologically.",
      "reason": "1) Youngest anchor wrong: uses MIN(dob) instead of MAX(dob).\n2) First-race anchor missing: shows every race the driver ran, not the earliest.\nTherefore the query does not satisfy the question’s requirements.",
      "verdict": false
    }
  },
  {
    "question_id": 950,
    "result": {
      "expected_answer": "Names of all constructors who scored 0 points in raceID 291.",
      "sql_description": "Joins constructorResults with constructors and returns constructor names where raceId = 291 and points = 0.",
      "reason": "Query applies the required race anchor (291) and the points=0 filter, then outputs the corresponding constructor names, satisfying the question.",
      "verdict": true,
      "evidence": "Result contains 11 rows with column 'name', e.g., Minardi, Dallara, Larrousse …"
    }
  },
  {
    "question_id": 1032,
    "result": {
      "expected_answer": "Return the league (its name) that has hosted the greatest total number of matches in the entire dataset, together with that match count.",
      "sql_description": "Joins Match with League, counts matches per league, orders by the count descending, and returns the top league name and its match count (LIMIT 1).",
      "reason": "Query correctly counts matches for each league, identifies the maximum, and outputs name plus count, satisfying the question. No missing anchors or extra constraints.",
      "verdict": true,
      "evidence": "sql_result shows: name='Spain LIGA BBVA', matches_played=3040 (columns: name, matches_played)"
    }
  },
  {
    "question_id": 796,
    "result": {
      "expected_answer": "List of each attribute of 3-D Man (attribute_name) together with its attribute_value.",
      "sql_description": "Joins superhero -> hero_attribute -> attribute to fetch attribute_name and attribute_value for the hero whose superhero_name is '3-D Man'.",
      "reason": "Query correctly filters on 3-D Man and returns every linked attribute with its value; extra superhero_name column is acceptable.",
      "verdict": true,
      "evidence": "sql_result rows: [superhero_name, attribute_name, attribute_value] e.g., (3-D Man, Intelligence, 80), (3-D Man, Strength, 35), etc."
    }
  },
  {
    "question_id": 959,
    "result": {
      "expected_answer": "The lap number (integer from lapTimes.lap) on which the 2009 season champion set his quickest lap time.",
      "sql_description": "Finds all laps of every driver who had position=1 in each 2009 race, then returns the maximum lapTimes.time among those laps.",
      "reason": "Query returns a time value, not a lap number; it also uses MAX (slowest) instead of MIN (fastest). Required anchor “lap number of the champion” is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 967,
    "result": {
      "expected_answer": "1) A list (three values) of the code or number field for the three youngest drivers (latest DOBs). 2) A separate count of how many of those three have nationality 'Dutch/Netherlandic'.",
      "sql_description": "Selects forename and date of birth of the three drivers with the most recent DOB.",
      "reason": "Returns names and DOB only, not the requested code/number values, and provides no count of Netherlandic drivers. Missing both required anchors (code numbers and NL count).",
      "verdict": false
    }
  },
  {
    "question_id": 850,
    "result": {
      "expected_answer": "Names of all races that took place on circuits located in Germany.",
      "sql_description": "Selects the race name from races joined with circuits and filters to rows where the circuit’s country is Germany.",
      "reason": "Query correctly links races to their circuits and restricts by country = 'Germany', returning the race names, which is exactly what the question asks. Duplication is harmless since uniqueness was not requested.",
      "verdict": true,
      "evidence": "sql_result shows column name with values such as 'German Grand Prix' and 'European Grand Prix', matching races held in Germany (rows 0-19)."
    }
  },
  {
    "question_id": 978,
    "result": {
      "expected_answer": "For each circuit located in Austria, return its location and geographical coordinates (lat, lng) together with how many races have been held on that circuit; or at minimum list the Austrian circuits and the count of times they were used.",
      "sql_description": "Retrieves the location, lat, lng of circuits that appear in races whose year is linked to a season having url = 'url_for_Austria_season'. Does not filter by country='Austria' and provides no counts.",
      "reason": "Misses required country anchor (Austria) and does not compute the number of times each circuit was held. Result set is empty, so the question is unanswered.",
      "verdict": false
    }
  },
  {
    "question_id": 994,
    "result": {
      "expected_answer": "Identify the constructor (team) with the highest accumulated (total) points in all Monaco Grand Prix races held from 1980 through 2010 inclusive. Return that total points value together with the constructor’s name and nationality.",
      "sql_description": "Looks at constructorStandings rows for Monaco GP races between 1980-2010, but takes each row as-is, orders by the single-race points value, and returns the one row with the largest points scored in an individual race, not the total across years.",
      "reason": "Fails to aggregate points per constructor; thus may choose a constructor that had a single high-scoring race even if another constructor has the highest cumulative points across 1980-2010.",
      "verdict": false
    }
  },
  {
    "question_id": 1076,
    "result": {
      "expected_answer": "A single numerical value: (average ball_control of Abdou Diallo) minus (average ball_control of Aaron Appindangoye).",
      "sql_description": "Computes AVG(ball_control) for each of the two players separately, returning two rows (one per player) but does not subtract them.",
      "reason": "Missing required anchor: the subtraction between the two averages; query outputs each average rather than their difference.",
      "verdict": false
    }
  },
  {
    "question_id": 1011,
    "result": {
      "expected_answer": "Full name(s) (forename and surname) of the driver(s) who hold the shortest-ever Formula 1 lap time record, restricted to drivers classified as “top 20”.",
      "sql_description": "Finds the minimum value of lapTimes.time over the entire table, then returns the forename and surname of any driver whose lap time equals that minimum, with no additional filters.",
      "reason": "Query ignores the required \"top 20 driver\" constraint; the mandatory anchor is missing, so the SQL does not match the question intent.",
      "verdict": false
    }
  },
  {
    "question_id": 1084,
    "result": {
      "expected_answer": "The count of distinct players (unique player_api_id) who were born before 1986 and whose defensive_work_rate is 'high'.",
      "sql_description": "Joins Player with Player_Attributes, filters birthdays with year < 1986 and defensive_work_rate = 'high', then counts ALL resulting rows without DISTINCT.",
      "reason": "Question explicitly requires counting distinct players; predicted SQL counts attribute rows, potentially duplicating players and inflating the total. Missing DISTINCT anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 861,
    "result": {
      "expected_answer": "The car/driver number of the competitor whose Q3 lap time was 0:01:54 in qualifying for race 903.",
      "sql_description": "Fetches the column \"number\" from the qualifying table for rows where raceId = 903 and the Q3 time equals '0:01:54'.",
      "reason": "Query applies both required anchors (race 903 and Q3 time 0:01:54) and returns the requested driver number; no extraneous conditions.",
      "verdict": true,
      "evidence": "sql_result shows column [number]; 0 rows returned in this instance, but structure aligns with requirement."
    }
  },
  {
    "question_id": 1036,
    "result": {
      "expected_answer": "The names of teams whose buildUpPlayPassing value in 2012 is higher than the average buildUpPlayPassing of all teams in 2012.",
      "sql_description": "Selects team_long_name for rows dated 2012 where the team’s buildUpPlayPassing is greater than the overall average buildUpPlayPassing computed from every row in Team_Attributes, regardless of year.",
      "reason": "The sub-query calculating the average ignores the 2012 filter, so the comparison is not against the 2012 average requested by the question. Missing 2012 anchor in the average calculation.",
      "verdict": false
    }
  },
  {
    "question_id": 1094,
    "result": {
      "expected_answer": "A single numeric value: the percentage by which Ariel Borysiuk’s overall rating exceeds Paulin Puel’s, computed as (Ariel – Paulin) / Paulin * 100.",
      "sql_description": "Takes every overall_rating record of Ariel Borysiuk and every overall_rating record of Paulin Puel, cross-joins them, then computes the percentage difference for each pair (without aggregation) and attempts to return the result as a single value.",
      "reason": "The query does not isolate a unique rating for each player (e.g., latest or average); instead it cross-joins all their rating rows, producing multiple differences. This violates the required anchor of using a single comparable rating per player, so the result is logically unreliable.",
      "verdict": false
    }
  },
  {
    "question_id": 868,
    "result": {
      "expected_answer": "Latitude and longitude of the circuit where the Malaysian Grand Prix takes place.",
      "sql_description": "Looks up races named 'Malaysian Grand Prix', joins to their circuit and returns that circuit’s lat and lng.",
      "reason": "Uses race name anchor to identify the correct circuit and outputs its coordinates; duplicates do not change the answer.",
      "verdict": true,
      "evidence": "sql_result rows show lat=2.76083, lng=101.738 for all occurrences."
    }
  },
  {
    "question_id": 1058,
    "result": {
      "expected_answer": "Identify which of the two extreme-height players (the tallest and the shortest in the Player table) has the larger average finishing score; returning either just that player or both players with their averages is acceptable.",
      "sql_description": "Finds the tallest and the shortest player(s) by comparing player.height to the MAX and MIN heights, computes each one’s average finishing score from Player_Attributes, and lists their names with the averages.",
      "reason": "Query correctly restricts to players whose height equals the global maximum or minimum, calculates their average finishing, and returns the data needed to see which of them has the higher average. Providing both rows is permissible for a comparison question.",
      "verdict": true,
      "evidence": "Rows: [player_name, average_finishing_rate] -> (0) Juan Quero 60.9, (1) Kristof van Hout 15.5. Highest average belongs to Juan Quero."
    }
  },
  {
    "question_id": 877,
    "result": {
      "expected_answer": "The name/identifier of the youngest driver among those who finished race 872 (drivers with non-NULL time).",
      "sql_description": "Joins drivers with results, keeps rows for raceId = 872 where time is not NULL, orders by dob descending (latest birthdate) and returns the first driverRef.",
      "reason": "Query applies the required filters (race 872, finished) and picks the driver with the latest dob, correctly answering who is the youngest.",
      "verdict": true,
      "evidence": "sql_result shows driverRef = 'perez' in row 0."
    }
  },
  {
    "question_id": 1122,
    "result": {
      "expected_answer": "The name of the player (or players) whose overall_rating value is the highest in the data set.",
      "sql_description": "Returns the lexicographically greatest player_name from the Player table without considering overall_rating or any strength metric.",
      "reason": "Required anchor overall_rating is absent; query picks alphabetical max name rather than strongest player.",
      "verdict": false
    }
  },
  {
    "question_id": 1134,
    "result": {
      "expected_answer": "A single numeric value representing player 6's jumping score minus player 23's jumping score (could be negative if player 23 jumps higher).",
      "sql_description": "Fetches each player’s own jumping score twice: once for player 6 and once for player 23, and in each row subtracts the same value from itself, producing 0; returns two (or more) rows instead of one aggregated difference.",
      "reason": "The query never references both players in the same arithmetic expression, so it cannot compute their score difference. Instead it returns 0 for each selected row. Thus it fails to answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 896,
    "result": {
      "expected_answer": "The percentage (share) of all races since 2010 in which driver Hamilton finished in a position other than 1st. It should equal (non-first finishes / total Hamilton finishes) * 100, or the equivalent ratio.",
      "sql_description": "Counts the number of driverStandings rows for Hamilton since 2010 where position > 1 and returns this count (104). Does not compute any ratio against total races.",
      "reason": "The query omits the denominator (total Hamilton races) and thus outputs a raw count, not a percentage. Required anchor of computing the ratio is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 902,
    "result": {
      "expected_answer": "List the race(s) (e.g., raceId or race names) in which driver Alex Yoong finished with a position number less than 20.",
      "sql_description": "Finds raceId values for Alex Yoong but only where his finishing position is below 10 (position < 10).",
      "reason": "The question asks for positions less than 20, but the query filters position < 10, missing races where his position is 10-19. Required anchor (position < 20) is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1144,
    "result": {
      "expected_answer": "Return the finishing (finishing rate) and curve score for the player(s) whose weight is the maximum in the Player table.",
      "sql_description": "Joins Player and Player_Attributes, filters players whose weight equals the maximum weight found in Player, and lists each of their Player_Attributes rows with player_name, finishing and curve.",
      "reason": "Query correctly anchors on MAX(weight) and outputs the requested finishing and curve values for those player(s). Extra rows from different dates are still legitimate instances of the same attributes for the heaviest player(s); no required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows columns player_name, finishing, curve for players with the heaviest weight (Kristof van Hout and Tim Wiese) across several attribute snapshots."
    }
  },
  {
    "question_id": 1098,
    "result": {
      "expected_answer": "Return Ajax’s maximum chanceCreationPassing value and the corresponding chanceCreationPassingClass at that maximum value.",
      "sql_description": "Finds all Team_Attributes rows for Ajax, computes MAX(chanceCreationPassing) but returns an arbitrary (not aggregated) chanceCreationPassingClass from the same Ajax group.",
      "reason": "The query does not tie chanceCreationPassingClass to the row(s) where chanceCreationPassing is maximal; the non-aggregated column can come from any Ajax record, so required anchor (class of the max score) is not guaranteed.",
      "verdict": false
    }
  },
  {
    "question_id": 1107,
    "result": {
      "expected_answer": "The earliest date on which Kevin Constant recorded his highest crossing score.",
      "sql_description": "Finds Kevin Constant’s maximum crossing value, then returns the minimum date among Player_Attributes rows for him that have that crossing value.",
      "reason": "Query applies correct player filter, computes MAX(crossing) to identify highest score, then picks MIN(date) to capture the first occurrence, satisfying all anchors (player, highest crossing, first time).",
      "verdict": true,
      "evidence": "Result shows MIN(date) column with value 2013-02-15 00:00:00, matching requested output."
    }
  },
  {
    "question_id": 1136,
    "result": {
      "expected_answer": "A single number: the count of distinct players whose crossing score equals the maximum crossing value in the dataset and whose preferred_foot is 'left'.",
      "sql_description": "Returns the player_name rows (one per matching Player_Attributes row) where crossing equals the global maximum and preferred_foot is 'left'. It does not aggregate or count; duplicates can appear.",
      "reason": "Question asks \"how many\", requiring a numeric count. Query returns names (with duplicates) instead of counting, so it does not satisfy the required anchor of producing the quantity.",
      "verdict": false
    }
  },
  {
    "question_id": 1148,
    "result": {
      "expected_answer": "A single numeric percentage: (number of players shorter than 180 cm AND overall_rating>70) divided by (total number of players) × 100.",
      "sql_description": "Counts players with height<180 and rating>70, then divides that count by itself (COUNT(*)/COUNT(*)) producing 100, independent of the total player count.",
      "reason": "Denominator anchor is wrong – it should be total players, not the filtered subset. Query therefore always returns 100 and cannot represent the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 1145,
    "result": {
      "expected_answer": "A list of the four leagues that hosted the greatest number of matches during the 2015/2016 season, most-games first (league names and optionally their game counts).",
      "sql_description": "Counts games per league for season 2015/2016, orders by that count descending, but keeps only the single top league due to LIMIT 1.",
      "reason": "Question explicitly asks for the top 4 leagues, but the query limits the result to 1 league, omitting three required leagues. Anchor on number of requested rows is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1153,
    "result": {
      "expected_answer": "The result should include: (1) the diagnosis/disease name for patient ID 30609, and (2) every date on which that patient had laboratory tests.",
      "sql_description": "Fetches the Diagnosis column from the Patient table where ID = 30609.",
      "reason": "Query returns only the diagnosis and omits the required list of laboratory-test dates, so it does not fully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1149,
    "result": {
      "expected_answer": "Identify whether male in-patients or male out-patients are more numerous and give the deviation as a percentage (defined as COUNT(male in-patients) divided by COUNT(male out-patients), or equivalent).",
      "sql_description": "Counts male in-patients and male out-patients then subtracts the second from the first, returning a raw difference in number of patients, not a percentage.",
      "reason": "The query returns a count difference, not the required percentage ratio, and it does not indicate which group is larger. Missing the required percentage anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1115,
    "result": {
      "expected_answer": "Percentage difference where we take Landon Donovan’s overall rating on 2013-07-12, subtract Jordan Bowery’s rating on the same date, divide that difference by Landon Donovan’s rating, then multiply by 100.",
      "sql_description": "Fetches both players’ ratings for 2013-07-12 and returns round(((Donovan – Bowery)/Bowery)*100,2) – i.e., the difference expressed as a percentage of Jordan Bowery’s rating.",
      "reason": "Required anchor from evidence says denominator must be Landon Donovan’s rating, but query divides by Jordan Bowery’s rating. Therefore it answers a different percentage. Query also returns no rows.",
      "verdict": false
    }
  },
  {
    "question_id": 1130,
    "result": {
      "expected_answer": "List of team_short_name values for teams whose chanceCreationPassingClass is 'Safe'. Duplicates acceptable unless stated otherwise.",
      "sql_description": "Joins Team with Team_Attributes on team_api_id and returns team_short_name where chancecreationpassingclass equals 'Safe'.",
      "reason": "Captures required anchor (chanceCreationPassingClass='Safe') and returns requested field (team_short_name). Extra duplicates are permissible since question does not forbid them.",
      "verdict": true,
      "evidence": "sql_result shows column team_short_name with values such as 'HAA', 'ARK', 'ARL', etc., matching the requested information."
    }
  },
  {
    "question_id": 951,
    "result": {
      "expected_answer": "The number (count) of constructors whose nationality is Japanese and who recorded 0 points in each of the two races in which they appeared (i.e., they have exactly 2 race entries and both have 0 points).",
      "sql_description": "Counts distinct constructors that (1) are Japanese, (2) have exactly two race entries, and (3) have at least one entry with points = 0. It does not ensure that BOTH race entries have 0 points or that the total points are 0.",
      "reason": "The query omits the anchor that all (or the total of) points in the two races must be zero; it only checks points=0 for the rows it keeps, allowing constructors who scored points in one of the two races to be counted. Therefore it may over-count and does not faithfully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1187,
    "result": {
      "expected_answer": "IDs of patients who have at least one examination dated between 1987-07-06 and 1996-01-31 and whose lab results show GPT > 30 and ALB < 4; the set size answers the 'how many' part.",
      "sql_description": "Finds patients whose Examination.Examination Date is between 1987-07-06 and 1996-01-31 and who also have Laboratory records with GPT > 30 and ALB < 4, then returns their patient.id values (duplicates possible).",
      "reason": "All required anchors are present: examination date range, GPT > 30, ALB < 4, linkage to the same patient. Listing IDs satisfies the listing request, and the count can be derived from row count. No extraneous or missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows two rows with column ID: [460574, 1043570], giving count=2."
    }
  },
  {
    "question_id": 1139,
    "result": {
      "expected_answer": "Return the home and away goal counts (final score) of the Belgian Jupiler League match played on 2008-09-24.",
      "sql_description": "Selects home_team_goal and away_team_goal from Match where date starts with '2008-09-24' and where league_id literally equals the text 'Belgium Jupiler League'.",
      "reason": "Fails to anchor on the league: league_id stores a numeric id, not the league name, so the comparison to the string 'Belgium Jupiler League' is invalid. Thus the query does not correctly filter the Belgian Jupiler League match.",
      "verdict": false
    }
  },
  {
    "question_id": 1001,
    "result": {
      "expected_answer": "Full name (forename and surname) of the driver who finished 1st in qualifying session Q3 for the 2008 race held at Marina Bay Street Circuit.",
      "sql_description": "Finds drivers with qualifying.position = 1 in 2008 Marina Bay race, BUT also requires their q3 time to equal the overall minimum q3 time for raceid = 3 (an unrelated race).",
      "reason": "Introduces an incorrect anchor (q3 = MIN(q3) for raceid 3) that is unrelated to the requested race, causing the correct driver to be filtered out and producing no result. Hence the query does not reliably return the required driver.",
      "verdict": false
    }
  },
  {
    "question_id": 1209,
    "result": {
      "expected_answer": "A list of diagnosis values for patients whose GPT (ALT) exceeds 60, ordered from the oldest patient (earliest birthday) to the youngest.",
      "sql_description": "Joins Patient and Laboratory on patient ID, keeps rows where Laboratory.GPT > 60, orders the rows by Patient.Birthday ascending, and outputs the Patient.Diagnosis column.",
      "reason": "Query applies the correct GPT>60 filter, selects the requested diagnosis field, and sorts by birthday ascending as required. Potential duplicate diagnoses due to multiple lab records per patient are acceptable because uniqueness was not specified.",
      "verdict": true,
      "evidence": "sql_result shows one column \"Diagnosis\" with 20 rows, ordered (row 0 older) as expected."
    }
  },
  {
    "question_id": 1014,
    "result": {
      "expected_answer": "For every circuit located in Italy, return its lap record, i.e., the fastest lap time ever recorded on that circuit (likely along with the circuit identifier/name).",
      "sql_description": "Finds all lap times from races held on Italian circuits, orders them by time, and returns the single overall fastest lap time (first row).",
      "reason": "Query returns only one lap time, not one record per circuit, and omits circuit identifiers. It therefore does not list the lap records for each Italian circuit.",
      "verdict": false
    }
  },
  {
    "question_id": 1166,
    "result": {
      "expected_answer": "Symptoms (non-NULL) and corresponding diagnosis for the single youngest patient who has at least one medical examination record.",
      "sql_description": "Returns symptoms and diagnosis from the Examination table for the patient whose birthday equals the minimum birthday value (oldest patient), without checking that symptoms are non-NULL.",
      "reason": "Uses MIN(birthday) so selects the oldest, not the youngest patient; also omits the required non-NULL symptoms filter. Therefore mandatory anchors (youngest, symptoms observed) are not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1031,
    "result": {
      "expected_answer": "Present-day age(s) of players whose sprint_speed is at least 97 in any player_attributes record dated between 2013 and 2015 (inclusive).",
      "sql_description": "Computes present age from Player.birthday and returns it for players whose sprint_speed ≥ 97, but restricts players to those whose birthday itself falls between 2013-01-01 and 2015-12-31; no filter on player_attributes.date.",
      "reason": "Required anchor “player_attributes date between 2013 and 2015” is missing and replaced by an incorrect birthday filter, so the query targets the wrong cohort and fails to answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1189,
    "result": {
      "expected_answer": "Count of patients whose Examination record shows Thrombosis = 2 and ANA Pattern = 'S', and whose aCL IgM value is more than 20% above the overall average aCL IgM.",
      "sql_description": "Counts distinct patients where Examination.diagnosis = 'thrombosis', Examination.ANA = 'S', and Laboratory.IGM exceeds 1.2 times the average Laboratory.IGM across all rows.",
      "reason": "Misses required anchors: 1) does not restrict Thrombosis level = 2 (uses diagnosis text instead); 2) compares Laboratory.IGM instead of Examination.aCL IgM; 3) uses ANA column rather than ANA Pattern. Therefore the query does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1175,
    "result": {
      "expected_answer": "Return the patient’s age at their examination date (year difference between Examination Date and Birthday) for the patient whose hemoglobin (HGB) value is the highest among all examinations/laboratory records, together with that patient’s doctor diagnosis.",
      "sql_description": "Takes the maximum HGB value from Laboratory across all patients, but simultaneously outputs a single (arbitrary) patient_age and diagnosis from some joined Examination-Patient row without ensuring they belong to the record that owns the max HGB.",
      "reason": "The query aggregates HGB with MAX but does not restrict the accompanying age and diagnosis to the same row that produced that maximum; lacking GROUP BY or a filter tying the non-aggregated columns to the max causes mismatched data. Therefore the returned age/diagnosis may not correspond to the patient with the highest hemoglobin, violating the key anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1037,
    "result": {
      "expected_answer": "A single number: the percentage (or proportion) of distinct players born between 1987-01-01 and 1992-12-31 whose preferred_foot is 'left'. Numerator and denominator must both be counted at the player level.",
      "sql_description": "Counts ALL rows in Player_Attributes with preferred_foot='left' for players born in the period and divides by the count of distinct players born in the period from Player. Does not use DISTINCT, so the numerator counts multiple attribute snapshots per same player, then returns the ratio (without multiplying by 100).",
      "reason": "Fails anchor on counting players: duplicates in Player_Attributes inflate the numerator, giving an incorrect percentage (result > 1 proves this). Required DISTINCT on player_fifa_api_id is missing, so it does not measure percentage of players.",
      "verdict": false
    }
  },
  {
    "question_id": 1201,
    "result": {
      "expected_answer": "A single numeric value: the percentage (0-100) of patients whose birthday year is 1980 and whose diagnosis is RA that have sex = 'F'.",
      "sql_description": "Filters Patient rows where strftime('%Y', Birthday) = '1980' and Diagnosis = 'RA', counts how many of these have SEX = 'F', divides by total matching rows, and multiplies by 100 to output that percentage.",
      "reason": "Query applies the correct filters (born 1980, diagnosis RA) and computes 100 * females / total. Matches the question’s required anchors and calculation.",
      "verdict": true,
      "evidence": "sql_result shows column percentage with value 100 (row 0), meaning 100% of the qualifying patients are female."
    }
  },
  {
    "question_id": 1229,
    "result": {
      "expected_answer": "Number of distinct patients whose triglyceride (tg) value is 200 or higher and whose age is greater than 50 years.",
      "sql_description": "Counts all rows from Patient joined to Laboratory where tg >= 200 and the year difference between current date and Birthday is more than 50.",
      "reason": "TG and age conditions are present, but the query counts rows not distinct patients. If a patient has multiple laboratory records it will be over-counted. The evidence explicitly requires DISTINCT.",
      "verdict": false
    }
  },
  {
    "question_id": 1220,
    "result": {
      "expected_answer": "List of patient IDs, their sex, and birthday for all patients whose urea nitrogen (UN) value equals 29 (i.e., exactly at the borderline).",
      "sql_description": "Retrieves patient ID, sex, and birthday by joining Patient and Laboratory tables, but filters rows where UA (uric acid) equals 29 instead of UN.",
      "reason": "Required anchor is UN = 29; query uses UA = 29, therefore it targets the wrong laboratory measure and does not satisfy the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1068,
    "result": {
      "expected_answer": "A single number: the average overall_rating for those player attribute records dated 2010-2015 (inclusive) whose player’s height is greater than 170 cm.",
      "sql_description": "Joins Player_Attributes with Player, filters rows where Player.height > 170 and the attribute date’s year is between 2010 and 2015, then returns AVG(overall_rating).",
      "reason": "Query includes the height >170 anchor and the 2010-2015 date window and computes the required average rating; averaging over attribute rows is a reasonable interpretation.",
      "verdict": true,
      "evidence": "sql_result shows one column AVG(overall_rating) with value 68.901357."
    }
  },
  {
    "question_id": 1205,
    "result": {
      "expected_answer": "A yes/no determination of whether patient 57266’s uric-acid value is within the defined normal range (UA>8.0 for males, UA>6.5 for females).",
      "sql_description": "Selects the UA value for patient 57266 only when the value satisfies the ‘normal range’ rule based on the patient’s sex; if the rule is met, it outputs the UA value, otherwise it returns no rows.",
      "reason": "The query checks the required thresholds tied to sex and the correct patient ID. A returned row implies the value is within the stated range; no row would imply it is not. With UA = 8.1 returned, the answer is effectively ‘Yes’. Although the output is the UA number rather than an explicit yes/no, it unambiguously conveys the necessary judgment.",
      "verdict": true,
      "evidence": "Returned column UA = 8.1 (row 0) indicating rule satisfied => ‘Yes’."
    }
  },
  {
    "question_id": 1231,
    "result": {
      "expected_answer": "The number of distinct male patients whose year of birth is between 1936 and 1956 (inclusive) and who have at least one laboratory record with CPK ≥ 250.",
      "sql_description": "Counts all rows produced by joining Patient with Laboratory where Patient.birthday lies lexicographically between the strings '1936' and '1956', Patient.sex is 'M', and Laboratory.CPK ≥ 250.",
      "reason": "1) Uses COUNT(*) without DISTINCT, so it counts lab records, not unique patients. 2) Compares full birthday dates directly to strings '1936' and '1956' instead of filtering by birth year, risking incorrect inclusion/exclusion. Thus required anchors (distinct patients, correct birth-year filter) are not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1239,
    "result": {
      "expected_answer": "List of patient IDs together with each patient’s age (current year minus birth year) for patients who have at least two laboratory records where their hematocrit (HCT) value is 52 or higher.",
      "sql_description": "Finds patient IDs that appear in the Laboratory table with HCT ≥ 52 in three or more records (COUNT(id) > 2) and returns those IDs with their ages.",
      "reason": "The query requires more than two (≥3) abnormal HCT records, while the question asks for two or more (≥2). This stricter condition can omit valid patients, violating the anchor on the examination count.",
      "verdict": false
    }
  },
  {
    "question_id": 1243,
    "result": {
      "expected_answer": "A single percentage value: among patients older than 55, the proportion (in %) of those with abnormal PT (PT >=14) who are female.",
      "sql_description": "Calculates 100 * (count of lab rows where PT >=14 and sex='F') divided by (count of patients whose birthday is more than 55 years ago), across all rows of Patient joined to Laboratory.",
      "reason": "Denominator should count older patients with abnormal PT, but query counts all older patients regardless of PT. Numerator should be restricted to older patients, but age filter is missing. Thus percentage is mis-computed; required anchors (age filter in numerator and PT filter in denominator) are violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1225,
    "result": {
      "expected_answer": "For each sex (M or F), return a group-concatenated list of distinct patient IDs whose total bilirubin (T-BIL) value is 2.0 or higher.",
      "sql_description": "Joins Patient and Laboratory, filters rows where T-BIL >= 2.0, then returns sex with COUNT(*) of matching laboratory rows.",
      "reason": "The query returns counts of rows instead of the required concatenated list of distinct patient IDs, and may double-count patients with multiple lab records. It misses the explicit 'list' anchor (GROUP_CONCAT(DISTINCT ID)).",
      "verdict": false
    }
  },
  {
    "question_id": 1247,
    "result": {
      "expected_answer": "A single integer: the number of DISTINCT male patients (Sex = 'M') whose white blood cell count is within the normal range (3.5 < WBC < 9.0) AND whose fibrinogen level is abnormal (FG <= 150 OR FG >= 450). Duplicate laboratory records for the same patient must not be double-counted.",
      "sql_description": "Counts distinct patient IDs from Patient-Laboratory-Examination join that satisfy (p.sex = 'M' AND FG <= 150) OR (FG >= 450 AND WBC between 3.5 and 9.0 AND diagnosis = 'Normal').",
      "reason": "1) Due to operator precedence, the WHERE clause splits into two disjuncts; the second disjunct does NOT require male sex, and the first disjunct lacks the WBC normality filter. Hence female patients may be counted and some counted males may have abnormal WBC values. 2) An extra diagnosis = 'Normal' constraint, not requested, can exclude valid patients. Required anchors (male, normal WBC, abnormal FG) are not simultaneously enforced, so the query does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1254,
    "result": {
      "expected_answer": "A single count of patients whose IgA result is strictly greater than 80 and strictly less than 500 and whose First Date is on or after 1990-01-01.",
      "sql_description": "Counts distinct patient IDs after joining Patient and Laboratory where IgA is BETWEEN 80 AND 500 (inclusive) and the year of First Date is 1990 or later.",
      "reason": "Required anchor \"IGA > 80 AND IGA < 500\" is violated: the query uses BETWEEN 80 AND 500, thus including boundary values 80 and 500 that should be excluded.",
      "verdict": false
    }
  },
  {
    "question_id": 1265,
    "result": {
      "expected_answer": "The count of distinct patients whose anti-ribonuclear protein (Laboratory.RNP) value is '-' or '+-' (normal) and whose hospital Admission flag (Patient.Admission) is '+'.",
      "sql_description": "Counts distinct patient IDs that simultaneously: 1) appear in Examination with Diagnosis = 'Normal', 2) have Laboratory.RNP in ('-', '+-'), and 3) have Patient.Admission = '+'.",
      "reason": "Adds an unrequested anchor on Examination.Diagnosis = 'Normal' and requires a matching Examination row. This invented constraint can exclude patients that otherwise satisfy the question, so result may be incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1255,
    "result": {
      "expected_answer": "The single disease name that occurs most frequently among all patients who have any laboratory measurement with IgM ≤ 40 or IgM ≥ 400.",
      "sql_description": "Finds patients whose IgM value is outside the interval 40-400 (strictly <40 or >400), retrieves their diagnoses, counts occurrences and returns the diagnosis with the highest count.",
      "reason": "The query excludes IgM values exactly equal to 40 or 400 by using NOT BETWEEN 40 AND 400, contradicting the explicit anchor (IgM ≤40 OR ≥400). Required boundary cases are therefore omitted.",
      "verdict": false
    }
  },
  {
    "question_id": 1281,
    "result": {
      "expected_answer": "The birth date (Birthday) of the youngest patient (i.e., latest/maximum birthday value) among those whose GOT lab value is 60 or higher.",
      "sql_description": "Retrieves the smallest (earliest) birthday of patients whose ID appears in any laboratory record with GOT ≥ 60.",
      "reason": "The query uses MIN(birthday) instead of MAX(birthday). MIN returns the oldest patient's birthdate, not the youngest, violating the question’s requirement to find the youngest.",
      "verdict": false
    }
  },
  {
    "question_id": 1267,
    "result": {
      "expected_answer": "The number of patients whose anti-SM result is normal (SM value '-' or '+-') and whose Thrombosis field equals 0 (no thrombosis).",
      "sql_description": "Counts rows where SM equals 'negative' and Thrombosis equals '1' (patient has thrombosis) after joining the three tables.",
      "reason": "It filters on Thrombosis = 1 instead of 0 (opposite of ‘does not have thrombosis’) and ignores the '+-' normal value. Required anchors for thrombosis condition and full normal SM set are violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1322,
    "result": {
      "expected_answer": "A single integer: the number of events with type = 'Meeting' that were attended by more than 10 members.",
      "sql_description": "Returns the event_id and event_name of each event whose type is 'Meeting' and whose attendance exceeds 10 (via GROUP BY / HAVING), producing one row per qualifying event.",
      "reason": "The query lists each qualifying meeting instead of counting them. Question asks for the number of such events, so the required aggregation (COUNT of events) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1241,
    "result": {
      "expected_answer": "Return the difference between the number of patients whose platelet count is below 100 (low) and the number of patients whose platelet count is above 400 (high). Counting must be per patient, not per lab record.",
      "sql_description": "Counts rows with PLT < 100 and rows with PLT > 400 in the Laboratory table and subtracts the second count from the first, producing a single integer.",
      "reason": "The query counts laboratory rows, not distinct patients. Because a patient can have multiple test dates, the result can over- or under-represent patient counts, violating the explicit anchor \"number of patients.\"",
      "verdict": false
    }
  },
  {
    "question_id": 1338,
    "result": {
      "expected_answer": "For every expense associated with the event named \"October Meeting\" held on 2019-10-08, report whether it was approved (True/False) so we can tell if all of them were approved.",
      "sql_description": "Lists descriptions of expenses whose approved flag is True after joining expense to event on expense.link_to_member = event.event_id, filtered to the target event.",
      "reason": "1) Join is on unrelated columns (link_to_member ↔ event_id) so associated expenses are not found. 2) Query filters to approved='true', omitting unapproved expenses, so cannot determine if EACH expense was approved. 3) It outputs only description, not approval status. Required anchors partially present but logic is insufficient.",
      "verdict": false
    }
  },
  {
    "question_id": 1092,
    "result": {
      "expected_answer": "The name of the league that has the highest number of matches in the 2008/2009 season.",
      "sql_description": "Counts matches per league in 2008/2009 and returns the league_id with the greatest count (single integer).",
      "reason": "Question asks for league NAME, but query returns only league_id; no join to League table to fetch the name. Core anchor (league name) missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1251,
    "result": {
      "expected_answer": "The number of distinct patients whose Ig G value is 2000 or higher (above normal).",
      "sql_description": "Counts all joined rows where the laboratory Ig G is below 900 and the symptom is 'abortion', without using DISTINCT.",
      "reason": "It filters for IGG < 900 (opposite of ≥2000), adds an irrelevant symptom condition, and does not count distinct patients. Required anchor IGG >= 2000 is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1102,
    "result": {
      "expected_answer": "Name of the oldest player (earliest birthday) among those whose overall_rating was 77 on 2016-06-23.",
      "sql_description": "Joins Player and Player_Attributes, keeps rows where overall_rating = 77 and date equals exactly '2016-06-23', orders by birthday ascending, returns the first player_name.",
      "reason": "Required anchor \"date LIKE '2016-06-23%'\" is implemented as an exact equality. In the schema the date values include a time portion (e.g. '2016-06-23 00:00:00'); equality will not match them, producing an empty result. Hence the query does not retrieve the relevant players and cannot identify the oldest.",
      "verdict": false
    }
  },
  {
    "question_id": 1256,
    "result": {
      "expected_answer": "The number of patients whose laboratory record shows an abnormal C-reactive protein (CRP = '+') and whose Patient.Description field is NULL (data not recorded).",
      "sql_description": "Counts distinct patient IDs where Patient.Description IS NULL and the Laboratory.CRP value is '+' OR '-' OR < 1.0.",
      "reason": "The query relaxes the abnormal-CRP anchor: it also accepts CRP '-' and values < 1.0, which represent normal results. Therefore it over-includes patients not meeting the abnormal criterion.",
      "verdict": false
    }
  },
  {
    "question_id": 1350,
    "result": {
      "expected_answer": "The textual status value (event.status) for the event that incurred the expense \"Post Cards, Posters\" dated 2019/8/20.",
      "sql_description": "Joins expense → budget → event, filters expense_description = 'Post Cards, Posters' and expense_date = '2019-8-20', then returns the associated event.status.",
      "reason": "All required anchors—expense description, expense date, and fetching the event’s status—are present. Using event.status matches the question’s wording. Even though no row is returned in the sample execution, the query logic aligns with the question.",
      "verdict": true,
      "evidence": "Returned column: status (no rows shown in sample output, but structure matches expected answer)."
    }
  },
  {
    "question_id": 1110,
    "result": {
      "expected_answer": "The value of buildUpPlayPassingClass (e.g., Short/Mixed/Long) for team 'FC Lorient' on 2010-02-22, regardless of the time part.",
      "sql_description": "Looks up buildUpPlayPassingClass from Team_Attributes joined with Team where team_long_name is 'FC Lorient' and the date string equals exactly '2010-02-22'.",
      "reason": "Date anchor is too strict: Team_Attributes stores full timestamps like '2010-02-22 00:00:00'; the query uses exact equality to '2010-02-22', so it misses the required record (confirmed by empty result). Required anchor “date LIKE '2010-02-22%'” not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1387,
    "result": {
      "expected_answer": "Full name (first and last) of the student who is assigned to manage the Budget category for the event named \"Yearly Kickoff\".",
      "sql_description": "Attempts to list every member’s first and last name but only filters the budget rows to those whose category is 'Budget' for the event 'Yearly Kickoff'. There is no join condition linking a budget record to a specific member, so the query produces a cross-join and, in execution, returns no rows.",
      "reason": "Missing anchor: relationship between member and the budget record that designates responsibility. Without this link the query cannot determine which student manages that budget, so it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1270,
    "result": {
      "expected_answer": "A single integer: the number of distinct patients whose anti-scl70 result is normal (SC170 in ('negative','0')), whose sex is female, and whose symptoms field is NULL (i.e., no symptom).",
      "sql_description": "Counts distinct patients with sex = 'M', examination.diagnosis = 'Normal', SC170 in ('-', '+-'), and symptoms exactly equal to 'vertigo'.",
      "reason": "Violates required anchors: uses sex='M' instead of female, requires a specific diagnosis not asked, checks symptoms='vertigo' instead of IS NULL, and uses different SC170 codes. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1116,
    "result": {
      "expected_answer": "Names of player(s) whose height is the maximum in the Player table (all players tied at tallest height).",
      "sql_description": "Selects 5 player names with the greatest heights by ordering all players by height descending and limiting the result to 5 rows.",
      "reason": "Question demands only players at height rank = 1, i.e., those with the absolute maximum height. The query returns the top 5 heights, including players with lower ranks, so it violates the rank=1 anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1404,
    "result": {
      "expected_answer": "For the event named 'October Meeting', list each expense type and the total approved cost (sum of cost) for that type.",
      "sql_description": "Joins expense -> budget -> event, filters rows where event_name = 'October Meeting' and approved = 'yes', then groups by expense_description and returns SUM(cost) alongside each description.",
      "reason": "All required anchors are present: event name filter, approval status, grouping by expense type, and summing cost. Output columns match requested information.",
      "verdict": true,
      "evidence": "Query would output columns [SUM(cost), expense_description]; execution currently returns no rows, which is acceptable if no approved expenses exist."
    }
  },
  {
    "question_id": 1340,
    "result": {
      "expected_answer": "A single numeric value: total amount spent on Student_Club events in 2019 minus the total amount spent on Student_Club events in 2020.",
      "sql_description": "Joins budget with event, keeps only rows where event.type = 'Student_Club', sums budget.spent for rows whose event_date year is 2019, subtracts the sum for rows whose year is 2020, and returns that difference as one column named difference.",
      "reason": "The query applies the correct year filters (2019 vs 2020), restricts to Student_Club events, aggregates the spent amounts, and subtracts 2020 from 2019 exactly as requested. No required anchor is missing.",
      "verdict": true,
      "evidence": "Result column difference returned (row0=None) matches the requested single-value format; value depends on data."
    }
  },
  {
    "question_id": 1141,
    "result": {
      "expected_answer": "Identify the build-up play speed class (Slow, Balanced or Fast) associated with the team “KSV Cercle Brugge”; multiple historical classes are acceptable since the question gives no time frame.",
      "sql_description": "Looks up all records in Team_Attributes for the team named “KSV Cercle Brugge” and returns the column buildUpPlaySpeedClass, yielding every speed-class value stored for that team.",
      "reason": "Query correctly filters by the required team and retrieves the requested speed-class information. The result set shows the classes ‘Balanced’ and ‘Fast’; these are legitimate values for the team across its records, satisfying the question which did not demand a single, latest, or deduplicated value.",
      "verdict": true,
      "evidence": "sql_result rows: columns (team_long_name, buildUpPlaySpeedClass) include Balanced (rows 0,1,3-5) and Fast (row 2)."
    }
  },
  {
    "question_id": 1399,
    "result": {
      "expected_answer": "A yes/no confirmation of whether the member named Maya Mclean is recorded as having attended the event whose name is \"Women's Soccer\".",
      "sql_description": "Looks up a row in attendance joining member and event, filtering for member first_name='Maya', last_name='Mclean', and event_name='Women''s Soccer'. Returns the member's name if such an attendance record exists.",
      "reason": "Query checks all required anchors: the specific member (first and last name) and the specific event name. Presence of a returned row implies attendance, satisfying the yes/no question. No missing or extra constraints.",
      "verdict": true,
      "evidence": "sql_result shows one row with columns first_name, last_name => ('Maya', 'Mclean'), confirming attendance."
    }
  },
  {
    "question_id": 1359,
    "result": {
      "expected_answer": "A single numeric ratio indicating how many times the Advertisement budget for the \"Yearly Kickoff\" event exceeds that for the \"October Meeting\" event (Yearly Kickoff Advertisement amount ÷ October Meeting Advertisement amount).",
      "sql_description": "Joins budget with event, keeps only Advertisement rows, sums amount for Yearly Kickoff and divides it by the sum for October Meeting, returning the resulting ratio.",
      "reason": "All required anchors are present: filters category='Advertisement', identifies the two events by name, aggregates their amounts, and returns the division. This directly yields the requested \"how many times\" value.",
      "verdict": true,
      "evidence": "sql_result shows a single column with value 2, matching the expected ratio."
    }
  },
  {
    "question_id": 1464,
    "result": {
      "expected_answer": "First and last names of all students who had a record of funds received on 9/9/2019 together with the amount each received.",
      "sql_description": "Joins income with member on member id, filters rows where income.date_received equals '9/9/2019', and returns member.first_name, member.last_name, and income.amount.",
      "reason": "All required anchors are present: date filter 9/9/2019, linkage to student, and selection of full name and amount. Logic matches the question.",
      "verdict": true,
      "evidence": "Query returns columns [first_name, last_name, amount]; execution produced 0 rows, which is permissible if no data matches."
    }
  },
  {
    "question_id": 1147,
    "result": {
      "expected_answer": "Player name(s) whose overall_rating reaches the maximum value in Player_Attributes; any one of them satisfies the request.",
      "sql_description": "Finds the global MAX(overall_rating) in Player_Attributes, then returns every player_name whose attribute row equals that max (duplicates possible).",
      "reason": "Uses MAX(overall_rating) anchor and returns corresponding player name(s). Duplicates and multiple players are acceptable for a ‘name one’ request. Thus fulfills the requirement.",
      "verdict": true,
      "evidence": "sql_result shows player_name column rows 0-11 all 'Lionel Messi', indicating the query returned a player with the highest rating."
    }
  },
  {
    "question_id": 1422,
    "result": {
      "expected_answer": "The categories (values of the type field) of all events whose location is 'MU 215'.",
      "sql_description": "Returns the names of events (event_name column) held at MU 215.",
      "reason": "Query retrieves event_name instead of the requested category/type, so it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1435,
    "result": {
      "expected_answer": "Names of events whose type is Game, status is Closed, and event_date falls between 2019-03-15 and 2020-03-20 inclusive.",
      "sql_description": "Selects event_name from the event table where type = 'Game', status = 'Closed', and event_date is between '2019-03-15' and '2020-03-20'.",
      "reason": "All required anchors (type game, status closed, date range) are present and correctly constrained. Output column contains only event names, matching the question.",
      "verdict": true,
      "evidence": "sql_result rows: event_name -> ['Women\\'s Soccer', 'Football game', 'Football game']"
    }
  },
  {
    "question_id": 1392,
    "result": {
      "expected_answer": "Name (or name with amount) of the source that provided the highest total funds between 2019-09-01 and 2019-09-30.",
      "sql_description": "Aggregates income rows in September 2019 by source, sums their amounts, sorts by summed amount descending, and returns the first (largest) source along with its total amount.",
      "reason": "Covers correct date range, computes total per source, picks maximum; output may include amount which is acceptable.",
      "verdict": true,
      "evidence": "sql_result rows: [0] source='School Appropration', total_amount=3000"
    }
  },
  {
    "question_id": 1482,
    "result": {
      "expected_answer": "Identify, among the segments SME, LAM and KAM, which segment shows the highest and which shows the lowest percentage change in EUR-denominated consumption from 2012 to 2013. Percentage change is computed per segment as (consumption_2013 − consumption_2012)/consumption_2013 × 100 %.",
      "sql_description": "For each segment, it looks at every individual month record between 201201 and 201312 (any currency). It takes the single maximum consumption value and the single minimum consumption value among all those rows, then computes (max − min)/min × 100. It does not restrict to EUR, does not aggregate by year, and returns percentages for all segments.",
      "reason": "Missing required anchors: 1) EUR-only filter, 2) year-level aggregation (2012 vs 2013 totals or averages) — the query instead uses row-level extrema which can come from any months and customers. Formula denominator also differs from given definition. Therefore the computed percentages and the deduced biggest/lowest segment would be incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1490,
    "result": {
      "expected_answer": "Percentage of LAM customers (distinct customers in the LAM segment) who have a consumption value greater than 46.73; should be a number between 0 and 100.",
      "sql_description": "Joins yearmonth with customers, filters to LAM rows where consumption > 46.73, counts ALL matching rows, divides by total number of LAM customers, then multiplies by 100.",
      "reason": "The numerator should count distinct LAM customers, not yearmonth rows; multiple rows per customer inflate the count, producing a value (>100%) that does not represent the requested percentage of customers.",
      "verdict": false
    }
  },
  {
    "question_id": 1168,
    "result": {
      "expected_answer": "We need: (1) the date when medical laboratory work was done for the oldest patient whose diagnosis is 'SJS'; (2) that patient’s age at their initial hospital arrival (year of First Date minus year of Birthday). The patient to pick must be the oldest (earliest birthday) among all SJS patients.",
      "sql_description": "Joins Patient and Laboratory, filters to diagnosis='SJS'. It aggregates all the joined rows, taking MAX(laboratory.date) but also returns a non-aggregated age expression built from First Date and Birthday. ORDER BY birthday ASC LIMIT 1 appears after the aggregation, so it no longer restricts which patient contributes to the non-aggregated columns; they come from an arbitrary row. Therefore the query effectively returns (a) the latest lab date across ALL SJS patients and (b) an indeterminate age from an unspecified SJS patient.",
      "reason": "The ORDER BY … LIMIT is ineffective in isolating the oldest patient once aggregates are present, so the returned age is not guaranteed to belong to the oldest patient. Essential anchor “oldest SJS patient” is thus not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1479,
    "result": {
      "expected_answer": "The year (YYYY) that has the highest total gas consumption among transactions paid in CZK.",
      "sql_description": "Joins yearmonth with customers, keeps rows where currency = 'CZK', groups by the first 4 characters of Date (year), sums Consumption per year, orders the sums descending, and returns the top year with its total.",
      "reason": "All required anchors are present: currency restriction to CZK, summing consumption per year, and selecting the max. The returned year therefore answers which year recorded the most CZK-paid gas consumption.",
      "verdict": true,
      "evidence": "Row0: year=2013, total_consumption≈2.99e9"
    }
  },
  {
    "question_id": 1501,
    "result": {
      "expected_answer": "List of country names of gas stations that had at least one transaction in June 2013.",
      "sql_description": "Joins transactions_1k with gasstations and returns the Country field where the transaction's Date substring YYYYMM equals '201306' (June 2013).",
      "reason": "Correctly filters transactions to June 2013 using substr, links to gasstations, and outputs the required country field. DISTINCT is not essential as duplicates were not disallowed.",
      "verdict": true,
      "evidence": "Query returns column Country; current dataset produced 0 rows, which is acceptable if no matching records exist."
    }
  },
  {
    "question_id": 1179,
    "result": {
      "expected_answer": "The value/status of the patient’s anti-Cardiolipin antibody (aCL IgM) measured on 1993-11-12, for the patient whose record shows Diagnosis = 'SLE' and Description = '1994-02-19'.",
      "sql_description": "Fetches aCL IgM from all Examination rows linked to patients with diagnosis 'SLE' and description '1994-02-19'; it does not restrict to the examination date 1993-11-12.",
      "reason": "Required anchor Examination Date = '1993-11-12' is missing, so the query can return data from other dates. Therefore it does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1457,
    "result": {
      "expected_answer": "List each member’s full name (first_name + last_name) and phone number whenever that member has an expense whose cost is above the overall average expense cost.",
      "sql_description": "Looks at every expense row; if its cost is greater than the global average cost (computed over all expenses), it joins to the member table and outputs that member’s full name and phone.",
      "reason": "Query applies the > AVG(cost) filter exactly as the question specifies, retrieves full name and contact number through the join, and therefore satisfies the requested information. Duplicates per qualifying expense do not violate the question.",
      "verdict": true,
      "evidence": "sql_result columns: full_name, contact_number with rows such as ('Sacha Harrison', '840-555-4781'), confirming the expected output format."
    }
  },
  {
    "question_id": 1493,
    "result": {
      "expected_answer": "Share (percentage) of customers in February 2012 whose consumption exceeded 528.3, i.e. 100 * (# customers with consumption > 528.3 in 201202) / (# all customers appearing in 201202).",
      "sql_description": "Counts distinct customers with consumption > 528.3 in 201202 for numerator, and erroneously counts the same set again for denominator, then divides, always yielding 100%.",
      "reason": "Denominator should include all February-2012 customers regardless of consumption but instead repeats the >528.3 filter, so the computed percentage is incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1524,
    "result": {
      "expected_answer": "The country/nationality of the customer (from a customer-related table) who made a transaction totaling 548.4 on 2012-08-24.",
      "sql_description": "Looks for a transaction dated 2012-08-24 with Amount = 548.4, then returns the Country of the gas station involved (gasstations.country).",
      "reason": "Question asks for the customer's nationality, not the gas station's country. Query never references any customer-nationality field and instead pulls gasstations.country. It also filters on Amount (integer) rather than the likely total price. Required anchor (customer nationality) missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1505,
    "result": {
      "expected_answer": "The number of customers whose currency is 'EUR' and whose monthly consumption (in any month) is greater than 1000.",
      "sql_description": "Returns a list of CustomerID values where customers.currency equals the literal string 'euro' and the customer appears in yearmonth with consumption > 1000; does not aggregate to a count.",
      "reason": "Missing required anchor: currency value should be 'EUR' (not 'euro'); more importantly, the query returns customer IDs instead of the required count, so it does not answer \"how many\".",
      "verdict": false
    }
  },
  {
    "question_id": 1227,
    "result": {
      "expected_answer": "A single numeric value: the average age (in years) of patients who are male (SEX='M') and who have at least one laboratory record with T-CHO ≥ 250 (high cholesterol).",
      "sql_description": "Computes the year-difference age for each male patient and averages these ages, but only for patients whose ID appears in Laboratory with T-CHO ≥ 250.",
      "reason": "All required anchors are satisfied: male filter via SEX='M'; high cholesterol via subquery on Laboratory T-CHO ≥ 250; age averaged as requested. Minor approximation in age calculation (year precision) is reasonable and consistent with evidence formula. Thus SQL answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one column average_age with value 70.95 (row 0), delivering the requested average."
    }
  },
  {
    "question_id": 1529,
    "result": {
      "expected_answer": "Two numeric totals: 1) total amount (sum of Amount) spent by customer 38508 in all their gas-station transactions; 2) total amount spent by the same customer in January 2012 (Date = '201201').",
      "sql_description": "Computes a single total: SUM(Amount) for all transactions where CustomerID = 38508, without any date restriction.",
      "reason": "Returns only one of the two required figures and omits the January-2012 anchor, so the query is incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 1472,
    "result": {
      "expected_answer": "Identify the LAM-segment customer with the smallest total consumption during the calendar year 2012 (i.e., considering all their 2012 records).",
      "sql_description": "Finds all yearmonth rows whose date value lies between 201201 and 201212 and belong to LAM customers, then picks the single row with the smallest per-row Consumption; returns that row’s customerid.",
      "reason": "The query compares individual monthly rows instead of aggregating each customer’s 2012 consumption, so a customer who has one unusually low month but high total could be selected. It therefore does not reliably answer who had the least 2012 consumption.",
      "verdict": false
    }
  },
  {
    "question_id": 1514,
    "result": {
      "expected_answer": "The currency (or currencies) associated with the customer who made a payment at 16:25:00 on 2012-08-24.",
      "sql_description": "Finds the customer(s) that had a transaction dated 2012-08-24 at 16:25:00 in transactions_1k, then returns their Currency from the customers table.",
      "reason": "Matches the required date and time anchors and retrieves the corresponding currency. Duplicate rows do not violate the question intent; all returned values are CZK, answering the question.",
      "verdict": true,
      "evidence": "sql_result rows: Currency column = ['CZK', 'CZK', 'CZK'] → answer CZK."
    }
  },
  {
    "question_id": 1480,
    "result": {
      "expected_answer": "The specific month in 2013 (e.g., 201307 or \"July\") during which SME customers recorded the highest total gas consumption.",
      "sql_description": "Finds the single highest Consumption value in 2013 rows for SME customers and returns that numeric value (max_consumption). It does not identify or output the associated month.",
      "reason": "Question asks for the peak month, not the peak consumption value. Moreover, it should aggregate consumption per month before determining the peak. The query only returns a consumption amount and omits the month entirely.",
      "verdict": false
    }
  },
  {
    "question_id": 1484,
    "result": {
      "expected_answer": "An integer: (number of Discount segment gas stations in Czech Republic) minus (number of Discount segment gas stations in Slovakia).",
      "sql_description": "Counts Discount gas stations in Czech Republic, then removes the result if the same count exists for Slovakia using EXCEPT; returns the first count only when different, otherwise returns nothing.",
      "reason": "Does not compute the numerical difference; EXCEPT set subtraction gives wrong semantics and may return empty. Also uses country names instead of required codes. Required anchor of arithmetic subtraction is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1525,
    "result": {
      "expected_answer": "Percentage = (number of distinct customers who made a transaction on 2012-08-25 AND whose currency is EUR) divided by (total distinct customers who made a transaction on 2012-08-25) * 100.",
      "sql_description": "Counts all distinct customers whose currency is EUR in the whole customers table for the numerator, divides by the distinct customers who transacted on 2012-08-25 for the denominator.",
      "reason": "Missing required anchor: the numerator must be limited to customers with transactions on 2012-08-25, but the query includes every EUR customer, inflating the percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 1531,
    "result": {
      "expected_answer": "Return the customer ID (or name) of the customer whose total spending (sum of Amount*Price across all their transactions) is highest, together with: 1) the customer’s average price paid per single item, defined as SUM(Amount*Price)/SUM(Amount), and 2) the currency recorded for that customer.",
      "sql_description": "1) Finds the customer with the greatest SUM(Amount*Price) via a sub-query. 2) For that customer it returns:\n   - customers.customerid,\n   - MAX(Amount*Price) over that customer’s rows (labelled total_spending),\n   - AVG(Price/Amount) as average_price_per_item,\n   - customers.currency.",
      "reason": "Average price per item is computed incorrectly: AVG(Price/Amount) is the simple arithmetic mean of per-transaction unit prices, not the weighted mean specified (SUM(Amount*Price)/SUM(Amount)). Therefore the query does not satisfy the required definition for “average price per single item”.",
      "verdict": false
    }
  },
  {
    "question_id": 1498,
    "result": {
      "expected_answer": "A single number: the maximum value of monthly consumption recorded during 2012.",
      "sql_description": "Filters rows whose Date starts with '2012' (i.e., months in 2012) and returns the maximum Consumption among those rows.",
      "reason": "The query applies the 2012 year filter and uses MAX to obtain the highest consumption value. Interpreting each row as one month's consumption for a customer, this directly yields the highest monthly consumption in 2012. This interpretation is reasonable and not contradicted by the schema, so the query satisfies the request.",
      "verdict": true,
      "evidence": "highest_monthly_consumption column in result shows 445279.69"
    }
  },
  {
    "question_id": 1242,
    "result": {
      "expected_answer": "IDs (or other identifiers) of all patients who had any laboratory examination in the year 1984, are younger than 50 years old, and whose platelet count on that exam is within the normal 100-400 range.",
      "sql_description": "Selects patient.id from Laboratory joined to Patient where Laboratory.Date starts with '1984' (i.e., year 1984), the patient’s current age computed from birthday is under 50, and the platelet (PLT) value is between 100 and 400. Returns all matching rows (duplicates possible).",
      "reason": "All required anchors are present: year filter (1984), age < 50, PLT 100-400, and patient list. Although DISTINCT is omitted, duplicates do not conflict with the question. Therefore the query satisfies the information need.",
      "verdict": true,
      "evidence": "sql_result shows column ID with values such as 102490, 460574, 1086485, matching the requested patient identifiers."
    }
  },
  {
    "question_id": 1257,
    "result": {
      "expected_answer": "Count of distinct patients whose laboratory result includes CRE (creatinine) value >= 1.5 and whose age (current year minus birth year) is less than 70.",
      "sql_description": "Counts distinct patients with CRP value >= 1.0 and not coded '+-' or '-', and age under 18.",
      "reason": "Uses CRP column instead of CRE for abnormal creatinine anchor and applies age < 18 rather than < 70, violating both explicit constraints.",
      "verdict": false
    }
  },
  {
    "question_id": 1275,
    "result": {
      "expected_answer": "A single integer: the number of distinct male patients (Sex='M') who have at least one laboratory record where both CENTROMEA and SSB are in the normal set ('-', '+-').",
      "sql_description": "Counts Patient rows (each patient appears once) whose ID occurs in Laboratory rows with CENTROMEA and SSB normal and whose Sex is 'M'. This delivers the number of distinct male patients meeting the lab criteria.",
      "reason": "All required anchors—normal CENTROMEA, normal SSB, male sex, distinct patient count—are present. Using Patient table guarantees uniqueness, so DISTINCT is effectively satisfied. Logic matches the question.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(*) with value 0; structure matches expectation."
    }
  },
  {
    "question_id": 1526,
    "result": {
      "expected_answer": "A single numeric value representing (total consumption in 2012 – total consumption in 2013) / total consumption in 2012 for the customer whose consumption was 634.8 on 2012-08-25.",
      "sql_description": "Fetches every individual consumption amount from 2012 and every individual consumption amount from 2013, then produces a cartesian product of the two lists without filtering for the specified customer or calculating the decrease rate.",
      "reason": "Missing required anchor: the customer with consumption 634.8 on 2012-08-25 is not isolated. No aggregation to yearly totals and no decrease-rate calculation. Therefore the query does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1352,
    "result": {
      "expected_answer": "A single number: the count of club members whose major name is 'Business' and whose t_shirt_size is 'Medium'.",
      "sql_description": "Counts members whose major is 'Human Development and Family Studies' and whose t_shirt_size is 'Large'.",
      "reason": "Misses both required anchors: major must be 'Business', t_shirt_size must be 'Medium'. Therefore the query answers a different question.",
      "verdict": false
    }
  },
  {
    "question_id": 1533,
    "result": {
      "expected_answer": "For each customer who has any transaction where unit price (Price/Amount) exceeded 29.00 for product id 5, report that customer’s consumption value for August 2012.",
      "sql_description": "Finds customers with at least one purchase of product 5 at unit price >29 (no date restriction), then fetches their August-2012 consumption from yearmonth and outputs the customer segment plus the consumption figure.",
      "reason": "Query enforces product id 5 and per-unit price >29 anchors, identifies the relevant customers, and returns their August 2012 consumption. Including segment is harmless surplus. All explicit constraints are met.",
      "verdict": true,
      "evidence": "sql_result shows columns Segment and Consumption for 10 qualifying customers; Consumption values align with August 2012 filter."
    }
  },
  {
    "question_id": 1427,
    "result": {
      "expected_answer": "List of budget category values for events whose location is 'MU 215', type is 'Guest Speaker', and whose associated budget record shows spent = 0.",
      "sql_description": "Joins budget with event on event ID, filters events at location MU 215 with type 'Guest Speaker' and budget.spent = 0, then returns the category field.",
      "reason": "All explicit anchors (location MU 215, type 'Guest Speaker', spent = 0) are present and the selected column is category; therefore the query retrieves exactly the requested information.",
      "verdict": true,
      "evidence": "sql_result shows one column 'category' with multiple rows (e.g., Speaker Gifts, Food, Parking, Advertisement), consistent with expected list output."
    }
  },
  {
    "question_id": 1460,
    "result": {
      "expected_answer": "The first and last name together (full name) of the member whose expense description is exactly \"Water, Veggie tray, supplies\", along with the cost of that expense.",
      "sql_description": "Joins member with expense using member_id, filters expenses where expense_description equals 'Water, Veggie tray, supplies', and returns the concatenated first_name and last_name as full_name plus the cost.",
      "reason": "All required anchors are present: it checks the correct expense description, links to the member, and outputs full name and cost. This matches the question.",
      "verdict": true,
      "evidence": "Returned columns: full_name, cost (e.g., row 0 ⇒ Elijah Allen, 28.15)."
    }
  },
  {
    "question_id": 1473,
    "result": {
      "expected_answer": "A single numeric value representing the average monthly consumption of customers whose segment is \"SME\" during the calendar year 2013.",
      "sql_description": "Joins yearmonth with customers, keeps rows where customers.segment = 'SME' and Date between 201301 and 201312, then returns AVG(consumption/12) which is mathematically equivalent to AVG(consumption)/12.",
      "reason": "All required anchors are present: SME segment filter and 2013 period filter. The query computes the average of consumption values divided by 12, matching the stated formula for average monthly consumption. Mathematical placement of /12 inside AVG is equivalent, so result satisfies the question.",
      "verdict": true,
      "evidence": "sql_result column avg_monthly_consumption row0 = 459.956264"
    }
  },
  {
    "question_id": 1481,
    "result": {
      "expected_answer": "Three numeric values: (1) difference between SME and LAM annual-average consumptions of the customers with the lowest total CZK consumption in 2013, (2) difference between LAM and KAM, and (3) difference between KAM and SME.",
      "sql_description": "For each segment separately, it keeps 2013 CZK rows, then: • takes the minimum single row Consumption as min_consumption; • within that same segment group it tries to subtract AVG consumptions of the other segments using CASE expressions. Because the grouping filters rows to one segment, the CASEs for other segments are always NULL, so the two difference fields are NULL. It never identifies the lowest-consumption customers, never aggregates to annual totals, and produces three rows (one per segment).",
      "reason": "Missing required anchors: (a) does not first find the customer(s) with the least annual consumption per segment, (b) does not compute their annual averages, (c) differences are computed wrongly and end up NULL, (d) outputs three rows instead of three numbers. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1486,
    "result": {
      "expected_answer": "Determine whether the number of SME customers paying in CZK is greater than the number paying in EUR and, if so, give the numeric difference (CZK-payers minus EUR-payers).",
      "sql_description": "Returns two rows: (currency = 'CZK', distinct SME count) and (currency = 'EUR', distinct SME count). It does not compute the difference or state whether CZK exceeds EUR.",
      "reason": "Core anchors are present (SME segment, currencies CZK and EUR, distinct customers), but the query fails to compute or return the required yes/no conclusion and the difference. Supplying raw counts alone does not satisfy the explicit request for the comparative statement and numeric gap.",
      "verdict": false
    }
  },
  {
    "question_id": 1507,
    "result": {
      "expected_answer": "A list of unique (distinct) transaction times for transactions at gas stations belonging to chain 11.",
      "sql_description": "Retrieves every Time value from transactions_1k where the gas station’s ChainID is 11, ordered by Time, but without DISTINCT so duplicates are kept.",
      "reason": "The question asks for disparate/distinct times, but the query returns all rows and therefore includes duplicates (e.g., two 14:29:00 entries in the result). Missing the DISTINCT anchor means it does not satisfy the requirement.",
      "verdict": false
    }
  }
]