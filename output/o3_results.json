[
  {
    "question_id": 46,
    "question": "Which state special schools have the highest number of enrollees from grades 1 through 12?",
    "evidence": "State Special Schools refers to DOC = 31; Grades 1 through 12 means K-12",
    "gold_sql": "SELECT T2.School FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.DOC = 31 ORDER BY T1.`Enrollment (K-12)` DESC LIMIT 1",
    "predicted_sql": "SELECT T1.`sname`, T1.`enroll12`\n  FROM satscores AS T1\n  INNER JOIN schools AS T2\n  ON T1.`cds` = T2.`CDSCode`\n  WHERE T2.`DOC` = '31'\n  AND T2.`GSoffered` = 'K-12'\n  ORDER BY T1.`enroll12` DESC\n  LIMIT 1",
    "ex": 0,
    "score": 0.0,
    "prover_details": {
      "expected_answer": "Name(s) of the state special school(s) (DOC = 31) that have the largest Enroll12 value – i.e., the highest number of students enrolled in grades 1-12.",
      "sql_description": "Joins satscores with schools, keeps rows where schools.DOC = 31 and GSoffered = 'K-12', orders by satscores.enroll12 descending, and returns the top row (school name and its enroll12).",
      "reason": "Query applies required DOC=31 filter, uses enroll12 (grades 1-12 enrollment) to rank, and returns the top school, satisfying the request for the state special school with the highest enrollment. Singular return is acceptable for “highest.”",
      "verdict": true,
      "evidence": "sql_result shows row 0 with columns sname='California School for the Deaf-Riverside', enroll12=71 – the top enrollment among filtered schools."
    },
    "refuter_details": {
      "judgement": "Predicted query only considers schools present in SAT scores, using enroll12 which yields California School for the Deaf-Riverside, but full K-12 enrollment data (FRPM) shows California School for the Deaf-Fremont has the highest enrollment; prediction therefore answers incorrectly.",
      "verdict": true,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 340,
    "question": "Which are the cards that have incredibly powerful foils.",
    "evidence": "incredibly poweful foils refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
    "gold_sql": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
    "predicted_sql": "SELECT `name`\n  FROM cards\n  WHERE `cardKingdomFoilId` IS NOT NULL\n  AND `cardKingdomId` IS NOT NULL",
    "ex": 0,
    "score": 0.0
  },
  {
    "question_id": 459,
    "question": "Which card costs more converted mana, \"Serra Angel\" or \"Shrine Keeper\"?",
    "evidence": "\"Serra Angel\" refers to name = 'Serra Angel'; \"Shrine Keeper\" refers to name = 'Shrine Keeper'; card costs more converted mana when the value of convertedManaCost is greater",
    "gold_sql": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1",
    "predicted_sql": "SELECT \n  CASE \n    WHEN (SELECT `convertedManaCost` FROM cards WHERE `name` = 'Serra Angel') > \n         (SELECT `convertedManaCost` FROM cards WHERE `name` = 'Shrine Keeper') \n    THEN 'Serra Angel' \n    ELSE 'Shrine Keeper' \n  END AS more_expensive_card",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Prediction returns the higher-cost card among the two just like the gold; any tie-handling or scalar-subquery concerns are theoretical and not an explicit requirement.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 465,
    "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
    "evidence": "set of cards with \"Ancestor''s Chosen\" in it refers to name = 'Ancestor''s Chosen'; Korean version refers to language = 'Korean'",
    "gold_sql": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
    "predicted_sql": "SELECT CASE WHEN COUNT(*) > 0 THEN 'Yes' ELSE 'No' END AS has_korean_version\n  FROM foreign_data\n  WHERE `uuid` = (\n    SELECT `uuid`\n    FROM cards\n    WHERE `name` = 'Ancestor''s Chosen'\n  )\n  AND `language` = 'Korean'",
    "ex": 0,
    "score": 0.0,
    "prover_details": {
      "expected_answer": "A yes/no indication of whether any Korean-language printing exists for the card named \"Ancestor's Chosen\".",
      "sql_description": "Looks up the uuid of the card whose name is 'Ancestor''s Chosen', checks foreign_data for rows with that uuid and language='Korean', and returns 'Yes' if at least one exists, otherwise 'No'.",
      "reason": "The query directly tests for the presence of a Korean-language entry tied to the card’s uuid; this satisfies the question’s requirement.",
      "verdict": true,
      "evidence": "has_korean_version column returns 'No' (row 0), so the query produced the requested yes/no answer."
    },
    "refuter_details": {
      "judgement": "Prediction checks Korean translation of the card itself, while the question (and gold) target the set containing that card; key anchor (“set”) is missed, leading to the wrong answer.",
      "verdict": true,
      "ambiguity": "ambiguous question",
      "gold_correct": true
    }
  },
  {
    "question_id": 544,
    "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
    "evidence": "\"Examples for teaching: Correlation does not mean causation\" is the Title of post; user who last edited refers to LastEditorUserId",
    "gold_sql": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'",
    "predicted_sql": "SELECT T2.`DisplayName`\n  FROM posts AS T1\n  INNER JOIN users AS T2\n  ON T1.`LastEditorUserId` = T2.`Id`\n  WHERE T1.`Title` = 'Examples for teaching: Correlation does not mean causation'\n  AND T1.`LastEditorUserId` IS NOT NULL",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Prediction matches intent; extra IS NOT NULL predicate is benign.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 637,
    "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
    "evidence": "used by Mark Meckes refers to DisplayName = 'Mark Meckes'; Doen't have comments refers to CommentCount = 0;",
    "gold_sql": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
    "predicted_sql": "SELECT DISTINCT T2.`TagName`\n  FROM posts AS T1\n  INNER JOIN tags AS T2\n  ON T1.`Tags` LIKE '%<' || T2.`TagName` || '>%'\n  WHERE T1.`OwnerUserId` = (\n    SELECT `Id`\n    FROM users\n    WHERE `DisplayName` = 'Mark Meckes'\n  )\n  AND T1.`CommentCount` = 0",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "All tag names appearing in posts authored by the user whose DisplayName is 'Mark Meckes' where those posts have CommentCount equal to 0.",
      "sql_description": "Find the Id of the user 'Mark Meckes'; from posts with that OwnerUserId and CommentCount = 0, pattern-match each post’s <Tags> field against the tags table, and return distinct matching TagName values.",
      "reason": "The query applies both explicit anchors: owner = Mark Meckes and CommentCount = 0, then extracts every distinct tag attached to such posts. That directly answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column TagName = 'books', demonstrating the query outputs tag names as required."
    },
    "refuter_details": {
      "judgement": "Prediction lists the distinct tag names (e.g., \"books\") for Mark Meckes’s zero-comment posts, matching the question; differences are only formatting/duplication vs. gold.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 785,
    "question": "Describe the names of neutral alignment superheroes.",
    "evidence": "names of superheroes refers to superhero_name; neutral alignment refers to alignment = 'Neutral';",
    "gold_sql": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'",
    "predicted_sql": "SELECT T1.`superhero_name`\n  FROM superhero AS T1\n  INNER JOIN alignment AS T2\n  ON T1.`alignment_id` = T2.`id`\n  WHERE T2.`alignment` = 'Neutral'",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Predicted SQL correctly lists superhero_name for Neutral alignment superheroes.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 937,
    "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
    "evidence": "finish time refers to time; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
    "gold_sql": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
    "predicted_sql": "SELECT `time`\n  FROM results\n  WHERE `raceId` = (\n    SELECT `raceId`\n    FROM races\n    WHERE `year` = 2008 AND `name` = 'Chinese Grand Prix'\n  )\n  AND `position` = 2",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "The finishing time (time field) for the driver who came 2nd in the 2008 Chinese Grand Prix.",
      "sql_description": "Gets raceId for the 2008 race named 'Chinese Grand Prix', then returns the time value from results where that raceId matches and position = 2.",
      "reason": "Question anchors: year 2008, race name 'Chinese Grand Prix', finishing position 2. Query applies all anchors and returns the requested time.",
      "verdict": true,
      "evidence": "sql_result row0 time = '+14.925'"
    },
    "refuter_details": {
      "judgement": "Prediction uses position=2 to get second-place finisher’s time (+14.925), matching normal interpretation of “ranked second”; gold uses rank=2 (fast-lap rank), giving a different driver, so gold is likely wrong.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": false
    }
  },
  {
    "question_id": 1044,
    "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
    "evidence": "players with a birthyear of 1970 and a birthmonth of October refers to substr(birthday,1,7) AS 'year-month',WHERE year = '1970' AND month = '10';",
    "gold_sql": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
    "predicted_sql": "SELECT `player_name`\n  FROM Player\n  WHERE strftime('%Y', `birthday`) = '1970'\n  AND strftime('%m', `birthday`) = '10'\n  AND `player_name` IS NOT NULL",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Prediction equivalent; extra NOT NULL is benign and satisfies the query requirements.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 1239,
    "question": "Name the ID and age of patient with two or more laboratory examinations which show their hematoclit level exceeded the normal range.",
    "evidence": "age = SUBTRACT(year(current_timestamp), year(Birthday)); patient with two or more laboratory examinations refers to COUNT(ID) > 2; hematoclit level exceeded the normal range refers to HCT > = 52;",
    "gold_sql": "SELECT DISTINCT T1.ID, STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.ID IN ( SELECT ID FROM Laboratory WHERE HCT >= 52 GROUP BY ID HAVING COUNT(ID) >= 2 )",
    "predicted_sql": "SELECT T1.`ID`, (strftime('%Y', 'now') - strftime('%Y', T2.`Birthday`)) as age\n  FROM (\n    SELECT `ID`, COUNT(*) as exam_count\n    FROM Laboratory\n    WHERE `HCT` >= 52\n    GROUP BY `ID`\n    HAVING COUNT(*) >= 2\n  ) AS T1\n  INNER JOIN Patient AS T2\n  ON T1.`ID` = T2.`ID`\n  WHERE T2.`Birthday` IS NOT NULL",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Predicted query meets the requirement; additional NOT NULL check on Birthday is benign and still returns correct patients and ages.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 1243,
    "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
    "evidence": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; ",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN T2.PT >= 14 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
    "predicted_sql": "SELECT \n  (COUNT(CASE WHEN T2.`SEX` = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\n  FROM Laboratory AS T1\n  INNER JOIN Patient AS T2\n  ON T1.`ID` = T2.`ID`\n  WHERE T2.`Birthday` IS NOT NULL\n  AND (strftime('%Y', 'now') - strftime('%Y', T2.`Birthday`)) > 55\n  AND T1.`PT` >= 14",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "A single numeric value: the percentage of females among patients older than 55 whose prothrombin time (PT) is at least 14.",
      "sql_description": "Joins Laboratory with Patient, filters to records where age (current year − birth year) > 55 and PT ≥ 14, then divides the number of those records with SEX = 'F' by the total number of such records and multiplies by 100 to yield a percentage.",
      "reason": "The query enforces all explicit anchors (age > 55, PT ≥14, SEX='F') and returns the requested female-percentage; counting laboratory rows instead of distinct patients is a reasonable interpretation given the evidence formula that uses plain SUM/COUNT without DISTINCT.",
      "verdict": true,
      "evidence": "sql_result shows column \"percentage\" with value 78.362573 (row 0), matching the requested output format."
    },
    "refuter_details": {
      "judgement": "Pred query restricts denominator to abnormal PT per spec, while gold counts all lab rows, yielding an incorrect tiny percentage; prediction is semantically correct.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": false
    }
  },
  {
    "question_id": 1275,
    "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
    "evidence": "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;",
    "gold_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
    "predicted_sql": "SELECT COUNT(DISTINCT T1.`ID`)\n  FROM Patient AS T1\n  INNER JOIN Laboratory AS T2\n  ON T1.`ID` = T2.`ID`\n  WHERE T2.`CENTROMEA` IN ('-', '+-')\n  AND T2.`SSB` IN ('-', '+-')\n  AND T1.`SEX` = 'M'",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "A single integer: the number of distinct male patients whose anti-centromere (CENTROMEA) and anti-SSB (SSB) test values are within the normal range ('-' or '+-').",
      "sql_description": "Counts DISTINCT patient IDs after joining Patient and Laboratory where SEX = 'M' and both CENTROMEA and SSB are '-' or '+-'.",
      "reason": "All required anchors are present: male filter (SEX='M'), normal level filters for CENTROMEA and SSB, and DISTINCT on patient IDs. Thus the query directly answers the question.",
      "verdict": true,
      "evidence": "Result set shows column COUNT(DISTINCT T1.ID) with value 0 (row 0), giving the requested count."
    },
    "refuter_details": {
      "judgement": "Predicted query follows the evidence-defined normal markers ('-','+-') and counts distinct male patients, matching the question; gold uses different marker values, so gold appears wrong.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": false
    }
  },
  {
    "question_id": 1356,
    "question": "Which department was the President of the club in?",
    "evidence": "'President' is a position of Student Club",
    "gold_sql": "SELECT T2.department FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'President'",
    "predicted_sql": "SELECT T2.`department`\n  FROM member AS T1\n  INNER JOIN major AS T2\n  ON T1.`link_to_major` = T2.`major_id`\n  WHERE T1.`position` = 'President'",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Prediction answers the question correctly; matches gold logic and constraints.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 1361,
    "question": "What is the total cost of the pizzas for all the events?",
    "evidence": "total cost of the pizzas refers to SUM(cost) where expense_description = 'Pizza'",
    "gold_sql": "SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza'",
    "predicted_sql": "SELECT SUM(`cost`) AS total_pizza_cost\n  FROM expense\n  WHERE `expense_description` = 'Pizza'",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Prediction correctly sums pizza expenses, matching question and gold.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 1376,
    "question": "Among all the closed events, which event has the highest spend-to-budget ratio?",
    "evidence": "closed events refers to event_name where status = 'Closed'; highest spend-to budget ratio refers to MAX(DIVIDE(spent, amount))",
    "gold_sql": "SELECT T2.event_name FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.status = 'Closed' ORDER BY T1.spent / T1.amount DESC LIMIT 1",
    "predicted_sql": "SELECT T1.`event_name`\n  FROM event AS T1\n  INNER JOIN budget AS T2\n  ON T1.`event_id` = T2.`link_to_event`\n  WHERE T1.`status` = 'Closed'\n  AND T2.`amount` > 0\n  ORDER BY (T2.`spent` / T2.`amount`) DESC\n  LIMIT 1",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Predicted query matches intent; extra amount>0 safeguard doesn’t violate requirements.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 1389,
    "question": "Which event has the lowest cost?",
    "evidence": "event refers to event_name; lowest cost means MIN(cost)",
    "gold_sql": "SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event INNER JOIN expense AS T3 ON T2.budget_id = T3.link_to_budget ORDER BY T3.cost LIMIT 1",
    "predicted_sql": "SELECT T1.`event_name`\n  FROM event AS T1\n  INNER JOIN budget AS T2\n  ON T1.`event_id` = T2.`link_to_event`\n  INNER JOIN expense AS T3\n  ON T2.`budget_id` = T3.`link_to_budget`\n  WHERE T3.`cost` = (\n    SELECT MIN(`cost`)\n    FROM expense\n  )",
    "ex": 1,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "Name(s) of the event(s) whose expense cost is the absolute minimum among all expenses.",
      "sql_description": "Finds the global minimum cost in the expense table and returns the event_name for every event whose linked expense has that exact minimum cost.",
      "reason": "The question defines lowest cost as MIN(cost). The query computes that minimum and returns the corresponding event_name(s). Result therefore satisfies the requirement; multiple names are acceptable if several events share the same minimum cost.",
      "verdict": true,
      "evidence": "sql_result shows column event_name with three rows (e.g., 'November Speaker', 'October Speaker', 'September Speaker') – all tied at the minimum cost."
    },
    "refuter_details": {
      "judgement": "Predicted query lists every event whose expense equals the minimum cost, satisfying the request for the event(s) with the lowest cost; extra rows only reflect ties, so prediction is acceptable.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 1426,
    "question": "List the last name of members with a major in environmental engineering and include its department and college name.",
    "evidence": "'Environmental Engineering' is the major_name;",
    "gold_sql": "SELECT T2.last_name, T1.department, T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Member' AND T1.major_name = 'Environmental Engineering'",
    "predicted_sql": "SELECT T1.`last_name`, T2.`department`, T2.`college`\n  FROM member AS T1\n  INNER JOIN major AS T2\n  ON T1.`link_to_major` = T2.`major_id`\n  WHERE T2.`major_name` = 'Environmental Engineering'",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Predicted query satisfies question; gold adds debatable extra filter on position.",
      "verdict": false,
      "ambiguity": "ambiguous question",
      "gold_correct": true
    }
  },
  {
    "question_id": 1493,
    "question": "In February 2012, what percentage of customers consumed more than 528.3?",
    "evidence": "February 2012 refers to '201202' in yearmonth.date; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month.",
    "gold_sql": "SELECT CAST(SUM(IIF(Consumption > 528.3, 1, 0)) AS FLOAT) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date = '201202'",
    "predicted_sql": "SELECT \n    (COUNT(DISTINCT CASE WHEN `Consumption` > 528.3 THEN `CustomerID` END) * 100.0 / \n    COUNT(DISTINCT `CustomerID`)) AS Percentage\nFROM yearmonth\nWHERE `Date` LIKE '201202%'",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Predicted query answers the asked percentage of customers in Feb-2012 correctly; differences (LIKE vs =, DISTINCT use) are allowable or even preferable, so no grounds to overturn.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 1501,
    "question": "Please list the countries of the gas stations with transactions taken place in June, 2013.",
    "evidence": "June 2013 refers to '201306'; The first 4 strings of the Date values in the yearmonth table can represent year; The 5th and 6th string of the date can refer to month;",
    "gold_sql": "SELECT DISTINCT T2.Country FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Date = '201306'",
    "predicted_sql": "SELECT DISTINCT g.`Country`\nFROM yearmonth ym\nJOIN transactions_1k t ON ym.`CustomerID` = t.`CustomerID`\nJOIN gasstations g ON t.`GasStationID` = g.`GasStationID`\nWHERE SUBSTR(ym.`Date`, 1, 4) = '2013' \n  AND SUBSTR(ym.`Date`, 5, 2) = '06'",
    "ex": 1,
    "score": 1.0,
    "refuter_details": {
      "judgement": "Predicted query filters the same June-2013 customer set and returns the same gas-station countries as the gold; logic satisfies the question.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 1505,
    "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
    "evidence": "Pays in euro = Currency = 'EUR'.",
    "gold_sql": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
    "predicted_sql": "SELECT COUNT(DISTINCT T1.`CustomerID`)\n  FROM customers AS T1\n  INNER JOIN yearmonth AS T2\n  ON T1.`CustomerID` = T2.`CustomerID`\n  WHERE T1.`Currency` = 'EUR'\n  AND T2.`Consumption` > 1000",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "A single integer: the number of customers whose currency is EUR and whose monthly consumption exceeds 1000.",
      "sql_description": "Joins customers with yearmonth, filters customers with currency='EUR' and at least one month where Consumption > 1000, counts distinct CustomerIDs.",
      "reason": "Satisfies both anchors—EUR customers and monthly consumption >1000—by counting distinct customers meeting those criteria. No conflicting constraints.",
      "verdict": true,
      "evidence": "Result set contains COUNT(DISTINCT T1.CustomerID)=391."
    },
    "refuter_details": {
      "judgement": "Prediction counts distinct euro-paying customers with any month >1000, matching question’s \"how many customers\" wording; gold over-counts monthly rows, so prediction is correct.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": false
    }
  }
]