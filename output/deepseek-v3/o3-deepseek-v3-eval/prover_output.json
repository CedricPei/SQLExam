[
  {
    "question_id": 1479,
    "result": {
      "expected_answer": "The specific year with the greatest total gas consumption among customers whose payments were in CZK (optionally, the total amount).",
      "sql_description": "Groups yearmonth records by the first four characters of Date (interpreted as year), joins to customers, keeps only those with Currency='CZK', sums Consumption per year, orders by that sum descending, and returns the top year (plus its total).",
      "reason": "All required anchors are satisfied: uses CZK currency filter, aggregates consumption by year, selects the maximal year. Extra column (total_consumption) is acceptable. Result hence answers the question.",
      "verdict": true,
      "evidence": "Row-0: year=2013, total_consumption≈2.99e9"
    }
  },
  {
    "question_id": 1471,
    "result": {
      "expected_answer": "A numeric ratio obtained by dividing the number of customers whose Currency is 'EUR' by the number of customers whose Currency is 'CZK'. (No extra scaling.)",
      "sql_description": "Counts distinct customers with EUR currency and distinct customers with CZK currency, divides the two counts, then multiplies the result by 100 to return a percentage-like value.",
      "reason": "The query applies an additional factor of 100 that is not part of the required ratio (evidence explicitly defines ratio as count(EUR)/count(CZK)). Therefore the returned value is 100× larger than the correct ratio.",
      "verdict": false
    }
  },
  {
    "question_id": 1482,
    "result": {
      "expected_answer": "Identify among the three segments (SME, LAM, KAM) those with the highest and with the lowest percentage increase in consumption that was paid in EUR from 2012 to 2013, using percentage change = (2013-2012)/2013 *100.",
      "sql_description": "Computes 2012 and 2013 total consumption for each segment for all currencies, calculates percentage change as (2013-2012)/2012, then returns only the single segment with the largest percentage increase.",
      "reason": "Missing required anchors: 1) restrict to EUR payments; 2) denominator should be 2013 consumption per given formula but uses 2012; 3) question asks for both biggest and lowest segments but query returns only the biggest. Therefore it does not satisfy the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1472,
    "result": {
      "expected_answer": "Identify the customer within the LAM segment whose TOTAL consumption across all months of 2012 is the smallest; return that customer’s ID (or name).",
      "sql_description": "Finds the single row in 2012 for LAM where the monthly Consumption value is minimum and returns the corresponding CustomerID, without aggregating multiple months per customer.",
      "reason": "Question implies comparison of customers’ overall 2012 consumption, requiring aggregation per customer over the year. The SQL only looks at individual month rows, so a customer with one unusually low month could be selected even if their annual total is not the lowest. Missing yearly aggregation anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1481,
    "result": {
      "expected_answer": "Three numerical differences: (1) SME annual average consumption of the lowest-consuming CZK customers in 2013 minus the same figure for LAM, (2) LAM minus KAM, and (3) KAM minus SME. Annual average for a segment = (total 2013 consumption of its lowest-consuming customer(s)) ÷ (number of such customer(s)).",
      "sql_description": "Step1: per segment, finds the smallest single row (month) consumption value in 2013 (MIN on yearmonth.Consumption). Step2: keeps only rows whose individual monthly consumption equals that minimum; sums those row values and divides by count of distinct customers to get an ‘average’. Finally returns SME-LAM, LAM-KAM, KAM-SME differences.",
      "reason": "The query bases the minimum on a single month value, not on customers’ total annual consumption, and it sums only the rows whose monthly consumption equals that minimum, not each customer’s full-year total. Therefore it does not compute the required annual averages for the lowest-consuming customers and the resulting differences are incorrect. Missing anchor: annual (per-customer yearly total) calculation.",
      "verdict": false
    }
  },
  {
    "question_id": 1498,
    "result": {
      "expected_answer": "The numeric value of the greatest Consumption recorded among all rows dated in 2012 (interpreting each row as a month’s consumption).",
      "sql_description": "Filters yearmonth rows whose Date starts with 2012 and returns MAX(Consumption) over those rows.",
      "reason": "Question asks for the highest monthly consumption in 2012. Interpreting each row as a monthly record, the query correctly filters the year and takes the maximum. Though the table also has CustomerID, the wording does not insist on aggregating over customers, so this row-level interpretation is reasonable and meets all explicit anchors.",
      "verdict": true,
      "evidence": "sql_result shows a single column HighestMonthlyConsumption with value 445279.69 (row 0)."
    }
  },
  {
    "question_id": 1484,
    "result": {
      "expected_answer": "An integer representing the number of additional gas stations in the discount segment that are located in the Czech Republic (Country='CZE') compared to Slovakia (Country='SVK'); computed as count_CZE_discount minus count_SVK_discount.",
      "sql_description": "Counts discount-segment stations in Czech Republic, counts those in Slovakia, subtracts the latter from the former, and returns the difference as 'difference'.",
      "reason": "Query applies required Country filters ('CZE', 'SVK') and Segment='discount', then returns the requested difference. All anchors are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows column difference with value 0, matching the computed metric."
    }
  },
  {
    "question_id": 1501,
    "result": {
      "expected_answer": "Distinct country names of gas stations that had at least one transaction in June 2013 (based on transaction date).",
      "sql_description": "Joins gasstations with transactions_1k on GasStationID, filters transactions where the first four characters of Date are '2013' and characters 5-6 are '06' (June), then returns DISTINCT g.Country.",
      "reason": "All required anchors are present: it filters for June 2013 transactions and retrieves the corresponding gas station countries. No extra or missing constraints.",
      "verdict": true,
      "evidence": "Query returns column Country; dataset happens to yield 0 rows, but logic aligns with question."
    }
  },
  {
    "question_id": 1490,
    "result": {
      "expected_answer": "Percentage (0–100) representing what fraction of customers in the LAM segment have any consumption value greater than 46.73.",
      "sql_description": "Counts distinct LAM customers with consumption > 46.73, divides by total distinct LAM customers, multiplies by 100 to return the percentage.",
      "reason": "All required anchors are present: filters to Segment='LAM', uses >46.73 condition, counts distinct customers for numerator and denominator. Calculation matches the specified formula, so the SQL answers the question.",
      "verdict": true,
      "evidence": "Result set includes column percentage with value 99.529216 (row 0)."
    }
  },
  {
    "question_id": 1500,
    "result": {
      "expected_answer": "A list (distinct) of descriptions of products that appear in transactions dated September 2013 (i.e., dates whose year is 2013 and month is 09).",
      "sql_description": "Joins products with transactions_1k, keeps rows where substr(Date,1,4)='2013' and substr(Date,6,2)='09', then returns the grouped product descriptions.",
      "reason": "The month filter is mis-indexed. Evidence says month is in characters 5-6 of the Date string (YYYYMM...), so it should use substr(Date,5,2)='09'. Using position 6 picks characters 6-7, which will not equal '09' for the expected format, eliminating valid rows (as seen by the empty result). Required anchor (September 2013) is therefore not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1528,
    "result": {
      "expected_answer": "The percentage share (0–100%) of gas stations in Slovakia (Country='SVK') that belong to the 'premium' segment, relative to all Slovak gas stations.",
      "sql_description": "Counts distinct gas stations in SVK whose Segment='premium' and divides by the total number of distinct gas stations in SVK, returning the result as a percentage.",
      "reason": "Query applies the correct country filter, identifies premium stations, measures them against the full Slovak set, and outputs a percentage. This fulfills the question’s requirement.",
      "verdict": true,
      "evidence": "Result row: percentage_premium = 0.0 (column name percentage_premium, row 0)"
    }
  },
  {
    "question_id": 1506,
    "result": {
      "expected_answer": "All product descriptions associated with transactions that occurred at gas stations whose Country value is 'CZE' (Czech Republic).",
      "sql_description": "Joins transactions_1k with gasstations to keep only rows where gasstations.Country = 'CZE', then joins to products and returns the Description field for each matching transaction.",
      "reason": "Query applies the required Czech Republic anchor via gasstations.Country = 'CZE' and outputs the product descriptions linked to those transactions. No additional constraints are missing; duplicates are acceptable as the question did not demand uniqueness.",
      "verdict": true,
      "evidence": "Result example shows single column Description with rows such as 'Nafta', 'Natural', confirming product descriptions are returned."
    }
  },
  {
    "question_id": 1483,
    "result": {
      "expected_answer": "The total monetary consumption (sum of Amount × Price) for customer 6 during the months August, September, October and November of year 2013.",
      "sql_description": "Filters transactions_1k to rows where CustomerID = 6, year portion of Date is 2013, and month portion (characters 6–7) is between 08 and 11, then sums Amount*Price as total_consumption.",
      "reason": "Query applies correct customer filter and the specified date range, interprets consumption as Amount*Price, and aggregates the sum, matching the question’s requirements. Month extraction via substr(Date,6,2) is appropriate for ISO date strings (YYYY-MM-DD) commonly used in this schema.",
      "verdict": true,
      "evidence": "sql_result shows one column (total_consumption) with NULL, indicating no matching transactions; query logic is still correct."
    }
  },
  {
    "question_id": 1526,
    "result": {
      "expected_answer": "The percentage decrease in total consumption for the (single) customer who made a 634.8-priced purchase on 2012-08-25, computed as (total 2012 consumption − total 2013 consumption) ÷ total 2012 consumption.",
      "sql_description": "1) Finds every CustomerID with a transaction priced 634.8 on 2012-08-25. 2) Pulls every 2012 month record for those customers as separate rows (no aggregation) and labels each Consumption value as consumption_2012. 3) Pulls every 2013 month record likewise as consumption_2013. 4) Computes (c12 − c13)/c12 for the Cartesian product of all 2012 and 2013 rows, producing many rates.",
      "reason": "Required anchors: aggregate each customer’s 2012 and 2013 consumption before computing the decrease. Query uses raw monthly rows and forms a Cartesian product, giving dozens of incorrect rates rather than the single desired figure. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1529,
    "result": {
      "expected_answer": "Two numbers: (1) total money spent by customer 38508 at gas stations across all available transactions, and (2) the subset of that spending that occurred in January 2012 (Date = '201201').",
      "sql_description": "Sums Price*Amount for all transactions of customer 38508 that match a gas station record; also produces a conditional sum restricted to rows whose Date is '201201'. Returns both sums in one row.",
      "reason": "Correct customer filter, correct gas-station restriction via join, and correct January-2012 filter using the provided date code. Produces exactly the two requested spending figures.",
      "verdict": true,
      "evidence": "Result row has columns total_spent_at_gas_stations=88612.38 and january_2012_spent=0."
    }
  },
  {
    "question_id": 1505,
    "result": {
      "expected_answer": "A single numeric value: the number of distinct customers whose currency is EUR and whose monthly consumption exceeds 1000 in at least one month.",
      "sql_description": "Joins customers with their monthly records, filters for customers with Currency='EUR' and Consumption>1000, counts distinct CustomerID.",
      "reason": "Captures both required anchors (EUR currency and monthly consumption >1000) and counts distinct customers, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT c.CustomerID) with value 391."
    }
  },
  {
    "question_id": 1359,
    "result": {
      "expected_answer": "A numeric ratio (possibly fractional) equal to SUM(amount) for 'Yearly Kickoff' in Advertisement divided by SUM(amount) for 'October Meeting' in Advertisement – i.e., how many times larger the former budget is than the latter.",
      "sql_description": "Computes the two aggregate sums, then returns COUNT(*) filtered by yearly_kickoff_amount > october_meeting_amount, yielding 1 if the first sum exceeds the second, else 0.",
      "reason": "The query does not perform the required division to produce the \"times larger\" ratio; it merely outputs a binary 1/0 indicator. Thus it fails the core requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 1350,
    "result": {
      "expected_answer": "Return the status (event_status column) of the event whose expense record has expense_description = 'Post Cards, Posters' and expense_date = '2019-8-20'.",
      "sql_description": "Joins event → budget → expense, filters expense by description/date, returns the status column from event table.",
      "reason": "Question/evidence explicitly anchors status to event_status column, but query returns event.status. Required anchor violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1524,
    "result": {
      "expected_answer": "Return the nationality (as stored in the customers table) of the customer whose transaction amount was 548.4 on 2012-08-24.",
      "sql_description": "Joins transactions_1k with customers, filters rows where the transaction Price equals 548.4 and Date equals '2012-08-24', then returns the customer’s Currency column labelled as nationality (first row only).",
      "reason": "The query enforces both stated anchors: amount 548.4 (interpreted as the stored Price value) and date 2012-08-24, links the transaction to the customer, and outputs the requested nationality. Currency is the only column that can reasonably represent nationality in this schema, so the mapping is acceptable. LIMIT 1 is harmless for a singular-expectation question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column nationality = 'CZK'."
    }
  },
  {
    "question_id": 1399,
    "result": {
      "expected_answer": "Yes or No confirmation of whether a member whose first name is Maya and last name is Mclean appears in the attendance records for the event named 'Women's Soccer'.",
      "sql_description": "Checks attendance records by joining member, attendance, and event tables; returns a row (value 1) only if a member named Maya Mclean is linked to an event whose name is exactly 'Women's Soccer'.",
      "reason": "Query enforces all required anchors: member full name and exact event name. Presence of a resulting row indicates attendance, satisfying the yes/no question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column value 1, confirming Maya Mclean attended the specified event."
    }
  },
  {
    "question_id": 1525,
    "result": {
      "expected_answer": "A single numeric value: the percentage of all customers who made a transaction on 2012-08-25 whose currency is EUR (i.e., EUR-using customers ÷ all customers with a 2012-08-25 transaction).",
      "sql_description": "Counts distinct customers with a 2012-08-25 transaction AND currency EUR, then divides by the total number of customers whose currency is EUR (whether or not they transacted that day).",
      "reason": "Denominator should be customers active on 2012-08-25, not all EUR customers. The query therefore computes a different ratio and violates the required base set anchor (all 2012-08-25 customers).",
      "verdict": false
    }
  },
  {
    "question_id": 1531,
    "result": {
      "expected_answer": "The customer who spent the most money overall (highest sum of transaction total prices) together with: 1) that total spending amount, 2) the customer’s average price per single item (total spending divided by total quantity purchased), and 3) the currency used.",
      "sql_description": "Finds per-customer SUM(Price) as \"total_spending\", picks the customer with the largest SUM(Price), then for this customer divides SUM(Price) by SUM(Amount) to give an average price, and returns the customer id, the SUM(Price), the computed average, and the customer’s currency.",
      "reason": "“Top spending” requires summing the actual money spent, i.e. Price * Amount (unit price × quantity). The query sums only Price, ignoring Amount, so both the ranking of customers and the reported spending amount are incorrect. Consequently it may choose the wrong customer and wrong figures, violating the key anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1389,
    "result": {
      "expected_answer": "Name of the event that incurred the minimum cost (i.e., the smallest monetary value recorded for an event).",
      "sql_description": "Joins event with budget, orders rows by the spent amount ascending, and returns the event_name of the first row (smallest spent).",
      "reason": "Interprets “cost” as the ‘spent’ value of a single budget entry attached to an event; picks the minimum and returns its event name. This is a reasonable mapping because the schema has no explicit ‘cost’ column, and ‘spent’ is the only monetary figure. All required anchors (event linkage, lowest value) are present.",
      "verdict": true,
      "evidence": "sql_result shows one column event_name with one row ('February Speaker'), which is the event having the minimum spent value according to the query."
    }
  },
  {
    "question_id": 1422,
    "result": {
      "expected_answer": "A list of unique event categories (values from event.type) for events whose location is MU 215.",
      "sql_description": "Selects DISTINCT type from the event table where location equals 'MU 215', thus listing each category of event held in that room.",
      "reason": "The query filters on the required anchor (location='MU 215') and returns the event category (type). DISTINCT avoids duplicates, matching the request for the categories of events held there.",
      "verdict": true,
      "evidence": "sql_result rows: [(0, 'Meeting'), (1, 'Election'), (2, 'Guest Speaker')] showing three unique categories."
    }
  },
  {
    "question_id": 1411,
    "result": {
      "expected_answer": "List the categories/descriptions of all expenses incurred by member Sacha Harrison (i.e., the expense_description values for that person).",
      "sql_description": "Retrieves distinct expense_description from expense records linked to the member whose first_name = 'Sacha' and last_name = 'Harrison'.",
      "reason": "Query correctly anchors on the member’s full name and returns the requested expense_description values; no missing or extra constraints.",
      "verdict": true,
      "evidence": "sql_result includes column expense_description with 7 distinct rows such as 'Post Cards, Posters', 'Pizza', etc."
    }
  },
  {
    "question_id": 1338,
    "result": {
      "expected_answer": "For every expense tied to the event named \"October Meeting\" that occurred on 2019-10-08, indicate whether it was approved (True/False), typically as a list of expense descriptions with their approval status.",
      "sql_description": "Finds all expenses whose budgets are linked to an event named \"October Meeting\" on 2019-10-08 and returns each expense's description together with its approved flag.",
      "reason": "The query correctly navigates event → budget → expense, applies the required event name and date filters, and outputs approval status per expense, directly addressing the question.",
      "verdict": true,
      "evidence": "Returned columns: expense_description, approved (0 rows in result, meaning no matching expenses)."
    }
  },
  {
    "question_id": 1435,
    "result": {
      "expected_answer": "Names of events (event_name) whose type is 'Game', status is 'Closed', and event_date is between 2019-03-15 and 2020-03-20 inclusive.",
      "sql_description": "Selects event_name from event records where type='Game', status='Closed', and event_date falls within the given date range.",
      "reason": "All required anchors (type Game, status Closed, date range 3/15/2019-3/20/2020) are explicitly applied; query returns only event_name, matching requested output.",
      "verdict": true,
      "evidence": "sql_result rows: event_name column -> e.g., Women's Soccer, Football game (rows 0-2)"
    }
  },
  {
    "question_id": 1322,
    "result": {
      "expected_answer": "A single integer: the number of events whose type is 'Meeting' and that were attended by more than 10 distinct club members.",
      "sql_description": "The inner query selects each event_id from attendance that has more than 10 member rows. It joins this list to event, keeps only rows where event.type = 'Meeting', and finally counts those events.",
      "reason": "Both required anchors are met: attendance > 10 members (via HAVING COUNT(link_to_member) > 10) and event type 'Meeting'. The final COUNT(*) therefore returns exactly the number requested by the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 4, indicating there are 4 such meeting events."
    }
  },
  {
    "question_id": 1317,
    "result": {
      "expected_answer": "A single integer: the number of Student_Club members who attended the \"Women's Soccer\" event and whose requested T-shirt size is Medium.",
      "sql_description": "Joins member → attendance → event, keeps rows for event_name = 'Women's Soccer', members whose t_shirt_size = 'Medium', and whose position = 'Student_Club'; counts distinct member_id.",
      "reason": "All required anchors—attendance at \"Women's Soccer\", membership in Student_Club (via position), and Medium T-shirt preference—are enforced, and the query returns their count.",
      "verdict": true,
      "evidence": "Result set has column COUNT(DISTINCT m.member_id) with value 0 (row 0)."
    }
  },
  {
    "question_id": 1404,
    "result": {
      "expected_answer": "For the event named 'October Meeting', list each expense type (category) and the total approved cost (sum of cost) for that event.",
      "sql_description": "Fetches every budget category linked to the 'October Meeting' event, sums the cost of expenses whose approved flag equals 'TRUE', and returns one row per category with that sum.",
      "reason": "Query joins event→budget→expense, filters on event name and approved flag, groups by category, and sums cost, which matches the request for expense types and their total approved value for the specified event.",
      "verdict": true,
      "evidence": "Result columns: category, total_value (sum(cost)); zero rows returned in test data but structure correct."
    }
  },
  {
    "question_id": 1464,
    "result": {
      "expected_answer": "First and last names of members who received funds on 9/9/2019, together with the amount each received.",
      "sql_description": "Joins member with income on member_id and filters rows where income.date_received equals '9/9/2019'; returns first_name, last_name, and amount.",
      "reason": "Query selects the required columns and applies the correct date filter, satisfying all anchors (names, amount, specific date).",
      "verdict": true,
      "evidence": "sql_result shows columns [first_name, last_name, amount]; although no rows returned, structure proves query addresses the question."
    }
  },
  {
    "question_id": 1149,
    "result": {
      "expected_answer": "Identify which category among male in-patients (Admission '+') and male outpatients (Admission '-') is more numerous, then report the deviation as the ratio inpatient_count / outpatient_count expressed in percent.",
      "sql_description": "Counts male in-patients and male outpatients, declares the group with the larger count, and computes 100 * (inpatient_count - outpatient_count) / (inpatient_count + outpatient_count).",
      "reason": "The query gets the correct larger group anchor, but its deviation formula divides the difference by the total (A−B)/(A+B) instead of the required ratio A/B stated in the evidence. Anchor ‘percentage formula = A divided by B’ is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1155,
    "result": {
      "expected_answer": "For every patient whose LDH value exceeds 500 in any lab record, provide the patient ID together with their sex and birthday.",
      "sql_description": "Joins Patient and Laboratory tables, filters rows where LDH > 500, and outputs p.ID, p.SEX, p.Birthday for each matching laboratory entry (one row per lab record, so patients may repeat).",
      "reason": "Query applies the correct LDH > 500 threshold and returns the requested three attributes. Although it may return duplicate rows for the same patient, the question does not explicitly require distinct patients, so this is acceptable.",
      "verdict": true,
      "evidence": "Result columns: ID, SEX, Birthday; all rows satisfy LDH > 500 filter (verified via WHERE clause) and display requested attributes."
    }
  },
  {
    "question_id": 1387,
    "result": {
      "expected_answer": "Full name of the student (or students) who is responsible for managing the budget for the event named \"Yearly Kickoff\".",
      "sql_description": "Looks for members whose position is 'Budget Manager'; joins member.member_id to budget.link_to_event (treating the event_id as if it were a member_id) and links that budget row to the 'Yearly Kickoff' event, then returns the member's full name.",
      "reason": "The join condition m.member_id = b.link_to_event mismatches member_id with event_id, so the query cannot correctly relate a student to the event’s budget. This breaks the required anchor between the student and the 'Yearly Kickoff' budget manager role, yielding no valid result.",
      "verdict": false
    }
  },
  {
    "question_id": 1381,
    "result": {
      "expected_answer": "Full names (first name + last name) of students whose attendance record shows they have been present at more than 7 events.",
      "sql_description": "Joins member with attendance, groups by each member, counts the number of attendance records (events) per member, and returns the concatenated first and last names for those counts greater than 7.",
      "reason": "Query applies the correct join, aggregates per student, filters with HAVING COUNT(link_to_event) > 7, and outputs the requested full names, satisfying all explicit anchors.",
      "verdict": true,
      "evidence": "sql_result has one column `full_name` with 20 rows such as 'Grant Gilmour', all representing members meeting the >7-event condition."
    }
  },
  {
    "question_id": 1185,
    "result": {
      "expected_answer": "A numeric decrease rate (preferably as a percentage) for the patient born 1959-02-18, computed as (total cholesterol in 1981-11 minus total cholesterol in 1981-12) divided by the 1981-12 total cholesterol.",
      "sql_description": "Gets the patient with birthday 1959-02-18, sums T-CHO for November 1981 and for December 1981, then returns 100 * (Nov_sum - Dec_sum) / Dec_sum as decrease_rate.",
      "reason": "All required anchors are present: correct patient filter, correct months and year, summing T-CHO, and formula divides the difference by the December sum. Result therefore answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column decrease_rate with value 6.030151 (row 0)."
    }
  },
  {
    "question_id": 1460,
    "result": {
      "expected_answer": "Full name (first and last) of the member who submitted the expense with description \"Water, Veggie tray, supplies\", together with the cost of that expense.",
      "sql_description": "Joins member and expense tables, filters expenses where expense_description equals 'Water, Veggie tray, supplies', and returns the concatenated first_name + last_name as full_name along with the cost.",
      "reason": "Query applies the required description filter, returns the requested full name and the corresponding cost. All anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result row0: full_name=Elijah Allen, cost=28.15"
    }
  },
  {
    "question_id": 1209,
    "result": {
      "expected_answer": "A list of the diagnoses for patients whose ALT (GPT) level is above 60, ordered from the oldest to the youngest according to their birthday.",
      "sql_description": "Joins Patient with Laboratory, keeps rows where GPT > 60, outputs the Diagnosis column, and orders the rows by the patient's Birthday in ascending order.",
      "reason": "It applies the GPT > 60 anchor and orders by birthday ASC as required. The question does not forbid duplicates, so returning multiple rows per patient is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows a single column \"Diagnosis\" with values such as MRA, SLE, RA, Adult STILL, SJS in the order produced."
    }
  },
  {
    "question_id": 1171,
    "result": {
      "expected_answer": "The number (count) of distinct patients whose Birthday year is less than 18 (interpreted as “underage”) and who had at least one examination with Examination Date between 1990 and 1993 inclusive.",
      "sql_description": "Counts DISTINCT patient IDs after joining Patient and Examination where the patient’s birth-year extracted with strftime is <18 and the examination year (also via strftime) is between 1990 and 1993.",
      "reason": "Query applies the required underage filter and the examination-year window, then counts unique patients, matching the question’s demand.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT p.ID) with value 0, i.e., no such patients found."
    }
  },
  {
    "question_id": 1427,
    "result": {
      "expected_answer": "List of budget categories (budget.category) for events whose location is 'MU 215', event type is 'Guest Speaker', and where the budget spent is 0.",
      "sql_description": "Joins budget with event, filters rows where event.location = 'MU 215', event.type = 'Guest Speaker', and budget.spent = 0, then returns the distinct budget.category values.",
      "reason": "All required anchors—location MU 215, type Guest Speaker, spent = 0—are present. Query returns the requested budget categories, matching the question intent.",
      "verdict": true,
      "evidence": "sql_result shows category column with 4 distinct values (Speaker Gifts, Food, Parking, Advertisement) corresponding to the criteria."
    }
  },
  {
    "question_id": 1153,
    "result": {
      "expected_answer": "Return the diagnosis (disease) recorded for patient ID 30609 and all laboratory test dates for that same patient.",
      "sql_description": "Fetches only the Date column from Laboratory for rows whose ID matches 30609 via a join with Patient, ordered chronologically.",
      "reason": "Query omits the required disease/diagnosis information; it only supplies lab dates, so it does not fully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1179,
    "result": {
      "expected_answer": "The anti-Cardiolipin antibody (aCL IgM) concentration value for the patient whose record shows Diagnosis = 'SLE' and Description date 1994-02-19, measured on the examination dated 1993-11-12.",
      "sql_description": "Finds the patient with Diagnosis 'SLE' and Description '1994-02-19', then selects that patient’s aCL IgM value in Examination records dated '1993/11/12'.",
      "reason": "All anchors (diagnosis, patient record date, examination date, aCL IgM field) are explicitly enforced; the query returns exactly the requested concentration. Logical mapping matches the question.",
      "verdict": true,
      "evidence": "Returned column: aCL IgM; 0 rows, indicating no recorded value, which is an acceptable result if no measurement exists."
    }
  },
  {
    "question_id": 1198,
    "result": {
      "expected_answer": "The total number of distinct female patients (SEX = 'F') who received an APS diagnosis.",
      "sql_description": "Joins Patient and Examination, filters to female patients and examinations whose Diagnosis = 'APS', then counts distinct patient IDs.",
      "reason": "Both required anchors are present: SEX='F' and Diagnosis='APS'. Counting DISTINCT Patient.ID gives the number of female patients given an APS diagnosis. Using Examination.Diagnosis is a reasonable interpretation since diagnoses are recorded there as well.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT Patient.ID) = 2"
    }
  },
  {
    "question_id": 1238,
    "result": {
      "expected_answer": "Return the ID and sex of the oldest patient (earliest Birthday) who is diagnosed with SLE and whose hemoglobin level is within the normal range (10 < HGB < 17).",
      "sql_description": "Joins Patient, Examination and Laboratory; keeps rows where Examination.Diagnosis = 'SLE' and HGB between 10 and 17; orders by Patient.Birthday ascending (older first) then ID; returns the first row’s ID and SEX.",
      "reason": "All required anchors are present: SLE diagnosis, normal hemoglobin range, and selection of the oldest via Birthday ordering. Although multiple lab or exam rows could create duplicates, the LIMIT 1 still yields a valid candidate, and the question only asks for the single oldest patient, so the query meets the intent.",
      "verdict": true,
      "evidence": "sql_result columns: ID, SEX; first row shows ID=48473, SEX=F."
    }
  },
  {
    "question_id": 1175,
    "result": {
      "expected_answer": "Return the age (in years, examination date year minus birthday year) of the patient at the examination that recorded the single highest hemoglobin (MAX(HGB)) and the doctor’s diagnosis for that same examination.",
      "sql_description": "Finds the patient ID whose laboratory record has the maximum HGB value, then joins this ID to ALL examinations of that patient and reports each examination’s age (year diff) and diagnosis.",
      "reason": "Required anchor not met: the examination returned is not constrained to be the one that coincides with the lab record holding the highest HGB; the join may list unrelated examinations or multiple rows. Thus the answer may be incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1169,
    "result": {
      "expected_answer": "A numeric ratio equal to (number of male patients whose uric-acid value is ≤ 8.0) divided by (number of female patients whose uric-acid value is ≤ 6.5).",
      "sql_description": "Joins Patient and Laboratory, keeps rows where (sex='M' and UA≤8.0) or (sex='F' and UA≤6.5). Counts DISTINCT patient IDs for each sex, divides male count by female count, and returns that single value as male_to_female_ratio.",
      "reason": "All required anchors are present: sex field is checked, abnormal UA thresholds match evidence, patients are counted distinctly, and the ratio male/female is computed. Query aligns with question intent.",
      "verdict": true,
      "evidence": "sql_result shows one column male_to_female_ratio with value 0.184 (row 0)."
    }
  },
  {
    "question_id": 1235,
    "result": {
      "expected_answer": "List each patient who has a red blood cell count below 3.5, showing their patient ID, their age (current year minus birth year), and their Diagnosis.",
      "sql_description": "Joins Patient with Laboratory and selects ID, age computed from Birthday, and Diagnosis for every laboratory record where RBC < 3.5.",
      "reason": "Captures the required anchor (RBC < 3.5), returns the requested fields (ID, age, Diagnosis). Extra duplicate rows per patient are acceptable since the question does not demand uniqueness.",
      "verdict": true,
      "evidence": "Result columns: ID, age, Diagnosis; rows correspond to lab records with RBC < 3.5."
    }
  },
  {
    "question_id": 1152,
    "result": {
      "expected_answer": "A single numeric value representing the quotient COUNT(SLE & Admission='+') divided by COUNT(SLE & Admission='-'); i.e., inpatient cases over outpatient cases among SLE patients, per the evidence.",
      "sql_description": "Counts SLE patients with Admission '+' (inpatient) and divides by count with Admission '-' (outpatient); multiplies by 100 to express it as a percentage.",
      "reason": "Matches all explicit anchors: filters Diagnosis='SLE'; uses inpatient count as numerator and outpatient count as denominator as prescribed in the evidence. Scaling by 100 is an acceptable representation (percentage form) of the same ratio.",
      "verdict": true,
      "evidence": "sql_result column outpatient_to_inpatient_ratio = 130.952381 (row 0)"
    }
  },
  {
    "question_id": 1201,
    "result": {
      "expected_answer": "A numeric percentage representing the proportion of patients (distinct individuals) whose birth year is 1980 and whose diagnosis is RA that are female.",
      "sql_description": "Joins Patient and Examination, filters birthday 1980 and RA in Examination, then divides the number of female examination rows by the total number of examination rows and multiplies by 100.",
      "reason": "The query counts examination records, not distinct patients. If a patient has multiple RA examinations, they are counted multiple times, violating the anchor that the percentage be over patients. Thus it may over- or under-state the true percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 1205,
    "result": {
      "expected_answer": "A single Yes/No indicating whether patient 57266’s uric-acid value is within the defined normal range (UA>8.0 for males, UA>6.5 for females).",
      "sql_description": "Looks up every laboratory record for patient 57266 and labels each record Yes if UA exceeds the threshold for that patient’s sex, otherwise No, returning one label per lab date.",
      "reason": "Question seeks one overall judgment, but the query outputs many rows. Result set even contains both Yes and No, leaving the answer indeterminate. No aggregation or date criterion is applied, so requirement not met.",
      "verdict": false
    }
  },
  {
    "question_id": 1166,
    "result": {
      "expected_answer": "Symptoms (non-NULL) and the diagnosis of the youngest patient who has at least one medical examination recorded.",
      "sql_description": "Joins Patient with Examination, keeps rows where Examination.Symptoms is not NULL, sorts by patient Birthday descending (youngest first) and returns one row (ID, Patient.Diagnosis, Symptoms).",
      "reason": "Captures required anchors: considers only patients with an examination, picks the youngest via highest birthday value, ensures symptoms are non-NULL, and returns both symptoms and diagnosis (extra ID acceptable).",
      "verdict": true,
      "evidence": "sql_result columns: ID, Diagnosis, Symptoms; first row shows Symptoms='CNS susp', Diagnosis='SLE'."
    }
  },
  {
    "question_id": 1254,
    "result": {
      "expected_answer": "The number of distinct patients whose Ig A value is between 80 and 500 and whose first hospital visit (First Date) falls in year 1990 or later.",
      "sql_description": "Counts distinct patient IDs after joining Patient with Laboratory, keeping rows where IGA > 80 and IGA < 500 and where the year extracted from Patient.`First Date` is at least 1990.",
      "reason": "All required anchors are present: Ig A normal-range filter, hospital visit time filter (year ≥ 1990), and counting distinct patients. Logic matches the question.",
      "verdict": true,
      "evidence": "sql_result shows one column COUNT(DISTINCT p.ID) with value 140, providing the requested count."
    }
  },
  {
    "question_id": 1195,
    "result": {
      "expected_answer": "The average albumin (ALB) value among lab records belonging to female patients whose platelet count (PLT) exceeds 400 and who are diagnosed with SLE.",
      "sql_description": "Joins Patient, Laboratory and Examination by patient ID, keeps rows where Patient.SEX = 'F', Laboratory.PLT > 400 and Examination.Diagnosis = 'SLE', then returns AVG(Laboratory.ALB).",
      "reason": "All explicit anchors—female sex, PLT > 400, SLE diagnosis—are present. Calculating AVG(ALB) over the qualifying joined rows satisfies the question; averaging per record is a reasonable interpretation since the question does not demand patient-level deduplication.",
      "verdict": true,
      "evidence": "sql_result shows one column AVG(l.ALB) with value 4.3 (row 0), which represents the computed average albumin level."
    }
  },
  {
    "question_id": 1252,
    "result": {
      "expected_answer": "A single number: the count of patients who have at least one laboratory record with IGG between 900 and 2000 (exclusive) and whose symptoms field is not NULL in examination records.",
      "sql_description": "Counts distinct patient IDs that appear in Laboratory with IGG > 900 and < 2000 and in Examination with a non-NULL Symptoms value.",
      "reason": "All required anchors (IGG range, Symptoms IS NOT NULL, counting distinct patients) are correctly implemented. Ambiguities about matching dates are irrelevant because the question only concerns patient-level existence.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT p.ID) = 1 (column COUNT(DISTINCT p.ID) row 0)."
    }
  },
  {
    "question_id": 1232,
    "result": {
      "expected_answer": "A list of each patient (at least one row per qualifying test) showing their ID, sex, and current age, where some laboratory record for the patient has GLU ≥ 180 (high) AND T-CHO < 250 (normal).",
      "sql_description": "Joins Patient with Laboratory on ID, filters rows where GLU is 180 or higher and T-CHO is below 250, then returns the patient ID, sex, and age (year difference between today and Birthday) for every matching lab row.",
      "reason": "All explicit anchors are present: GLU ≥ 180, T-CHO < 250, outputs ID/SEX/age. Duplicates per patient are acceptable because the question does not demand uniqueness. Age calculation method is reasonable.",
      "verdict": true,
      "evidence": "sql_result columns: ID, SEX, age; rows e.g. (57266, M, 102) …, all satisfy requested format."
    }
  },
  {
    "question_id": 1247,
    "result": {
      "expected_answer": "A single integer: the number of distinct male patients whose white-blood-cell count is in the normal range (3.5–9.0) and whose fibrinogen value is abnormal (≤150 or ≥450).",
      "sql_description": "Joins Patient with Laboratory, keeps rows for male patients where the same laboratory record shows WBC between 3.5 and 9.0 and FG ≤150 or ≥450, then counts DISTINCT patient IDs.",
      "reason": "All explicit anchors (male sex, normal WBC range, abnormal FG range, deduplicated patients) are present. The query requires both conditions to occur in the same lab record; the wording does not forbid this interpretation, so it is a reasonable reading. Therefore the SQL answers the question.",
      "verdict": true,
      "evidence": "sql_result has one column COUNT(DISTINCT p.ID) with value 6, providing the requested count."
    }
  },
  {
    "question_id": 1243,
    "result": {
      "expected_answer": "A single numeric percentage: among patients aged over 55 whose prothrombin time (PT) is abnormal (PT ≥ 14), what share are female.",
      "sql_description": "1) Builds list of patients older than 55 (year-based). 2) Joins to all Laboratory rows with PT ≥ 14. 3) Counts rows whose SEX='F' and divides by total qualifying rows, multiplying by 100.",
      "reason": "The percentage should be calculated at patient level; each patient must be counted once regardless of how many abnormal-PT lab entries they have. The query counts laboratory rows, so patients with multiple abnormal PT measurements are over-represented, distorting both numerator and denominator. Required DISTINCT patient anchor is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1265,
    "result": {
      "expected_answer": "A single integer: the number of distinct patients whose anti-ribonuclear protein (RNP) test result is in the normal range ('-' or '+-') and whose Admission flag is '+'.",
      "sql_description": "Counts distinct Patient IDs after joining Patient with Laboratory where Laboratory.RNP is '-' or '+-' and Patient.Admission is '+'.",
      "reason": "Query applies the two required filters (normal RNP values and Admission='+') and counts DISTINCT patients, matching the question; no anchors are missing.",
      "verdict": true,
      "evidence": "Result set has column COUNT(DISTINCT p.ID) with value 0 (row 1)."
    }
  },
  {
    "question_id": 1189,
    "result": {
      "expected_answer": "A single integer: the count of distinct patients whose Thrombosis = 2 and ANA Pattern = 'S' whose aCL IgM value exceeds the average aCL IgM for that group by at least 20 % (i.e., > 1.2 × average).",
      "sql_description": "First computes the average aCL IgM among examinations with ANA = 'S' and Thrombosis = 2 (using column ANA, not ANA Pattern). Then counts distinct patients with the same filters whose aCL IgM is greater than (avg + avg) * 0.2 (which equals 0.4 × average).",
      "reason": "Threshold is mis-computed (0.4×avg instead of 1.2×avg, so it does not identify values 20 % above the mean). Moreover, it filters on ANA = 'S' rather than ANA Pattern = 'S', contradicting schema semantics. Required anchors therefore not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1275,
    "result": {
      "expected_answer": "The count of distinct male patients (Sex = 'M') who have normal anti-centromere (CENTROMEA in '-', '+-') and normal anti-SSB (SSB in '-', '+-') results.",
      "sql_description": "Joins Patient and Laboratory, filters male patients and lab records where both CENTROMEA and SSB are in ('-', '+-'); counts distinct patient IDs.",
      "reason": "All required anchors—male sex, normal anti-centromere, normal anti-SSB, DISTINCT patient count—are present. Interpreting the question to require at least one lab record where both markers are normal is reasonable and not contradicted by the prompt.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT p.ID) with value 0 for the single row returned."
    }
  },
  {
    "question_id": 1225,
    "result": {
      "expected_answer": "For each sex (M/F), provide a concatenated list of all distinct patient IDs whose total bilirubin (T-BIL) value is >= 2.0 (i.e., outside the normal range).",
      "sql_description": "Joins Patient with Laboratory, filters rows where T-BIL >= 2.0, groups by SEX, and returns GROUP_CONCAT(DISTINCT p.ID) for each sex.",
      "reason": "All required anchors are met: uses >=2.0 threshold, groups by sex, lists distinct patient IDs. No extraneous or missing conditions.",
      "verdict": true,
      "evidence": "Result shows two rows with columns SEX and patient_ids, e.g. row0 SEX='F', row1 SEX='M', each containing comma-separated ID lists."
    }
  },
  {
    "question_id": 1035,
    "result": {
      "expected_answer": "All team_fifa_api_id values for teams whose buildUpPlaySpeed is greater than 50 and less than 60 (i.e., 51-59).",
      "sql_description": "Joins Team and Team_Attributes on team_fifa_api_id and returns Team.team_fifa_api_id for every Team_Attributes row where buildUpPlaySpeed > 50 and < 60; duplicates are not removed.",
      "reason": "Query applies the exact numeric filter required and outputs the requested column. Duplicate rows do not invalidate the answer because the question does not prohibit them.",
      "verdict": true,
      "evidence": "sql_result shows team_fifa_api_id column (e.g., 434, 77, 614, 1901, 650, 1861, 229, 111989, 1) that satisfy the 51-59 speed condition."
    }
  },
  {
    "question_id": 1220,
    "result": {
      "expected_answer": "List of each patient (ID, sex, birthday) who has a laboratory record with urea nitrogen value equal to 29 (the borderline-passing level).",
      "sql_description": "Joins Patient with Laboratory, filters rows where Laboratory.UN = 29, outputs the patient’s ID, SEX and Birthday.",
      "reason": "Satisfies the only explicit anchor (UN = 29). Returns the requested columns; duplicates from multiple test dates do not conflict with the question’s intent of providing all such patients.",
      "verdict": true,
      "evidence": "sql_result shows columns ID, SEX, Birthday for 20 rows, all presumably coming from UN=29 records."
    }
  },
  {
    "question_id": 1251,
    "result": {
      "expected_answer": "The count of distinct patients who have at least one laboratory record with IGG value 2000 or above (i.e., Ig G higher than normal).",
      "sql_description": "Joins Patient and Laboratory, keeps rows where l.IGG >= 2000, and returns COUNT(DISTINCT p.ID) to get the number of unique patients meeting that criterion.",
      "reason": "Query applies the correct IGG >= 2000 threshold, uses DISTINCT on patient IDs as required, and returns a single count value; no anchors are missing.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT p.ID) with value 136."
    }
  },
  {
    "question_id": 1267,
    "result": {
      "expected_answer": "The count of distinct patients whose anti-SM laboratory result is normal ('-' or '+-') and whose thrombosis status is explicitly recorded as 0 (negative). Patients with any positive thrombosis value or without a thrombosis record should not be counted.",
      "sql_description": "Counts distinct patients that have a Laboratory.SM value in ('-', '+-') and whose Examination.Thrombosis is 0 OR NULL.",
      "reason": "The question’s explicit anchor is Thrombosis = 0. The query also admits Examination.Thrombosis IS NULL, so it counts patients with missing thrombosis data, violating the required anchor. It may also include patients who have both 0 and positive thrombosis records. Therefore it does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1242,
    "result": {
      "expected_answer": "All patient identifiers who had a lab exam in 1984 and whose platelet count was in the normal range (100–400) and whose current age is under 50 years.",
      "sql_description": "Joins Patient and Laboratory; keeps rows where the lab Date year is 1984, platelet count between 100 and 400, and the difference between the current year and patient birth year is <50; returns distinct patient IDs.",
      "reason": "Query contains every required anchor (year 1984, PLT 100–400, age<50) and returns the requested list of patients. Using current age rather than age in 1984 is a reasonable interpretation and not contradicted by evidence.",
      "verdict": true,
      "evidence": "sql_result shows 5 distinct IDs column [ID] (e.g., 102490, 460574, ...)."
    }
  },
  {
    "question_id": 1029,
    "result": {
      "expected_answer": "The buildUpPlaySpeed values (optionally with team names) for the four teams that have the highest buildUpPlaySpeed in the dataset.",
      "sql_description": "Joins Team with Team_Attributes, orders all rows by buildUpPlaySpeed descending, and returns the first four rows (team_long_name plus buildUpPlaySpeed).",
      "reason": "Query correctly targets buildUpPlaySpeed, orders descending to get the highest values, and limits to four results, satisfying the request for the top-4 teams’ attack-build speed. No required anchors are missing; returning team names in addition to the speed is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows 4 rows with columns team_long_name and buildUpPlaySpeed (e.g., Carpi – 80, Hannover 96 – 78, etc.), matching the requested information."
    }
  },
  {
    "question_id": 1241,
    "result": {
      "expected_answer": "Return the number of distinct patients whose platelet (PLT) results are below 100 (low abnormal) and compare it—e.g., by subtracting—to the number of distinct patients whose PLT results are above 400 (high abnormal). Only patients with any abnormal PLT (<=100 or >=400) should be considered.",
      "sql_description": "Filters Laboratory rows with abnormal PLT values, then counts how many rows (not patients) have PLT<100 and how many have PLT>400, and outputs the two row counts plus their difference (low − high).",
      "reason": "Question asks for numbers of patients, implying distinct IDs. Query counts lab rows, so patients with multiple tests are over-counted. Missing DISTINCT on ID violates the patient anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1270,
    "result": {
      "expected_answer": "A single integer: the number of distinct patients whose anti-scl70 result is normal (SC170 = 'negative' or '0'), whose sex is female, and whose Symptoms field is NULL.",
      "sql_description": "Counts distinct patient IDs after joining Patient with Laboratory and Examination, keeping only rows where SC170 is 'negative' or '0', sex is 'F', and Symptoms IS NULL. Uses COUNT(DISTINCT p.ID) to return the final number.",
      "reason": "All required anchors are present: SC170 normal filter, female sex, Symptoms IS NULL, and distinct patient counting. The LEFT JOIN with a Symptoms IS NULL filter effectively selects patients having at least one exam row with NULL symptoms, which aligns with the evidence definition. Therefore the query answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with COUNT(DISTINCT p.ID)=19"
    }
  },
  {
    "question_id": 1256,
    "result": {
      "expected_answer": "The number of distinct patients whose C-reactive protein test is abnormal (CRP = '+') and whose patient record has no Description value (Description IS NULL).",
      "sql_description": "Joins Patient with Laboratory on ID, selects rows where Laboratory.CRP = '+' and Patient.Description IS NULL, counts distinct patient IDs, returning 25.",
      "reason": "Query filters on the required CRP abnormality and missing Description fields exactly as specified and counts unique patients, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT p.ID) with value 25 (row 0)."
    }
  },
  {
    "question_id": 1040,
    "result": {
      "expected_answer": "Names of the 10 tallest players (height > 180) with the highest average heading_accuracy, ordered from highest to lowest average.",
      "sql_description": "Joins Player with Player_Attributes, keeps players whose height exceeds 180, groups rows by player_name, computes AVG(heading_accuracy) per name, orders by that average descending, and returns the first 10 names.",
      "reason": "All required anchors are present: height filter (>180), average of heading_accuracy, descending order, top 10, returning names. Minor ambiguity about grouping by name vs ID is acceptable; it still provides the requested information for each name.",
      "verdict": true,
      "evidence": "sql_result shows 10 rows with column player_name, ordered as expected."
    }
  },
  {
    "question_id": 1255,
    "result": {
      "expected_answer": "Return the disease diagnosis that appears most often among patients whose IgM value is ≤ 40 or ≥ 400.",
      "sql_description": "Finds patient IDs with abnormal IgM in Laboratory, then counts how many of those patients have each Diagnosis in Patient, orders by descending count, and returns the top diagnosis.",
      "reason": "Query correctly filters abnormal-IgM patients, aggregates diagnoses per distinct patient, selects the highest count, and outputs that disease. All required anchors (IgM threshold, most common diagnosis) are present.",
      "verdict": true,
      "evidence": "sql_result shows column Diagnosis with value 'SLE' in row 0, providing the requested most common disease."
    }
  },
  {
    "question_id": 1028,
    "result": {
      "expected_answer": "The long name of the team that recorded the highest number of away wins in the Scotland Premier League during the 2009/2010 season.",
      "sql_description": "Filters matches to Scotland Premier League and season '2009/2010', keeps only games where the away team won (away goals > home goals), counts such wins per away team, orders by this count descending, and returns the team_long_name of the top team (LIMIT 1).",
      "reason": "All explicit anchors are satisfied: correct league, correct season treated as 2010 season per evidence, away-win condition, counting wins, selecting the maximum. The result therefore answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column team_long_name = 'Rangers', matching expected output structure."
    }
  },
  {
    "question_id": 1031,
    "result": {
      "expected_answer": "List each player who recorded a sprint_speed of 97 or higher in any record dated 2013-2015 (inclusive), together with the player’s current age (calculated from today’s date and birthday).",
      "sql_description": "Finds all Player_Attributes rows dated between 2013-01-01 and 2015-12-31 with sprint_speed >=97, joins to Player, calculates age as floor((today−birthday)/365.25) and returns distinct player_name and age.",
      "reason": "Query applies the correct sprint_speed filter, correct date window, computes age from current date, and outputs one row per qualified player. All required anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result columns: player_name, age. Example row 0: (Mathis Bolly, 34)."
    }
  },
  {
    "question_id": 1048,
    "result": {
      "expected_answer": "The overall rating value(s) for footballer Gabriel Tamas during the year 2011 (e.g., a single representative rating for that season).",
      "sql_description": "Finds all Player_Attributes rows for Gabriel Tamas whose date falls in 2011 and returns the average of their overall_rating values.",
      "reason": "All required anchors are present: correct player name and 2011 date filter. The query supplies a single rating by averaging, a reasonable interpretation of the singular question wording.",
      "verdict": true,
      "evidence": "AVG(pa.overall_rating)=75.0"
    }
  },
  {
    "question_id": 1037,
    "result": {
      "expected_answer": "Percentage = (number of distinct players born 1987-1992 whose preferred_foot = 'left') ÷ (total distinct players born 1987-1992) × 100.",
      "sql_description": "Finds all Player rows with birth year 1987-1992, joins to all their Player_Attributes rows, counts DISTINCT players for denominator but sums 1 per left-foot attribute row for numerator, then multiplies by 100.",
      "reason": "Numerator should count DISTINCT left-foot players, but query counts every Player_Attributes row, duplicating players that have multiple records. This inflates the ratio (result >100%), so it does not return the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 1302,
    "result": {
      "expected_answer": "A single integer: the number of distinct patients whose creatinine phosphokinase (CPK) is below 250 and who have at least one positive coagulation measure (KCT, RVVT, or LAC equal to '+').",
      "sql_description": "Joins Patient with Laboratory and Examination, filters lab rows to CPK < 250 and exam rows where KCT = '+' OR RVVT = '+' OR LAC = '+', then counts distinct patient IDs.",
      "reason": "All required anchors are present: CPK < 250 for normal range and positivity check on any of KCT, RVVT, or LAC. Counting distinct patients satisfies the 'how many' requirement. Date alignment between lab and exam records is unspecified and reasonably interpreted as any occurrence per patient.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT p.ID) = 1"
    }
  },
  {
    "question_id": 1115,
    "result": {
      "expected_answer": "A single numeric value: ((Landon Donovan overall_rating − Jordan Bowery overall_rating) / Landon Donovan overall_rating) × 100 for the date 2013-07-12.",
      "sql_description": "Pulls Landon Donovan’s and Jordan Bowery’s rows from Player_Attributes whose date equals the literal string '2013-07-12', joins them on that exact date, then computes 100 × (Landon − Jordan)/Landon.",
      "reason": "The question requires using the records from 2013-07-12 regardless of the time part. In this database dates are stored with the time component (e.g. '2013-07-12 00:00:00'); filtering with the bare string '2013-07-12' fails to match those rows, resulting in no data and therefore no percentage. Hence the query does not satisfy the date anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1068,
    "result": {
      "expected_answer": "The average of the overall_rating values recorded in Player_Attributes between the years 2010 and 2015 (inclusive) for those players whose height in the Player table is greater than 170 cm.",
      "sql_description": "Computes AVG(pa.overall_rating) for Player_Attributes rows that are linked to at least one Match dated 2010-2015 and whose Player.height>170, duplicating each attribute row once for every qualifying match appearance.",
      "reason": "Date anchor is applied to Match.date instead of Player_Attributes.date, and unnecessary join to Match skews the averaging by duplicating records. Required anchor on attribute date (2010-2015) is missing/incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1136,
    "result": {
      "expected_answer": "A single number: the count of players whose crossing score equals the maximum crossing score in the dataset and whose preferred_foot is 'left'.",
      "sql_description": "Counts distinct player_api_id values in Player_Attributes where preferred_foot = 'left' and crossing equals the overall MAX(crossing).",
      "reason": "SQL applies required anchors: preferred_foot = 'left' and crossing at global maximum, then counts distinct players, matching the question’s intent.",
      "verdict": true,
      "evidence": "Result set has one column COUNT(DISTINCT p.player_api_id) with value 2 indicating two such players."
    }
  },
  {
    "question_id": 1092,
    "result": {
      "expected_answer": "The name of the league that recorded the highest number of matches during the 2008/2009 season.",
      "sql_description": "Joins League with Match, keeps only matches from season '2008/2009', groups by league, orders by descending match count (ties broken alphabetically), and returns the first league name.",
      "reason": "Query applies the required season filter, counts matches per league, selects the league with the maximum count, and outputs its name—exactly what the question asks.",
      "verdict": true,
      "evidence": "sql_result shows one row: name = 'England Premier League' (column: name, row 0), consistent with the intended answer."
    }
  },
  {
    "question_id": 1080,
    "result": {
      "expected_answer": "A single integer: the number of distinct players whose preferred_foot is 'left' and whose attacking_work_rate is 'low'.",
      "sql_description": "Joins Player with Player_Attributes then counts DISTINCT player_api_id rows where preferred_foot = 'left' and attacking_work_rate = 'low'.",
      "reason": "Query applies both required filters and counts unique players, matching the question’s intent. Multiple attribute rows per player are handled via DISTINCT, so the count represents players, not rows.",
      "verdict": true,
      "evidence": "sql_result shows one column COUNT(DISTINCT p.player_api_id) with value 189."
    }
  },
  {
    "question_id": 1058,
    "result": {
      "expected_answer": "The name of the player whose height is either the overall maximum or overall minimum and whose average finishing score (across all his attribute records) is highest among those extreme-height players.",
      "sql_description": "1) Finds the global tallest and shortest heights. 2) Collects all players whose height equals either extreme. 3) For each of those players, computes AVG(finishing) from Player_Attributes. 4) Returns the single player with the highest average finishing.",
      "reason": "All required anchors are honored: only tallest and shortest players are considered; finishing is averaged per player; the highest average among them is selected; the query outputs that player’s name. This matches the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows one row: player_name='Juan Quero', avg_finishing_rate=60.9, fitting the expected single-player answer."
    }
  },
  {
    "question_id": 1141,
    "result": {
      "expected_answer": "The single build-up play speed class (slow, balanced, or fast) that applies to KSV Cercle Brugge – normally the one from the most relevant/most recent Team_Attributes record.",
      "sql_description": "Fetches every buildUpPlaySpeedClass value for KSV Cercle Brugge from Team_Attributes without choosing a specific date, returning one row per recorded date.",
      "reason": "The query returns multiple rows containing both “Balanced” and “Fast”, so it does not resolve to a single speed class as the question implies. It omits a rule (e.g., latest date) to pick the definitive class, thus failing the required anchor of a unique answer.",
      "verdict": false
    }
  },
  {
    "question_id": 1094,
    "result": {
      "expected_answer": "A single percentage indicating (Ariel Borysiuk overall_rating − Paulin Puel overall_rating) ÷ Paulin Puel overall_rating × 100.",
      "sql_description": "Selects every Player_Attributes row for Ariel and every row for Paulin, forms a cartesian product, and computes the percentage difference for each pair, returning many rows.",
      "reason": "Fails to anchor on a unique overall_rating for each player (e.g., latest or average) and therefore outputs multiple duplicated percentages instead of one definitive value.",
      "verdict": false
    }
  },
  {
    "question_id": 850,
    "result": {
      "expected_answer": "Names of races that took place at circuits located in Germany.",
      "sql_description": "Joins races with circuits and returns the race names where the circuit's country equals 'Germany'.",
      "reason": "Query applies the necessary Germany‐circuit filter and outputs the race names, satisfying the question; duplicates are acceptable because uniqueness wasn't requested.",
      "verdict": true,
      "evidence": "sql_result has column 'name' with values like 'German Grand Prix', 'European Grand Prix', confirming races on German circuits are returned."
    }
  },
  {
    "question_id": 1113,
    "result": {
      "expected_answer": "The defenceAggressionClass value (e.g., “Press/Contain/Double”) for team Hannover 96 on 2015-09-10.",
      "sql_description": "Joins Team with Team_Attributes, filters rows where team_long_name = ‘Hannover 96’ and date starts with ‘2015-09-10’, then returns defenceAggressionClass.",
      "reason": "All explicit anchors—team name and specific date—are correctly applied. Query retrieves the requested attribute; result shows one class value, satisfying the question.",
      "verdict": true,
      "evidence": "defenceAggressionClass row0=Press"
    }
  },
  {
    "question_id": 1135,
    "result": {
      "expected_answer": "Four player_api_id values belonging to players whose potential equals the global minimum potential score and whose preferred_foot is 'right'.",
      "sql_description": "Selects rows with preferred_foot='right', orders them by potential ascending and player_api_id, then returns the first four player_api_id values (duplicates allowed).",
      "reason": "Question, via evidence, requires restricting to potential = MIN(potential). Query only sorts by potential and limits to four, so if fewer than four right-footed players have the absolute minimum, higher-potential players will be included. Missing explicit MIN(potential) anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1107,
    "result": {
      "expected_answer": "The earliest date on which Kevin Constant achieved his highest crossing rating (max crossing score).",
      "sql_description": "Computes Kevin Constant’s maximum crossing value, then finds rows with that value and returns the earliest date (ORDER BY date ASC LIMIT 1).",
      "reason": "All required anchors are satisfied: filters for Kevin Constant, identifies MAX(crossing), selects first chronological date where crossing equals that max. Matches question intent exactly.",
      "verdict": true,
      "evidence": "sql_result shows one row: date column value '2013-02-15 00:00:00', which aligns with the expected single earliest date."
    }
  },
  {
    "question_id": 1134,
    "result": {
      "expected_answer": "A single numeric value equal to player 6’s jumping score minus player 23’s jumping score (using their records in Player_Attributes).",
      "sql_description": "The query cross-joins all Player_Attributes rows where player_api_id = 6 with all rows where player_api_id = 23 and returns the difference of their jumping values (p6.jumping - p23.jumping).",
      "reason": "The question refers to players with id 6 and 23 (Player_Attributes.id according to the evidence) but the SQL filters on player_api_id, so it may select the wrong players. Because of this mismatch the query returns no rows, failing to provide the required difference.",
      "verdict": false
    }
  },
  {
    "question_id": 868,
    "result": {
      "expected_answer": "Latitude and longitude of the circuit where the Malaysian Grand Prix is held.",
      "sql_description": "Joins races with circuits, filters races named 'Malaysian Grand Prix', returns the circuit's lat and lng.",
      "reason": "Query applies correct race-name anchor and outputs the requested coordinates; duplicates do not violate requirements.",
      "verdict": true,
      "evidence": "Rows show lat=2.76083, lng=101.738 for all returned records (lat,lng columns)."
    }
  },
  {
    "question_id": 1148,
    "result": {
      "expected_answer": "A single percentage value indicating what proportion of all players are shorter than 180 cm and have an overall_rating above 70.",
      "sql_description": "Counts distinct player_api_id values that satisfy height < 180 and overall_rating > 70, divides by the count of all distinct players in Player, and multiplies by 100 to yield the percentage.",
      "reason": "Uses the required height and overall_rating conditions, applies DISTINCT to avoid duplicates from multiple attribute rows, and divides by the total number of players, matching the evidence formula. No required anchor is missing.",
      "verdict": true,
      "evidence": "Result set has one column with value ≈17.59, representing the computed percentage."
    }
  },
  {
    "question_id": 865,
    "result": {
      "expected_answer": "The name (and possibly other identifiers) of the oldest driver among those who completed race 592 (results.time IS NOT NULL). Oldest means earliest date of birth.",
      "sql_description": "Joins results with drivers, keeps rows for raceId 592 where time is not null (finished), orders by dob ascending (earliest first) and picks the first row, returning that driver's id, forename, surname, and dob.",
      "reason": "Query applies the required race filter and finished-driver condition, then correctly selects the driver with the earliest birthdate, matching the definition of oldest. Returned columns identify the driver, satisfying the ‘who’ question.",
      "verdict": true,
      "evidence": "Row0: driverId=306, forename='Jean-Pierre', surname='Beltoise', dob='1937-04-26'"
    }
  },
  {
    "question_id": 866,
    "result": {
      "expected_answer": "The name of the driver who recorded a 1 minute 27-second lap in race 161, together with that driver’s introduction website URL.",
      "sql_description": "Joins drivers with lapTimes, filters laps of raceId 161 whose time string starts with '1:27', and outputs the driver’s forename, surname and url (one row per matching lap).",
      "reason": "All required anchors are present: race number 161 and lap time 1:27. The selected columns include the driver’s identity and url as requested. Extra duplicate rows do not contradict the question.",
      "verdict": true,
      "evidence": "Rows 0-19: forename, surname, url ⇒ David Coulthard, http://en.wikipedia.org/wiki/David_Coulthard"
    }
  },
  {
    "question_id": 902,
    "result": {
      "expected_answer": "List of race names in which driver Alex Yoong finished with a position (track number) under 20.",
      "sql_description": "Finds all results where the driver’s forename is 'Alex' and surname is 'Yoong', keeps those with position < 20, joins to races, and returns the race name.",
      "reason": "All required anchors are present: driver full name filter and position < 20. Query selects race names, matching the question’s target. No extra or missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows 5 rows, column name: Brazilian Grand Prix, Canadian Grand Prix, French Grand Prix, Italian Grand Prix, Japanese Grand Prix – consistent with expected list of races."
    }
  },
  {
    "question_id": 937,
    "result": {
      "expected_answer": "The finish time (results.time) of the driver who finished 2nd in the 2008 Chinese Grand Prix.",
      "sql_description": "Gets the `time` value from results for the row where the associated race is the 2008 Chinese Grand Prix and the driver’s finishing order (`positionOrder`) is 2.",
      "reason": "All required anchors are present: race name = Chinese Grand Prix, year 2008, finishing rank 2. Returns the finish time field, matching the question.",
      "verdict": true,
      "evidence": "sql_result column `time` row0 = '+14.925'"
    }
  },
  {
    "question_id": 877,
    "result": {
      "expected_answer": "The name (or identifier) of the driver with the most recent date of birth among those who recorded a finish time (time IS NOT NULL) in raceId 872 – i.e., the youngest finisher of race 872.",
      "sql_description": "Joins drivers with results, keeps rows where raceId = 872 and time is not NULL (finished), orders by dob descending (latest birthdate first), and returns the first row (driverId, forename, surname, dob).",
      "reason": "All required anchors are present: raceId 872, finished drivers (time IS NOT NULL), selection of youngest via DESC dob with LIMIT 1. Query therefore answers the question.",
      "verdict": true,
      "evidence": "Returned columns: driverId=815, forename='Sergio', surname='Pérez', dob='1990-01-26' (row 0) – the youngest finisher."
    }
  },
  {
    "question_id": 879,
    "result": {
      "expected_answer": "The nationality of the driver whose fastestLapSpeed value is the maximum recorded in the results table.",
      "sql_description": "Finds the maximum fastestLapSpeed in results, then joins to drivers to return the nationality of the driver whose fastestLapSpeed equals that maximum (first row only).",
      "reason": "Logical formulation is acceptable, but the equality comparison between a numeric cast and the original text column yields no matching row, producing an empty result; therefore the query does not return the required nationality.",
      "verdict": false
    }
  },
  {
    "question_id": 915,
    "result": {
      "expected_answer": "The nationality (country) of the driver who is oldest (earliest date of birth) among all drivers.",
      "sql_description": "Selects the nationality from drivers ordered by date of birth ascending (earliest first) and returns the first row, i.e., the oldest driver's country.",
      "reason": "Query correctly identifies the oldest driver by earliest dob and returns that driver’s nationality; meets all anchors of the question.",
      "verdict": true,
      "evidence": "sql_result shows nationality column with first row value 'South African'."
    }
  },
  {
    "question_id": 901,
    "result": {
      "expected_answer": "List all Formula 1 races whose date falls in September 2005, returning for each the race name together with its circuit name and the circuit location.",
      "sql_description": "Joins races with circuits and filters races whose date has month = 09 and year = 2005 using strftime, then selects race name, circuit name and circuit location.",
      "reason": "Filters exactly on September 2005, retrieves required columns, no missing or extraneous constraints. Result shows three races that indeed occurred in that month.",
      "verdict": true,
      "evidence": "sql_result columns: race_name, circuit_name, location; rows include Italian Grand Prix (Monza), Belgian Grand Prix (Spa), Brazilian Grand Prix (São Paulo) – all dated September 2005."
    }
  },
  {
    "question_id": 1145,
    "result": {
      "expected_answer": "The names (and optionally counts) of the four leagues that hosted the greatest number of matches in the 2015/2016 season.",
      "sql_description": "Counts matches per league for season '2015/2016', orders by the count descending (tie-broken by name), and returns the top 4 leagues with their game counts.",
      "reason": "Query applies the correct season filter, aggregates by league, ranks by number of games, and limits to the top four results, directly satisfying the question.",
      "verdict": true,
      "evidence": "name, game_count rows: (0) England Premier League 380, (1) France Ligue 1 380, (2) Italy Serie A 380, (3) Spain LIGA BBVA 380."
    }
  },
  {
    "question_id": 897,
    "result": {
      "expected_answer": "Return the full name of the driver who has the highest number of wins overall; also provide that driver’s nationality and the maximum single-race (or standings) points he has ever scored.",
      "sql_description": "Builds a per-driver summary (full name, nationality, total_wins = SUM(wins), max_points = MAX(points)), then selects the row with the greatest total_wins (breaking ties by max_points) and outputs full_name, nationality, max_points.",
      "reason": "The query identifies the driver with the most wins and outputs the requested fields. SUM(wins) provides a wins tally, MAX(points) gives the driver’s peak points, satisfying the question’s requirements.",
      "verdict": true,
      "evidence": "Result row: full_name='Michael Schumacher', nationality='German', max_points=148.0 (columns full_name, nationality, max_points)."
    }
  },
  {
    "question_id": 896,
    "result": {
      "expected_answer": "A single percentage value: for all races from 2010 onwards in which the driver with surname 'Hamilton' competed, what share of those races did he finish in a position other than 1 (i.e., position > 1).",
      "sql_description": "Counts all Hamilton results from races with year >= 2010; divides the count where finishing position > 1 by the total count, multiplies by 100, returns that percentage.",
      "reason": "Matches anchors: Hamilton only, year ≥ 2010, uses position > 1 as ‘not first’, divides by all his race entries. Provides a single percentage as requested. Minor ambiguity about NULL positions is acceptable since question/evidence define >1 criterion explicitly.",
      "verdict": true,
      "evidence": "Result column shows one value (54.225352), representing the computed percentage."
    }
  },
  {
    "question_id": 955,
    "result": {
      "expected_answer": "For every Formula 1 season with year < 1975, return that year together with the average finishing time of the race winners (position = 1) expressed in seconds.",
      "sql_description": "Builds champion_times by converting each winner’s time string ‑ formatted HH:MM:SS.mmm – into total seconds, restricted to races whose season year is before 1975 and where time is not NULL. It then averages these seconds per year and returns the year and the average seconds.",
      "reason": "All required anchors are present: uses position = 1 (champion), filters year < 1975, converts the time to seconds, and computes the average per year. Output columns match the asked information. Logic aligns with the question.",
      "verdict": true,
      "evidence": "sql_result shows rows with columns year and avg_champion_time_seconds, e.g., (1950, 7967.7), (1969, 4625.5), confirming per-year averages before 1975."
    }
  },
  {
    "question_id": 928,
    "result": {
      "expected_answer": "Reference name (drivers.driverRef) of the driver who finished 1st in the 2007 Canadian Grand Prix.",
      "sql_description": "Joins drivers, results, and races; filters races to name = 'Canadian Grand Prix' and year = 2007; keeps only rows where the finishing order (positionOrder) is 1; outputs the driverRef.",
      "reason": "All explicit anchors—race name, year, first place, reference name—are satisfied. The query retrieves the winner’s driverRef and execution shows ‘hamilton’, matching historical result.",
      "verdict": true,
      "evidence": "sql_result row 0: driverRef = hamilton"
    }
  },
  {
    "question_id": 930,
    "result": {
      "expected_answer": "The name of the Formula 1 race in which Lewis Hamilton achieved his best (lowest) rank value across all races; if multiple races share that best rank, returning any one of them (e.g., the earliest) is acceptable.",
      "sql_description": "Looks up Lewis Hamilton in drivers, joins to his results, orders those results by rank ascending (best first) then by race date, and returns the race name of the first row (LIMIT 1).",
      "reason": "Query anchors on driver full name and minimises res.rank as required, returning the corresponding race name. Potential NULL-rank rows could sort first, but evidence row returned is a real race and no contradicting requirement was given, so the query satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows column `name` with a single row: Belgian Grand Prix (row 0)."
    }
  },
  {
    "question_id": 962,
    "result": {
      "expected_answer": "The percentage of drivers who, in races from 2000-2005, were born before 1985 and recorded more than 50 laps – calculated as (# such drivers ÷ # all drivers who raced 2000-2005) × 100.",
      "sql_description": "Finds all distinct drivers appearing in races between 2000 and 2005 (eligible_drivers). Finds the subset whose dob year <1985 and who in those races logged laps>50 (born_before_1985). Returns 100 × count(distinct subset)/count(distinct all).",
      "reason": "SQL applies year 2000-2005 filter, dob<1985, laps>50, counts distinct drivers for numerator and denominator as required, then computes percentage; all anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result has column percentage with value 100.0 (row0), matching the requested metric format."
    }
  },
  {
    "question_id": 972,
    "result": {
      "expected_answer": "All drivers (id and code) whose date of birth is in 1971 and who recorded a lap with a non-NULL fastestLapTime in any race.",
      "sql_description": "Joins drivers with results, keeps drivers born in 1971, but further restricts to only those result rows whose fastestLapTime equals the overall minimum fastestLapTime in the entire results table (i.e., the single globally fastest lap time).",
      "reason": "The question only requires that the driver ‘has’ a fastest lap time (fastestLapTime IS NOT NULL). The query instead demands that the driver’s lap time be the absolute minimum among all results, an extra constraint that excludes valid drivers. Therefore it may miss correct answers.",
      "verdict": false
    }
  },
  {
    "question_id": 989,
    "result": {
      "expected_answer": "Return the driver who finished in position 1 at the 2008 Canadian Grand Prix together with his recorded finish time (the champion’s race time).",
      "sql_description": "Finds drivers whose result position is 1 in races held in 2008 at a circuit whose name is exactly 'Canadian Grand Prix'; returns their forename, surname and recorded time.",
      "reason": "The question anchors to the race named 'Canadian Grand Prix'; the query filters by circuits.name instead of races.name, causing no matching row (confirmed by empty result). Required anchor (identifying the 2008 Canadian Grand Prix race) is therefore mismatched and the champion is not returned.",
      "verdict": false
    }
  },
  {
    "question_id": 994,
    "result": {
      "expected_answer": "The constructor that accumulated the highest total points in Monaco Grand Prix races held from 1980 through 2010 (inclusive), together with that total score, the constructor’s name, and its nationality.",
      "sql_description": "Adds up points for every constructor in races whose circuit name equals 'Monaco' and whose race year is between 1980 and 2010, then returns the single constructor with the largest sum (columns: score, name, nationality).",
      "reason": "Question anchors on Monaco Grand Prix events; the query filters by circuits.name = 'Monaco'. In the given schema the Monaco track is stored as 'Circuit de Monaco', and race names are 'Monaco Grand Prix'. Filtering by exact value 'Monaco' mismatches the data, causing the race set to be empty (confirmed by empty result). Required anchor therefore not satisfied, so the query does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 963,
    "result": {
      "expected_answer": "A single integer: the number of distinct French drivers who have at least one recorded lap time under 2 minutes (i.e., under 120 seconds).",
      "sql_description": "Joins drivers with lapTimes, filters rows to those where the driver’s nationality is 'French' and the lap time is under 120,000 ms, then counts distinct driverIds.",
      "reason": "Query applies correct nationality filter and converts 2 minutes to 120,000 ms, counting unique drivers, matching the question’s criteria.",
      "verdict": true,
      "evidence": "Result set column COUNT(DISTINCT d.driverId) has value 9."
    }
  },
  {
    "question_id": 959,
    "result": {
      "expected_answer": "The lap number (results.fastestLap) on which the 2009 season champion set his quickest lap, i.e., an integer like 43.",
      "sql_description": "Gets fastestLapTime string values (not lap numbers) from every 2009 race result where the driver was temporarily first in the standings that round, picks the smallest time.",
      "reason": "1) Returns fastestLapTime, not fastestLap lap number requested. 2) Champion identification relies on driverStandings position = 1 for each race, not the season champion; may include multiple drivers. 3) Therefore required anchor (fastest lap number of 2009 champion) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1144,
    "result": {
      "expected_answer": "Return the finishing rate and the curve score for the player whose weight is the maximum among all players.",
      "sql_description": "Finds the maximum weight in Player, filters to those player(s), joins to all their attribute records, then returns one row (finishing, curve) from Player_Attributes due to LIMIT 1.",
      "reason": "Query applies the required heaviest-weight anchor using MAX(weight) and outputs the requested finishing and curve columns. Although multiple attribute snapshots may exist, the question does not specify a date, so returning any one record for that player is a reasonable interpretation.",
      "verdict": true,
      "evidence": "sql_result columns: finishing, curve; first row values (0): 13, 13."
    }
  },
  {
    "question_id": 743,
    "result": {
      "expected_answer": "Return two figures: 1) the percentage of superheroes whose alignment is 'Bad' (those who act in self-interest/own moral code) out of all superheroes; 2) how many of those 'Bad' superheroes are published by Marvel Comics.",
      "sql_description": "Counts all superheroes with alignment='Bad', divides by total superheroes to get a percentage, and separately counts those same 'Bad' superheroes whose publisher_name is 'Marvel Comics'.",
      "reason": "The query applies the required alignment filter ('Bad'), computes the overall percentage and the Marvel-specific count exactly as asked; all anchors (alignment condition and Marvel publisher) are present.",
      "verdict": true,
      "evidence": "percentage_bad and marvel_bad_count columns returned (row 0: 28.266667%, 118)."
    }
  },
  {
    "question_id": 1014,
    "result": {
      "expected_answer": "For each circuit whose country is Italy, return its lap record (the fastest lap time ever recorded there).",
      "sql_description": "Joins lapTimes with races and circuits, keeps only rows where the circuit country is 'Italy', groups by circuit, and for each circuit returns the minimum milliseconds value as the lap record along with circuit id and name.",
      "reason": "The query honors both anchors: it limits to Italian circuits and derives the lap record as the minimum lap time per circuit. Output columns match what is asked (circuit and its lap record).",
      "verdict": true,
      "evidence": "Rows: [0] circuitId=21, name=\"Autodromo Enzo e Dino Ferrari\", fastest_lap_milliseconds=80411; [1] circuitId=14, name=\"Autodromo Nazionale di Monza\", fastest_lap_milliseconds=81046"
    }
  },
  {
    "question_id": 944,
    "result": {
      "expected_answer": "A single numeric value: the percentage by which the winner’s total race time is shorter than that of the slowest finisher in the 2008 Australian Grand Prix.",
      "sql_description": "1) Finds the raceId of the 2008 Australian Grand Prix.\n2) Retrieves the winner’s finishing time in milliseconds (position = 1).\n3) Retrieves the finishing time of the driver with the largest finishing position whose time is not NULL (i.e., the last classified finisher).\n4) Computes (last − champion) / last * 100 and outputs it as percentage_faster.",
      "reason": "Query uses correct race, winner, and last-finisher anchors, ensures the last driver finished (time IS NOT NULL), employs milliseconds to calculate the required percentage and returns the correct measure. All constraints in the question are respected.",
      "verdict": true,
      "evidence": "Result set contains one column percentage_faster (empty here but logically produced when data present)."
    }
  },
  {
    "question_id": 894,
    "result": {
      "expected_answer": "Return the best (minimum) lap time value and the driver (forename, surname) and the race (name) where that lap time was recorded.",
      "sql_description": "Finds rows in lapTimes whose milliseconds equal the global minimum and returns the corresponding driver's forename, surname, and race name, limited to one row; it does not output the lap-time value itself.",
      "reason": "Query omits the lap-time value explicitly asked for (“What is the best lap time recorded?”). Required anchor (best lap time value) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 988,
    "result": {
      "expected_answer": "The names (optionally with their average pit-stop duration) of the three German drivers born between 1980 and 1985 who have the lowest average pit-stop duration, ordered from shortest to longer.",
      "sql_description": "Computes the average pit-stop duration per driver by joining drivers and pitStops, filters to German nationality and birth years 1980-1985, then orders those averages ascending and returns the first three records (full name plus average).",
      "reason": "All required anchors are satisfied: nationality='German', birth year 1980-1985, average of pit-stop duration, ordering by shortest, and limiting to top 3. Returning avg_duration along with names does not violate the request.",
      "verdict": true,
      "evidence": "sql_result shows columns full_name and avg_duration for 3 rows (row0 Nico Rosberg 23.267592, row1 Adrian Sutil 23.467138, row2 Timo Glock 23.689389), matching the requested output."
    }
  },
  {
    "question_id": 854,
    "result": {
      "expected_answer": "Latitude and longitude (coordinates) of the circuit(s) that host the Australian Grand Prix race.",
      "sql_description": "Finds the circuits linked to races named 'Australian Grand Prix' and returns their lat and lng values.",
      "reason": "Query correctly joins races to circuits, filters for races named 'Australian Grand Prix', and outputs the desired coordinate columns. Duplicates from multiple race years do not violate the requirement.",
      "verdict": true,
      "evidence": "sql_result shows lat=-34.9272, lng=138.617 (columns lat, lng, rows 0-10), matching the circuit location for all Australian Grand Prix entries."
    }
  },
  {
    "question_id": 1001,
    "result": {
      "expected_answer": "Full name(s) of the driver with the fastest (rank-1) Q3 time at the 2008 Marina Bay Street Circuit qualifying.",
      "sql_description": "Finds drivers whose q3 time equals the minimum q3 among all qualifying records for races in 2008 at Marina Bay Street Circuit, then returns the driver’s forename + surname (one row, limit 1).",
      "reason": "Query applies required anchors: circuit name, year 2008, Q3 stage, and chooses the min q3 to identify the 1st-ranked driver. Joins correctly map driver to qualifying to race to circuit. Output is the requested full name, matching the question.",
      "verdict": true,
      "evidence": "sql_result has column full_name; row0 = 'Felipe Massa'."
    }
  },
  {
    "question_id": 769,
    "result": {
      "expected_answer": "Name of the superhero whose durability attribute value is the highest among all superheroes published by \"Dark Horse Comics\".",
      "sql_description": "Joins superhero with publisher, hero_attribute, and attribute; keeps rows where publisher_name = 'Dark Horse Comics' and attribute_name = 'durability'; orders by attribute_value descending and superhero_name ascending; returns the first superhero_name (highest durability).",
      "reason": "All explicit anchors (publisher filter, durability attribute, maximum value via ORDER BY DESC LIMIT 1) are present. The query therefore retrieves the most durable Dark Horse Comics superhero as asked.",
      "verdict": true,
      "evidence": "sql_result columns: [superhero_name]; 0 rows returned (dataset may lack matching data but query logic is correct)."
    }
  },
  {
    "question_id": 906,
    "result": {
      "expected_answer": "The name of the race in which Lewis Hamilton first competed (earliest season he appears) and the number of points he scored in that debut race.",
      "sql_description": "Finds the earliest race (smallest year, then earliest date) where the driver with forename='Lewis' and surname='Hamilton' appears in results, then returns that race’s name, year, date and Hamilton’s points for that race.",
      "reason": "Query anchors on full driver name, selects the earliest race by ascending year/date, and retrieves Hamilton’s points for that race. This satisfies the requirement of identifying his first race and the points he recorded. Extra columns (year, date) are allowed.",
      "verdict": true,
      "evidence": "sql_result shows 1 row with columns: race_name='Malaysian Grand Prix', year=2007, date='2007-04-08', points=8.0."
    }
  },
  {
    "question_id": 726,
    "result": {
      "expected_answer": "A list of Marvel Comics heroes ordered from tallest to shortest, optionally showing their height.",
      "sql_description": "Fetches superhero_name and height_cm for heroes whose publisher is 'Marvel Comics', excludes NULL heights, then orders the rows by height_cm descending (ties broken alphabetically).",
      "reason": "Query applies the requisite Marvel publisher filter and sorts by height descending, fulfilling the ranking requirement; inclusion of height values is allowed.",
      "verdict": true,
      "evidence": "sql_result rows show superhero_name and height_cm columns sorted from 30480 down to 218."
    }
  },
  {
    "question_id": 791,
    "result": {
      "expected_answer": "A single numeric value: the average of height_cm across all superheroes in the table.",
      "sql_description": "Computes the arithmetic average of the column height_cm from every row in superhero (NULLs ignored by AVG).",
      "reason": "The query directly implements the requested calculation—average height of all superheroes—using AVG on height_cm. No anchors are missing or extra constraints added.",
      "verdict": true,
      "evidence": "sql_result shows one column AVG(height_cm) with value 267.751445."
    }
  },
  {
    "question_id": 892,
    "result": {
      "expected_answer": "The full name of the driver who achieved the single highest points value recorded in driverStandings, together with that points value.",
      "sql_description": "Joins drivers with driverStandings, takes the maximum points value per driver, then orders those maxima descending and returns the top driver’s full name and his max points.",
      "reason": "The query’s ordering of per-driver MAX(points) ensures the selected driver owns the global MAX(points) in the table. It returns his full name and the corresponding points, satisfying the request. All required anchors (max points, full name, points value) are present.",
      "verdict": true,
      "evidence": "sql_result row0: full_name='Sebastian Vettel', points=397.0"
    }
  },
  {
    "question_id": 978,
    "result": {
      "expected_answer": "For the country Austria: 1) the number of circuits located there, and 2) for each Austrian circuit, its location name together with its latitude and longitude coordinates.",
      "sql_description": "Counts rows in circuits where country='Austria' and, without grouping, returns that single count together with one arbitrary location, lat and lng.",
      "reason": "The query mixes an aggregate (COUNT) with non-aggregated columns without GROUP BY, so only one location/coordinate is returned (Spielburg) although the count indicates 3 circuits. Thus it fails to provide all Austrian locations and their coordinates as requested.",
      "verdict": false
    }
  },
  {
    "question_id": 533,
    "result": {
      "expected_answer": "A single integer: the number of users whose LastAccessDate is later than 2014-09-01.",
      "sql_description": "Counts all rows in the users table with LastAccessDate > '2014-09-01'.",
      "reason": "The query applies the required date filter and counts users; users table has one row per user, so COUNT(*) gives the needed total.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 5146, fulfilling the requested count."
    }
  },
  {
    "question_id": 1011,
    "result": {
      "expected_answer": "Full names (forename + surname) of the 20 drivers whose fastest recorded lap times are the overall 20 quickest ever in Formula 1 – i.e., one row per driver, ranked by their minimum lap time in milliseconds ascending.",
      "sql_description": "Takes every lap record, sorts all rows by milliseconds ascending and returns the first 20 rows, outputting the associated driver full name. It does not collapse rows by driver, so the same driver can appear many times.",
      "reason": "Question asks for the top-20 drivers (plural) behind the fastest-ever lap records. That implies at most one entry per driver, ordered by each driver’s best lap. The query instead returns the 20 fastest lap *records*, allowing duplicates; only 4–5 distinct drivers appear, while others are omitted. Required distinct-driver anchor is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 904,
    "result": {
      "expected_answer": "The name and year of the race in which Michael Schumacher recorded his single fastest lap (minimum milliseconds across all his race results).",
      "sql_description": "Finds all results for driver Michael Schumacher, orders them by the milliseconds column ascending (fastest), and returns the race name and year for the top-ranked (smallest) milliseconds value.",
      "reason": "All required anchors satisfied: correct driver filtering, uses min(milliseconds) via ORDER BY ASC LIMIT 1, and outputs race name and year. Tie handling is acceptable. Therefore the query answers the question.",
      "verdict": true,
      "evidence": "sql_result columns: name, year – row0: Hungarian Grand Prix | 2006"
    }
  },
  {
    "question_id": 1002,
    "result": {
      "expected_answer": "The forename+surname of the driver with the most recent date of birth, together with that driver’s nationality and the name of the first (earliest‐dated) race he or she competed in.",
      "sql_description": "Finds the driver with the latest dob (youngest). Separately computes, for every driver, the minimum race date but returns an arbitrary race_name from that driver’s results, then joins the two parts to present full_name, nationality and that arbitrary race_name.",
      "reason": "Required anchor: race name of the driver’s first race. Because race_name is not linked to the MIN(date) (it is neither aggregated nor grouped), the query can return a race different from the first one, so the anchor is not guaranteed. Therefore the SQL does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 772,
    "result": {
      "expected_answer": "For every superhero whose gender is Female and whose publisher is Dark Horse Comics, list three attributes: eye colour, hair colour, and skin colour.",
      "sql_description": "The query selects eye_colour, hair_colour, and skin_colour by joining the superhero table to the colour table three times and filters rows where gender = 'Female' and publisher_name = 'Dark Horse Comics'. It outputs those three colour fields for each matching superhero.",
      "reason": "All required anchors (female gender, Dark Horse Comics publisher, and the three colour fields) are explicitly applied, and the selected columns match the requested attributes. Therefore the SQL answers the question correctly.",
      "verdict": true,
      "evidence": "Returned columns: eye_colour, hair_colour, skin_colour. Sample rows: (Green, Blond, No Colour), (Brown, Brown, No Colour) etc., corresponding to female Dark Horse Comics superheroes."
    }
  },
  {
    "question_id": 728,
    "result": {
      "expected_answer": "A ranking of eye colours for Marvel Comics superheroes, showing each eye colour and how many Marvel superheroes have it, ordered from the most common to the least.",
      "sql_description": "Counts superheroes per eye_colour for those whose publisher is 'Marvel Comics', groups by eye colour, and orders the groups by the count descending.",
      "reason": "Query filters on Marvel Comics, groups on eye colour, counts superheroes, and orders by descending count, perfectly matching the requested ranking.",
      "verdict": true,
      "evidence": "Result columns: eye_color, count – first rows: Blue 126, Brown 89, No Colour 47 … correctly sorted by popularity."
    }
  },
  {
    "question_id": 788,
    "result": {
      "expected_answer": "The percentage of Marvel Comics heroes whose gender is Female (i.e., female count within Marvel heroes divided by total Marvel heroes, times 100).",
      "sql_description": "Counts Marvel Comics superheroes, counts those that are also female, divides the latter by the former and multiplies by 100, yielding the share of female heroes among Marvel Comics heroes.",
      "reason": "Adopting the evidence-backed interpretation (percentage of females among Marvel heroes), the query’s numerator and denominator are correct and use the proper joins; therefore it answers the question.",
      "verdict": true,
      "evidence": "sql_result shows a single numeric column with value ≈28.68 indicating the computed percentage."
    }
  },
  {
    "question_id": 563,
    "result": {
      "expected_answer": "Return the FavoriteCount (number of favorites) of the post on which user 3025 left the comment created at 2014/4/23 20:29:39.",
      "sql_description": "Joins posts with comments, keeps the comment whose UserId = 3025 and CreationDate = '2014/4/23 20:29:39.0', then outputs the associated post's FavoriteCount.",
      "reason": "All required anchors (comment user 3025, exact comment timestamp, link to its post) are applied and the query returns the requested FavoriteCount; therefore it directly answers the question.",
      "verdict": true,
      "evidence": "Query selects p.FavoriteCount; the result set contains that column (rows may be empty in sample execution)."
    }
  },
  {
    "question_id": 951,
    "result": {
      "expected_answer": "A single integer: the number of Japanese constructors that have exactly two constructorResults races and scored a total of 0 points in those two races.",
      "sql_description": "For each Japanese constructor, the query checks if they have exactly 2 constructorResults rows and a SUM of points = 0. For every qualifying constructor it outputs the value COUNT(DISTINCT constructorId) inside the grouped query, producing 1 for each qualifying constructor (one row per constructor).",
      "reason": "Grouping by constructorId then selecting COUNT(DISTINCT constructorId) returns 1 per constructor, not the overall count. If multiple constructors satisfy the conditions, the query will return multiple rows of value 1 instead of a single total. Thus it does not reliably answer \"how many\".",
      "verdict": false
    }
  },
  {
    "question_id": 758,
    "result": {
      "expected_answer": "Hair colour(s) of any superhero whose race is 'human' and height_cm = 185.",
      "sql_description": "Joins superhero with colour and race, filters rows where height_cm = 185 and race = 'human', outputs the corresponding hair colour.",
      "reason": "All explicit anchors (height 185, human race, hair colour) are present and correctly used; the selected column is the requested attribute. Logical mapping matches the question.",
      "verdict": true,
      "evidence": "Result set columns: [colour]; 0 rows returned, but logic is sound."
    }
  },
  {
    "question_id": 766,
    "result": {
      "expected_answer": "The full name of the superhero who has the highest strength attribute value (if several tie, any top-strength hero is acceptable).",
      "sql_description": "Joins superhero, hero_attribute, and attribute tables, filters records where attribute_name = 'strength', orders by attribute_value descending and then full_name, and returns the first full_name (highest strength).",
      "reason": "Query correctly targets strength records, ranks by attribute_value to find the maximum, and retrieves the corresponding hero full name; optional tie-breaking by name is acceptable.",
      "verdict": true,
      "evidence": "Query returned 0 rows (column full_name) in provided sample result, but logic matches requirements."
    }
  },
  {
    "question_id": 639,
    "result": {
      "expected_answer": "Percentage = (number of posts authored by the user whose OwnerDisplayName is 'Community' that have the tag exactly equal to 'r') / (total number of posts authored by 'Community') * 100.",
      "sql_description": "Counts distinct posts by Community as denominator. Joins every tag value to posts whose Tags field contains that tag as a substring. Numerator counts distinct Community posts that join to a tag row where TagName = 'r', then divides by total Community posts to give a percentage.",
      "reason": "Anchor failure on the tag match. The ON clause uses the substring pattern \"%r%\", so any post whose Tags text contains the letter \"r\" anywhere (e.g., '<ruby>', '<docker>') is counted as using the R tag, inflating the numerator. Question requires posts whose tag is exactly 'r'.",
      "verdict": false
    }
  },
  {
    "question_id": 565,
    "result": {
      "expected_answer": "Indicate whether the post that received the comment made by user 23853 at 2013-07-12 09:08:18 was well-finished (ClosedDate not null). Return a boolean/flag, e.g., 1 for well-finished, 0 for not.",
      "sql_description": "Finds the comment by user 23853 created at '2013-07-12 09:08:18.0', joins to its post, and outputs 1 if that post's ClosedDate is not NULL, else 0.",
      "reason": "Query uses both required anchors (user id, exact comment timestamp) and correctly evaluates the post’s ClosedDate to decide well-finished status, matching the question’s definition.",
      "verdict": true,
      "evidence": "is_well_finished → 1 (row 0)"
    }
  },
  {
    "question_id": 531,
    "result": {
      "expected_answer": "Identify the one of the two users (Harlan vs. Jarrod Dixon) that has the greater value in the Reputation column; return that winner (optionally with its reputation).",
      "sql_description": "Filters the users table for the two display names, sorts the two records by Reputation descending, and returns the top row (DisplayName and Reputation).",
      "reason": "Query directly compares the two specified users and outputs the single user with the highest reputation, satisfying the comparison request. Presence of LIMIT 1 is acceptable for a winner-take-all question; returning the reputation alongside the name is allowed.",
      "verdict": true,
      "evidence": "row0: DisplayName=Harlan, Reputation=457"
    }
  },
  {
    "question_id": 719,
    "result": {
      "expected_answer": "A single integer: the number of superheroes that both possess the power \"Super Strength\" and have height_cm > 200.",
      "sql_description": "Counts distinct superheroes with the power \"Super Strength\" whose hero_attribute entry where attribute_name = 'Height' has attribute_value > 200.",
      "reason": "Question/evidence explicitly anchors height to the superhero.height_cm column (>200). Predicted SQL ignores height_cm and instead relies on hero_attribute, so it does not satisfy the required anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 683,
    "result": {
      "expected_answer": "A single numeric value representing the percentage of posts created in 2011 whose owner users had a reputation greater than 1000.",
      "sql_description": "The query joins posts with their owners, keeps only posts whose CreaionDate year is 2011, counts how many of those posts have owner reputation > 1000, divides by the total number of selected posts, and multiplies by 100 to produce the percentage.",
      "reason": "All required anchors are met: year filter 2011 on post creation, owner reputation > 1000, ratio over total 2011 posts. Minor ambiguity about posts without owners is acceptable as the question refers to owners explicitly.",
      "verdict": true,
      "evidence": "Result set has one column with the computed percentage (≈51.17)."
    }
  },
  {
    "question_id": 694,
    "result": {
      "expected_answer": "For the post titled 'Analysing wind data with R', list the 10 most recent comments’ text together with the display name of the commenter.",
      "sql_description": "Gets comments joined to the post with that exact title, orders them by CreationDate descending (latest first) with a secondary Id tie-break, and returns Text and UserDisplayName for the first 10 rows.",
      "reason": "All required anchors are met: correct post title filter, returns comment text and user display name, sorted by recency and limited to 10. Ordering via ORDER BY DESC satisfies the ‘latest’ requirement.",
      "verdict": true,
      "evidence": "sql_result shows 10 rows with columns Text and UserDisplayName, matching the requested output."
    }
  },
  {
    "question_id": 736,
    "result": {
      "expected_answer": "The name(s) of the superhero with the lowest Intelligence attribute value (i.e., the dumbest).",
      "sql_description": "Joins superheroes with their Intelligence attribute, orders by attribute_value ascending to bring the lowest (dumbest) first, then returns the first superhero name (ties broken alphabetically).",
      "reason": "Query correctly targets Intelligence attribute, orders to obtain the minimum value, and returns one superhero name as asked. Singular phrasing allows returning one even if ties exist.",
      "verdict": true,
      "evidence": "sql_result shows superhero_name = 'Ammo' in first row, matching the intended selection."
    }
  },
  {
    "question_id": 581,
    "result": {
      "expected_answer": "The display name of the user who owns the post whose title is \"Open source tools for visualizing multi-dimensional data\" (interpreting the stored title as not including a trailing question-mark).",
      "sql_description": "Looks up the post with Title = 'Open source tools for visualizing multi-dimensional data', joins it to users on OwnerUserId = Id, and returns the corresponding users.DisplayName.",
      "reason": "All required anchors are present: it filters by the specified title, links to the owner via OwnerUserId, and returns the owner's DisplayName. The evidence phrase indicates the title does not contain the question mark, so the chosen literal matches that interpretation; thus the SQL logically answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column DisplayName (no rows). Content not used for logic evaluation."
    }
  },
  {
    "question_id": 576,
    "result": {
      "expected_answer": "Display name of the user whose comment text is exactly 'thank you user93!'.",
      "sql_description": "Selects the UserDisplayName from comments where Text equals 'thank you user93!'.",
      "reason": "All required anchors—matching comment text and returning the commenter’s display name—are present. Query logic aligns with the question even though the returned value is NULL in the sample result.",
      "verdict": true,
      "evidence": "sql_result shows column UserDisplayName with value None (row 0), indicating query executed and returned the corresponding display name field."
    }
  },
  {
    "question_id": 710,
    "result": {
      "expected_answer": "The total number of comments whose score is 0 and that belong to posts having exactly one comment.",
      "sql_description": "Joins posts with comments, keeps rows where the post's CommentCount = 1 and the comment's Score = 0, then counts those comments.",
      "reason": "All required anchors are correctly applied: CommentCount = 1 for the parent post, Score = 0 for the comment, and the query counts such comments. This matches the question’s intent.",
      "verdict": true,
      "evidence": "Returned one row with COUNT(*) = 10997."
    }
  },
  {
    "question_id": 571,
    "result": {
      "expected_answer": "A numeric ratio: (number of posts authored by user 24) ÷ (number of votes cast by user 24).",
      "sql_description": "Counts distinct posts whose OwnerUserId = 24 and distinct votes whose UserId = 24, then divides the first count by the second to get the posts-to-votes ratio.",
      "reason": "All required anchors (user id 24, counting posts, counting votes, computing division) are present. DISTINCT prevents double-counting caused by the Cartesian join, so the returned value correctly reflects the desired ratio.",
      "verdict": true,
      "evidence": "sql_result shows column \"1.0 * COUNT(DISTINCT posts.Id) / NULLIF(COUNT(DISTINCT votes.Id), 0)\" with value 0.375."
    }
  },
  {
    "question_id": 595,
    "result": {
      "expected_answer": "List of user IDs whose profile has at least 1000 views (users.Views >= 1000) and where every post they own has exactly one postHistory record (i.e., only a single history entry per post).",
      "sql_description": "Returns user IDs for users whose individual posts (with Post.ViewCount >= 1000) have exactly one related postHistory record. It filters on post view count, not users.Views, and does not ensure the condition across all of a user’s posts.",
      "reason": "Missing required anchor: the 1000-view condition must apply to users.Views, not posts.ViewCount. Additionally, it does not guarantee the one-history condition for all posts of a user, only for the filtered post(s).",
      "verdict": false
    }
  },
  {
    "question_id": 349,
    "result": {
      "expected_answer": "Return the card name and its artist for the card that has the highest number of rulings, plus an indication (Yes/No) of whether that card is a promotional printing (isPromo=1).",
      "sql_description": "Counts rulings for each card by joining cards to rulings, orders the groups by the ruling count descending, keeps the top card (breaking ties by name/uuid), and outputs its name, artist, and a Yes/No flag depending on isPromo.",
      "reason": "Query applies the required anchor (max ruling count) and includes the requested fields (card name, artist, promo flag). Tie-breaking is permissible; promo flag is derived correctly.",
      "verdict": true,
      "evidence": "Returned columns: card_name='Teferi's Protection', artist='Chase Stone', is_promotional_printing='No' (row 0)."
    }
  },
  {
    "question_id": 640,
    "result": {
      "expected_answer": "A single numeric value representing SUM(ViewCount) of Mornington’s posts minus SUM(ViewCount) of Amos’s posts.",
      "sql_description": "Computes total view count for posts whose owner’s DisplayName is 'Mornington', subtracts total view count for posts whose owner’s DisplayName is 'Amos', returning one column view_count_difference.",
      "reason": "Query matches required users via users.DisplayName, sums view counts for each, subtracts, returns the difference; all anchors satisfied.",
      "verdict": true,
      "evidence": "Result: view_count_difference column row0 = -497"
    }
  },
  {
    "question_id": 629,
    "result": {
      "expected_answer": "A single numeric value representing the ratio of the number of votes cast in 2010 divided by the number cast in 2011.",
      "sql_description": "Counts votes from 2010 and 2011, divides the 2010 count by the 2011 count, then multiplies that quotient by 100 to express it as a percentage.",
      "reason": "Query correctly compares 2010 votes to 2011 votes; multiplying by 100 merely expresses the same ratio as a percentage, a reasonable interpretation of “ratio.” All required year filters and the division anchor are present.",
      "verdict": true,
      "evidence": "Returned column shows 130.709968, meaning 2010 votes are about 1.307 times (or 130.7%) those in 2011."
    }
  },
  {
    "question_id": 341,
    "result": {
      "expected_answer": "List of card names whose borderColor is 'borderless' and which do NOT have a \"powerful foil\" version, i.e., where it is NOT true that both cardKingdomFoilId and cardKingdomId are non-NULL (so at least one of those two columns may be NULL).",
      "sql_description": "Returns distinct names of cards with borderColor='borderless' where BOTH cardKingdomId IS NULL AND cardKingdomFoilId IS NULL.",
      "reason": "The query imposes a stricter condition (both IDs NULL) instead of the required negation of the paired-non-NULL condition. Cards that lack a foil (cardKingdomFoilId NULL) but still have a regular CardKingdomId would qualify per the question yet are excluded, making the result incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 598,
    "result": {
      "expected_answer": "A single number: (student badges in 2010 ÷ total student badges)*100 minus (student badges in 2011 ÷ total student badges)*100.",
      "sql_description": "Gets counts of Student badges for 2010 and 2011, then returns 100*(count_2010 − count_2011)/(count_2010 + count_2011).",
      "reason": "Formula anchor violated. Question/evidence requires dividing by the total Student-badge count, but query divides by (count_2010 + count_2011) only, so result is not the requested percentage difference.",
      "verdict": false
    }
  },
  {
    "question_id": 358,
    "result": {
      "expected_answer": "The color of the card border for the card named \"Ancestor's Chosen\" (e.g., black, silver, etc.).",
      "sql_description": "Fetches the borderColor field from cards where name equals 'Ancestor''s Chosen'.",
      "reason": "Correctly filters by the given card name and returns its border color. Returned rows all show 'black', satisfying the question despite duplicates.",
      "verdict": true,
      "evidence": "sql_result shows column borderColor with rows 0-3 all = 'black'."
    }
  },
  {
    "question_id": 687,
    "result": {
      "expected_answer": "An integer count of all comments associated with the post that has the maximum score among posts.",
      "sql_description": "Selects the Id of the single post with the highest Score (ORDER BY Score DESC LIMIT 1) and counts rows in comments whose PostId equals that Id.",
      "reason": "Meets the required anchor (post with highest score) and returns the count of its comments. Using ORDER BY DESC LIMIT 1 is an acceptable way to obtain the max-score post; tie handling is unspecified in the question, so choosing one is reasonable.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 3 (row 0)."
    }
  },
  {
    "question_id": 544,
    "result": {
      "expected_answer": "Display name (text) of the last editor of the post titled \"Examples for teaching: Correlation does not mean causation\".",
      "sql_description": "Selects the LastEditorDisplayName field from posts where the Title exactly matches the target post.",
      "reason": "Query anchors on the specific title and returns the designated display-name column that stores the last editor’s display name; this directly satisfies the question’s requirement.",
      "verdict": true,
      "evidence": "sql_result shows column LastEditorDisplayName with value None (row 0); this is the fetched display name."
    }
  },
  {
    "question_id": 672,
    "result": {
      "expected_answer": "Number of Users located in United Kingdom who have at least one post with FavoriteCount >= 4.",
      "sql_description": "Joins users with their posts, keeps only users whose Location is 'United Kingdom' and posts whose FavoriteCount is 4 or more, then counts distinct user IDs.",
      "reason": "The query enforces the UK location anchor and the FavoriteCount ≥ 4 anchor at post level, then counts distinct users, which satisfies counting users that have qualifying posts.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT u.Id) column with value 14 indicating the number of qualifying users."
    }
  },
  {
    "question_id": 685,
    "result": {
      "expected_answer": "Return two columns: (1) the ViewCount of the post whose content/title is 'Computer Game Datasets'; (2) the DisplayName of the user who most recently posted/created that post (i.e., the latest author among posts with that title).",
      "sql_description": "Finds rows in posts with Title = 'Computer Game Datasets'; joins to users through LastEditorUserId, then sorts by LastEditDate descending and outputs the first row’s ViewCount and the last editor’s DisplayName.",
      "reason": "It relies on LastEditorUserId/LastEditDate, but the question asks for the user who last posted (author), not necessarily the last editor. If the post was never edited or if the latest post’s author differs from the latest editor, the query gives the wrong person or no row at all (inner join). Thus required anchor 'user who last posted the post' is not met.",
      "verdict": false
    }
  },
  {
    "question_id": 440,
    "result": {
      "expected_answer": "List the language(s) appearing in foreign_data.language for the card whose cards.name is 'A Pedra Fellwar'.",
      "sql_description": "Joins cards and foreign_data on uuid, filters rows where cards.name = 'A Pedra Fellwar', and returns the corresponding foreign_data.language values.",
      "reason": "Uses the correct card name anchor and retrieves the requested language field; satisfies query intent even if no rows are present in sample data.",
      "verdict": true,
      "evidence": "sql_result columns: [language]; 0 rows returned."
    }
  },
  {
    "question_id": 716,
    "result": {
      "expected_answer": "The percentage (0–100 scale) of users whose UpVotes = 0 among those users who have written at least one comment with a score between 5 and 10 (inclusive).",
      "sql_description": "Filters comments with Score between 5 and 10, gathers the distinct UserIds involved, counts how many of those users have UpVotes = 0, divides by the total distinct users in that set, and multiplies by 100 to return the percentage.",
      "reason": "All required anchors are satisfied: score range filter, join to users for UpVotes, computation of percentage. Interprets question as user-level (distinct users), which is a reasonable reading and not contradicted by the evidence. Returned scalar matches requested metric.",
      "verdict": true,
      "evidence": "sql_result shows one column 'percentage' with value 4.87013 (row 0)."
    }
  },
  {
    "question_id": 587,
    "result": {
      "expected_answer": "For every post whose Tags include '<humor>', provide: 1) the post title, 2) each of its comments’ text, and 3) that post’s average view-count (which is effectively the view count because each post has a single ViewCount value).",
      "sql_description": "Joins posts with their comments, keeps only rows where the post’s Tags contain '<humor>', then groups by post id, title and each individual comment text; for each such group it outputs the title, the comment text, and AVG(ViewCount) which collapses to the post’s ViewCount.",
      "reason": "All required anchors are present – humor-tag filter, title, comment text, and a numeric average of ViewCount per post. Although grouping by comment text repeats the same average for each comment, duplicates are allowed and do not violate the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows columns Title, Text, AverageViewCount with multiple rows (one per comment) and correct averages (e.g., same 288.0 for all comments of first post)."
    }
  },
  {
    "question_id": 345,
    "result": {
      "expected_answer": "Return the legality status (e.g., Legal, Banned, Restricted) for every card whose types include Artifact and that has no value in side (single-face), specifically for the Vintage play format.",
      "sql_description": "Joins cards with legalities and outputs l.status where the card's types is exactly 'Artifact', side is NULL (single face), and the legality record is for format = 'vintage'.",
      "reason": "Query applies all required anchors—artifact cards (types filter), no multiple faces (side IS NULL), vintage format (l.format filter)—and returns their legality status. Duplicates are harmless; question didn’t forbid them.",
      "verdict": true,
      "evidence": "sql_result shows column status with 20 rows, all 'Legal' (rows 0-19)."
    }
  },
  {
    "question_id": 586,
    "result": {
      "expected_answer": "Display name(s) of user(s) who awarded a bounty of 50 on any post whose title contains the word \"variance\".",
      "sql_description": "Gets users from users joined to votes where BountyAmount=50 and the associated post's Title contains 'variance'; outputs their DisplayName.",
      "reason": "Query includes required anchors: bounty amount = 50 in votes and post titles containing 'variance'; returns corresponding user display names, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows DisplayName column with rows 0: 'chl', 1: 'shabbychef'."
    }
  },
  {
    "question_id": 473,
    "result": {
      "expected_answer": "A boolean yes/no stating whether every set that contains the card named \"Adarkar Valkyrie\" is marked isForeignOnly = 1 (i.e., only available outside the United States).",
      "sql_description": "Joins cards and sets, filters to rows with name = 'Adarkar Valkyrie' that belong to sets where isForeignOnly = 0, counts them, and returns 1 (true) if the count is zero, else 0 (false). Thus it answers: \"true\" when all such sets are foreign-only, \"false\" otherwise.",
      "reason": "The query directly tests for the existence of any non-foreign-only set containing the specified card; this precisely resolves whether the card is exclusively in foreign-only sets. No required anchor is missing.",
      "verdict": true,
      "evidence": "Result column is_foreign_only = 0 (row 0) → at least one non-foreign-only set exists, so answer is \"No\"."
    }
  },
  {
    "question_id": 352,
    "result": {
      "expected_answer": "Percentage (0–100) of distinct cards that have at least one foreign_data entry with language = 'Chinese Simplified' divided by the total number of distinct cards.",
      "sql_description": "Counts distinct foreign_data rows whose language is Chinese Simplified and divides by the count of distinct cards, multiplying by 100.",
      "reason": "Numerator is based on DISTINCT fd.id (foreign_data rows), not on DISTINCT cards/uuid, so cards having multiple Chinese rows are over-counted. This violates the required anchor of counting each card once.",
      "verdict": false
    }
  },
  {
    "question_id": 634,
    "result": {
      "expected_answer": "Return the name (Harvey Motulsky or Noah Snyder) whose posts collectively have the larger total view count.",
      "sql_description": "Filters posts to those owned by the two specified users, groups rows by owner, sums their ViewCount, orders the owners by that sum descending, and returns the top owner name.",
      "reason": "Captures required anchor (posts by the two owners) and correctly compares total view counts, returning only the higher one; output column matches the requested information.",
      "verdict": true,
      "evidence": "Query returns column OwnerDisplayName; logical steps align with MAX(SUM(ViewCount)) specification even though current dataset returns 0 rows."
    }
  },
  {
    "question_id": 405,
    "result": {
      "expected_answer": "A single integer: the number of sets whose block is 'Commander' and that have a translation entry in Brazilian Portuguese ('Portuguese (Brasil)').",
      "sql_description": "Joins sets with set_translations, filters rows where language = 'Portuguese (Brasil)' and block = 'Commander', then counts distinct set codes.",
      "reason": "All required anchors (block = Commander, language = Portuguese (Brasil), count of sets) are correctly enforced, and duplicates are removed with DISTINCT. Therefore the query returns the desired count.",
      "verdict": true,
      "evidence": "Result has one column COUNT(DISTINCT st.setCode) with value 0."
    }
  },
  {
    "question_id": 198,
    "result": {
      "expected_answer": "A single scalar value: the overall average number of single bonds (bond_type = '-') per atom across all carcinogenic molecules (label = '+'). Numerator = total single-bond rows of those molecules; denominator = total atoms in those molecules (regardless of their own bonds).",
      "sql_description": "Joins atom→molecule→connected→bond, keeps only single-bond rows (b.bond_type='-'); counts those rows for the numerator and divides by the number of DISTINCT atoms that appear in those single-bond rows.",
      "reason": "By filtering on b.bond_type='-' in the WHERE clause, the query excludes atoms that are in carcinogenic molecules but are not part of any single bond, so the denominator is incomplete. The required anchor ‘COUNT of all atoms in carcinogenic molecules’ is not satisfied, leading to an inflated average.",
      "verdict": false
    }
  },
  {
    "question_id": 215,
    "result": {
      "expected_answer": "The total number of distinct atoms whose element is iodine ('i') or sulfur ('s') that participate in at least one single bond (bond_type = '-')",
      "sql_description": "Finds atoms with element 'i' or 's', joins through the connected table to bonds, keeps only rows where the bond is of single type '-', then counts distinct atom_ids.",
      "reason": "Satisfies all anchors: filters for iodine/sulfur atoms, restricts to single bonds, counts distinct atom IDs as required.",
      "verdict": true,
      "evidence": "sql_result shows one row with COUNT(DISTINCT a.atom_id)=80"
    }
  },
  {
    "question_id": 412,
    "result": {
      "expected_answer": "Return the foreign name(s) (foreign_data.name) in French of all cards illustrated by Matthew D. Wilson whose card entry is a creature card (type contains \"Creature\"), has layout \"normal\" and border color \"black\".",
      "sql_description": "Fetches foreign_data.name where foreign_data.language is French and the joined card record has artist Matthew D. Wilson, layout normal, borderColor black, and type exactly equal to \"Creature\".",
      "reason": "The query hard-matches c.type = 'Creature'. In MTGJSON the type field almost always contains additional subtype text (e.g. \"Creature — Human Wizard\"). Requiring exact equality will exclude those legitimate creature cards, so the query is too restrictive and risks returning an empty or incomplete answer, violating the type anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 344,
    "result": {
      "expected_answer": "Names of all card printings whose rarity is mythic and whose legality status is \"Banned\" in the gladiator format.",
      "sql_description": "Joins cards to their legalities, filters rows to rarity = 'mythic', format = 'gladiator', status = 'Banned', and returns the distinct card names.",
      "reason": "The query applies all anchors (rarity mythic, format gladiator, status banned) and outputs the requested names. No extra or missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows column name (name) with two rows: 0 Oko, Thief of Crowns; 1 Nexus of Fate – both mythic cards banned in gladiator."
    }
  },
  {
    "question_id": 459,
    "result": {
      "expected_answer": "Identify which of the two cards – Serra Angel or Shrine Keeper – has the higher convertedManaCost (optionally show its cost).",
      "sql_description": "Fetches both cards’ convertedManaCost values, orders the two rows by cost descending, and returns the first – i.e., the card with the larger convertedManaCost.",
      "reason": "Query compares the two specified cards on convertedManaCost and returns the higher-cost one, satisfying the comparison request. Tie-handling is acceptable because the question does not specify, and both card names are explicitly filtered.",
      "verdict": true,
      "evidence": "Result row 0: name='Serra Angel', convertedManaCost=5.0 – returned as the higher cost card."
    }
  },
  {
    "question_id": 483,
    "result": {
      "expected_answer": "A list (one row per card) containing the Italian rules text (fd.text) for every card that belongs to the set named \"Coldsnap\".",
      "sql_description": "Finds every card whose setCode links to a set with name 'Coldsnap', joins to its foreign_data rows in Italian, keeps only non-null text, and returns that text column.",
      "reason": "Query applies the required anchors (set name Coldsnap, language Italian) and outputs the requested field (Italian rules text). No extraneous constraints; returning fd.text satisfies the listing request.",
      "verdict": true,
      "evidence": "sql_result shows one column `text` with 20 Italian rule texts (rows 0-19), indicating the query retrieved the intended data."
    }
  },
  {
    "question_id": 637,
    "result": {
      "expected_answer": "A list of every distinct tag appearing in posts authored by the user whose DisplayName is \"Mark Meckes\" where those posts have CommentCount = 0.",
      "sql_description": "Finds posts whose owner’s DisplayName is Mark Meckes and whose CommentCount is 0, matches each post’s <tag> string against the tags table, and returns the distinct TagName values.",
      "reason": "All required anchors are present: author identified by DisplayName, CommentCount = 0 filter applied, and the query extracts the tag names tied to those posts. The LIKE condition with <tag> delimiters correctly captures tags, so the result set corresponds to the requested tags.",
      "verdict": true,
      "evidence": "sql_result shows one row: books (column TagName row 0), consistent with expected output type."
    }
  },
  {
    "question_id": 231,
    "result": {
      "expected_answer": "Return the bond type that appears most frequently among all bonds for molecule TR010, together with TR010’s carcinogenic label (+ for carcinogenic, - for not).",
      "sql_description": "Counts bonds for molecule TR010, orders bond types by descending frequency, selects the top one, and outputs that bond type along with the molecule’s label (carcinogenic status).",
      "reason": "Query filters to TR010, aggregates counts by bond_type, chooses the highest-count type, and retrieves the molecule’s carcinogenic flag. This fulfills both requested items.",
      "verdict": true,
      "evidence": "row0: bond_type='-', is_carcinogenic='-'"
    }
  },
  {
    "question_id": 530,
    "result": {
      "expected_answer": "For every card illustrated by Allen Williams, return its frameVersion (frame style) and card name, and indicate whether the card is banned (if any cards are banned they should be identifiable).",
      "sql_description": "Retrieves all rows from cards where artist = 'Allen Williams'; left-joins to legalities only on records whose status = 'Banned'. Returns frameVersion, card name, and the banned status (NULL when not banned).",
      "reason": "All required anchors are present: artist filter, inclusion of frameVersion and card name, detection of banned status via legalities. Output allows identification of any banned cards; NULL status indicates none. Thus the query satisfies the question.",
      "verdict": true,
      "evidence": "Result columns: frameVersion, name, status. 20 rows shown; status column is NULL for every row, indicating Allen Williams has no banned cards."
    }
  },
  {
    "question_id": 474,
    "result": {
      "expected_answer": "Number of distinct sets that contain at least one card with an Italian translation and whose baseSetSize is below 10.",
      "sql_description": "Joins cards, their Italian foreign data, and sets then counts DISTINCT card uuids that meet language='Italian', fd.text NOT NULL, and baseSetSize<10.",
      "reason": "Question asks for a count of sets, but the query counts cards (distinct c.uuid). Anchor on counting sets is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 244,
    "result": {
      "expected_answer": "Return whether the molecule that has the greatest number of double bonds (bond_type = '=') is carcinogenic (label '+'). A boolean / 1-0 / yes-no result is fine.",
      "sql_description": "Counts bonds whose bond_type is ' = ' (space-equals-space) per molecule, picks the molecule with the highest count, and outputs 1 if its label is '+', else 0.",
      "reason": "Key anchor mis-matched: bond_type comparison should be '=' but query uses ' = ', so double-bond rows are not found; result set is empty, so the question is unanswered.",
      "verdict": false
    }
  },
  {
    "question_id": 682,
    "result": {
      "expected_answer": "The ID and owner display name of the post created in 2010 that has the highest FavoriteCount (i.e., the single most ‘valuable’ post of that year).",
      "sql_description": "Gets all posts whose CreaionDate year is 2010, orders them by FavoriteCount descending (ties broken by Id), and returns the first row with its Id and OwnerDisplayName.",
      "reason": "Query applies the correct 2010 year filter, ranks by FavoriteCount to find the maximum, and outputs the required columns. No necessary anchor is missing.",
      "verdict": true,
      "evidence": "Returned columns: Id (row 0 = 1595) and OwnerDisplayName (row 0 = None)."
    }
  },
  {
    "question_id": 263,
    "result": {
      "expected_answer": "The percentage of atoms that are chlorine (element = 'cl') among all atoms that participate in single bonds (bond_type = '-') across the whole database.",
      "sql_description": "Counts chlorine atoms that appear in connected.atom_id for single bonds and divides by the count of DISTINCT atom_id in that position, multiplying by 100.",
      "reason": "It ignores atoms that appear only in connected.atom_id2, so both numerator and denominator omit part of the population. This violates the requirement to consider all atoms involved in single bonds, not just those stored in one column of the connection table.",
      "verdict": false
    }
  },
  {
    "question_id": 12,
    "result": {
      "expected_answer": "A single numeric value representing the maximum ratio Free Meal Count (Ages 5-17) / Enrollment (Ages 5-17) among schools whose SAT excellence rate (NumGE1500 / NumTstTakr) exceeds 0.3.",
      "sql_description": "Joins frpm and satscores on school code, filters schools where NumGE1500 / NumTstTakr > 0.3, computes each school’s free-meal rate for ages 5-17, and returns the maximum of these rates.",
      "reason": "All required anchors are present: excellence rate filter >0.3 and calculation of the 5-17 free-meal rate, then max aggregation. No extraneous conditions. Even if no rows satisfy the filter (resulting in NULL), the query logically answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column highest_eligible_free_rate with value None, indicating no qualifying schools; still consistent with query intent."
    }
  },
  {
    "question_id": 253,
    "result": {
      "expected_answer": "For every bond whose bond_type is '#', return the element symbol of each of the two atoms that participate in that bond (i.e., the pair of element names for each triple bond).",
      "sql_description": "Joins connected → bond to keep only rows whose bond_type = '#', then joins each atom id in the connection to the atom table and outputs DISTINCT (a1.element, a2.element) pairs.",
      "reason": "The query correctly filters bonds to triple bonds (#) and retrieves the element of each of the two connected atoms, producing one row per ordered pair. Although both orientations of the same bond may appear, the question does not forbid such duplication, and all requested information is present.",
      "verdict": true,
      "evidence": "sql_result rows: (n,c), (c,n), (y,p), (p,y) – columns element, element show the two elements for every triple bond."
    }
  },
  {
    "question_id": 366,
    "result": {
      "expected_answer": "The rules text printed on the card “Benalish Knight” (its abilities/effects).",
      "sql_description": "Looks up the card’s uuid, then returns every ruling text from the rulings table for that uuid.",
      "reason": "Question asks for the card’s own rules text, stored in cards.text, not the separate rulings. The query therefore targets the wrong information and omits the card text; result can be empty even though the card has rules.",
      "verdict": false
    }
  },
  {
    "question_id": 415,
    "result": {
      "expected_answer": "The percentage (0–100) of cards whose legality entry shows format = 'commander' and status = 'legal' that have hasContentWarning = 0.",
      "sql_description": "Joins cards to legalities on uuid, keeps rows where format is 'commander' and status is 'legal', counts how many of those rows have hasContentWarning = 0 and divides by the total row count, multiplying by 100 to get a percentage.",
      "reason": "All required anchors (format = commander, status = legal, hasContentWarning check, percentage computation) are present; duplicates, nulls, and DISTINCT are not mandated by the question and do not alter the ratio materially. Therefore the query answers the question correctly.",
      "verdict": true,
      "evidence": "Output includes a single numeric column labeled 100.0 * COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) / COUNT(*), row 0."
    }
  },
  {
    "question_id": 347,
    "result": {
      "expected_answer": "For every card whose artist is Stephen Daniele, list the card id together with each associated ruling text, and indicate whether the card has missing/degraded properties (hasContentWarning = 1 -> Yes, else No).",
      "sql_description": "Selects card id from cards where artist = 'Stephen Daniele', joins to rulings on uuid to fetch ruling text, and flags cards whose hasContentWarning = 1 with 'Yes', otherwise 'No'.",
      "reason": "Query filters by the intended artist, retrieves ruling texts via rulings table, and reports the requested Yes/No flag based on hasContentWarning, matching all stated requirements.",
      "verdict": true,
      "evidence": "Returned columns: id, text, has_missing_or_degraded_properties; 20 rows shown with cards like id 29, 3872, etc., each having ruling text and No/Yes flag."
    }
  },
  {
    "question_id": 391,
    "result": {
      "expected_answer": "Names of cards whose original type is Artifact, whose color list includes only black (value 'B'), and that have at least one entry in foreign_data (i.e., a foreign-language translation).",
      "sql_description": "Joins cards with foreign_data, keeping rows where originalType equals 'Artifact', colors equals 'B', and the joined foreign_data row has a non-NULL language; returns the card name column.",
      "reason": "All required anchors—artifact type, black color, existence of foreign translation—are explicitly filtered. Duplicates from multiple languages do not violate the question. Query therefore satisfies the request.",
      "verdict": true,
      "evidence": "sql_result shows names column with values such as 'Executioner\\'s Capsule' and 'Immortal Coil', confirming artifact, black, with translations."
    }
  },
  {
    "question_id": 40,
    "result": {
      "expected_answer": "The phone number of the Fresno Unified school that has the lowest average SAT reading score.",
      "sql_description": "Joins schools with SAT scores, keeps only rows where district name equals 'Fresno Unified', sorts by AvgScrRead ascending, and returns the Phone of the first (lowest-scoring) school.",
      "reason": "All required anchors are present: district filter, reading score used for ordering, phone number selected, and minimum chosen with LIMIT 1. Thus the query answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column Phone = '(559) 490-4290'."
    }
  },
  {
    "question_id": 465,
    "result": {
      "expected_answer": "Whether at least one printing of the card named \"Ancestor's Chosen\" has an entry in foreign_data with language 'Korean' (i.e., a Korean version exists). Return yes/no or equivalent boolean.",
      "sql_description": "Counts rows where cards.name = 'Ancestor''s Chosen' and a linked foreign_data row has language 'Korean'; returns true if count > 0, else false.",
      "reason": "Query checks the required card name and language anchors exactly and outputs a boolean existence indicator, matching the yes/no question.",
      "verdict": true,
      "evidence": "sql_result shows has_korean_version column with value 0, demonstrating the query executed as intended and produced the expected boolean indicator."
    }
  },
  {
    "question_id": 402,
    "result": {
      "expected_answer": "Return the percentage of cards that are Story Spotlight AND have no text box (isStorySpotlight = 1 and isTextless = 1) relative to all Story Spotlight cards, and list the ids of those text-box-less cards.",
      "sql_description": "Counts Story Spotlight cards where isTextless = 0, divides by all Story Spotlight cards to give a percentage, and outputs that percentage along with each id having isTextless = 0.",
      "reason": "The query uses isTextless = 0, which corresponds to cards WITH a text box according to the schema, not cards without one. Thus both the percentage and the id list target the wrong subset and do not answer the question requirements.",
      "verdict": false
    }
  },
  {
    "question_id": 46,
    "result": {
      "expected_answer": "The school(s) under DOC = 31 (State Special Schools) that serve grades 1-12 and have the largest total K-12 enrollment – i.e., the enrollment leader(s) among those schools.",
      "sql_description": "Joins schools with frpm, keeps rows where schools.DOC = '31' and frpm.Low Grade <= '1' and frpm.High Grade >= '12', sums Enrollment (K-12) per school, and lists every such school ordered by that sum descending.",
      "reason": "The grade filter relies on a lexical comparison to the string '1'. Rows whose Low Grade is coded as 'K' (or other text preceding grade 1) fail the ‘<= ‘‘1’’’ test, so state special schools that start at Kindergarten – such as the California School for the Deaf campuses – are wrongly excluded. Consequently the query may omit the true highest-enrollment school, as suggested by the solitary result of 60 students, far below known Deaf-school enrollments. Because a required anchor (include all schools serving grades 1-12, regardless of whether they also serve K) is mishandled, the answer set is incomplete and the “highest” determination is unreliable.",
      "verdict": false
    }
  },
  {
    "question_id": 528,
    "result": {
      "expected_answer": "For every card that belongs to the Magic set named \"Hour of Devastation\", list the card’s name along with each play format where that card’s legality status is \"Legal\".",
      "sql_description": "Fetches cards whose setCode matches the code of the set whose name is 'Hour of Devastation', joins those cards to the legalities table on uuid, filters legalities to rows where status = 'Legal', and returns the card name plus the associated format.",
      "reason": "All required anchors are present: it restricts to the set name, returns card names, and filters formats to those with status 'Legal'. Output columns correspond exactly to the requested information.",
      "verdict": true,
      "evidence": "Rows like (name='Abandoned Sarcophagus', format='commander') and (name='Abrade', format='legacy') demonstrate card-format legality pairs."
    }
  },
  {
    "question_id": 218,
    "result": {
      "expected_answer": "Percentage of molecules labeled as carcinogenic (+) whose atoms list contains no fluorine element, expressed as 0-100%.",
      "sql_description": "Identifies all carcinogenic molecules, identifies which of them have at least one fluorine atom, subtracts that count from total carcinogenic count, divides by total carcinogenic count and multiplies by 100 to give the percentage without fluorine.",
      "reason": "SQL applies the label '+' filter, checks fluorine presence per molecule with distinct molecule ids, computes (total – with_F)/total *100; thus directly answers the asked percentage of carcinogenic molecules lacking fluorine.",
      "verdict": true,
      "evidence": "sql_result shows one row with column percentage ≈99.34 (percentage column)."
    }
  },
  {
    "question_id": 95,
    "result": {
      "expected_answer": "Account_id(s) of every client who is (1) the youngest among all clients (latest birth_date) AND (2) whose district reaches the highest average salary (max A11). If several clients satisfy both extrema, all their account numbers should be listed.",
      "sql_description": "Builds a list of (client_id, birth_date, avg_salary) for owner-clients, orders it by birth_date DESC then avg_salary DESC, keeps only the first row (LIMIT 1), and returns all owner accounts of that single client.",
      "reason": "It applies LIMIT 1, so it may discard other clients that are equally youngest and/or tie on highest salary. It also does not guarantee that the retained client’s salary is the overall maximum—it only breaks ties among equally youngest clients. Therefore required anchors ‘all youngest clients’ and ‘overall highest average salary’ are not fully met.",
      "verdict": false
    }
  },
  {
    "question_id": 115,
    "result": {
      "expected_answer": "A numeric percentage (0–100) representing the proportion of male clients among all clients whose branch is in the South Bohemia region and which has the highest number of inhabitants (A4) among those branches.",
      "sql_description": "1) Picks the district in district table where region (A3) = 'south Bohemia' with the largest inhabitants value (A4). 2) Retrieves all clients linked to that district. 3) Computes 100 * (number of clients whose gender = 'M') / (total clients) and returns it as male_percentage.",
      "reason": "Query applies the required region filter, selects the single district with the maximum inhabitants, links clients through district_id, and calculates the requested male-client percentage exactly per the formula. All explicit anchors are satisfied; no contradictory constraints.",
      "verdict": true,
      "evidence": "sql_result shows a single column male_percentage with value 40.0."
    }
  },
  {
    "question_id": 149,
    "result": {
      "expected_answer": "All disposition/account types other than OWNER (i.e., types not eligible for loans) for accounts whose district average salary (A11) is greater than 8000 and at most 9000.",
      "sql_description": "Selects distinct disp.type where type is not 'OWNER' and the linked account’s district has A11 > 8000 and <= 9000.",
      "reason": "Matches the non-eligibility condition (type != 'OWNER') and the salary range, then returns the set of such types. No required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows one row: type = 'DISPONENT'."
    }
  },
  {
    "question_id": 371,
    "result": {
      "expected_answer": "A single numeric percentage: (number of Story Spotlight cards that have French language) divided by (total number of Story Spotlight cards) × 100.",
      "sql_description": "Counts distinct Story-Spotlight cards after INNER JOIN to foreign_data; numerator counts those whose joined language is French; denominator counts those that have at least one foreign_data row (any language).",
      "reason": "The denominator must include every Story Spotlight card. Using an INNER JOIN limits the base to cards present in foreign_data, omitting any Spotlight cards lacking foreign_data rows. This violates the required anchor of considering all Story Spotlight cards, so the percentage can be wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 529,
    "result": {
      "expected_answer": "List of set names where a Korean translation exists in set_translations but no Japanese translation exists for that same set.",
      "sql_description": "Joins each set to any Japanese translation rows and any Korean translation rows, then keeps only those sets that have at least one Korean row (st_kr.id IS NOT NULL) and no Japanese rows (st_jp.id IS NULL). Returns the set name.",
      "reason": "The SQL enforces both anchors: presence of a Korean translation and absence of any Japanese translation for the same set. This matches the question’s requirements.",
      "verdict": true,
      "evidence": "sql_result shows column [name] with 0 rows, indicating no sets currently satisfy the conditions; logic is still correct."
    }
  },
  {
    "question_id": 192,
    "result": {
      "expected_answer": "The mean approved loan amount for loans that are still running (status C or D) belonging to accounts that have at least one transaction whose k_symbol is 'POPLATEK PO OBRATU' (fee for statement issuance after transaction). Each loan should be counted once in the average.",
      "sql_description": "Joins loan with its account’s transactions, keeps rows where the loan status is C or D and the transaction k_symbol equals 'POPLATEK PO OBRATU', then takes AVG(loan.amount) over the resulting joined rows.",
      "reason": "Because the join keeps one row per matching transaction, loans that incur the fee multiple times are repeated, so their amounts are over-weighted in the average. The query therefore does not compute the average per loan but a transaction-weighted average, violating the required anchor of counting each running loan once.",
      "verdict": false
    }
  },
  {
    "question_id": 281,
    "result": {
      "expected_answer": "A list of element symbols with the number of carcinogenic molecules whose 4th atom (identified via substr(atom_id,7,1)='4') is that element.",
      "sql_description": "Joins atoms to molecules, keeps only molecules labeled '+', selects atoms whose id indicates they are the 4th atom, groups these by element and counts them.",
      "reason": "All required anchors are present: carcinogenic label '+', 4th-atom selector via substring, grouping and counting by element. This directly produces the requested tally.",
      "verdict": true,
      "evidence": "sql_result columns: element, tally (e.g., row0 element='br', tally=6; row1 element='c', tally=145 …)."
    }
  },
  {
    "question_id": 207,
    "result": {
      "expected_answer": "The set of chemical element symbols of atoms that participate in at least one double bond (bond_type = '=').",
      "sql_description": "Finds all atoms linked through the connected table to bonds whose type is '=', then returns the distinct element symbols of those atoms.",
      "reason": "Query correctly filters bonds with bond_type '=' and returns distinct element symbols of associated atoms, matching the requested information.",
      "verdict": true,
      "evidence": "sql_result shows column element with rows: c, o, n, s, ca, which aligns with expected list format."
    }
  },
  {
    "question_id": 462,
    "result": {
      "expected_answer": "Italian translation(s) of the set name(s) that include the card \"Ancestor's Chosen\".",
      "sql_description": "Finds every set containing the card named 'Ancestor's Chosen', then returns the translation field from set_translations where language = 'Italian'.",
      "reason": "Query applies the required card-name filter and language='Italian', joins through the set code, and outputs the translated set names; this fulfills the question.",
      "verdict": true,
      "evidence": "sql_result rows: translation -> 'Set Base Decima Edizione' (row 0,1), 'Sentenza' (row 2)."
    }
  },
  {
    "question_id": 17,
    "result": {
      "expected_answer": "A list of schools whose average SAT Writing score exceeds 499, ordered from highest to lowest average writing score, displaying each school’s charter number (non-NULL).",
      "sql_description": "Joins satscores with schools, keeps rows where AvgScrWrite > 499 and CharterNum is not NULL, returns School, CharterNum and AvgScrWrite, ordering by AvgScrWrite descending (i.e., ranking).",
      "reason": "All required anchors are satisfied: filters on writing score > 499, ensures charter numbers are present, and orders results to provide a ranking. Columns include the charter number as requested.",
      "verdict": true,
      "evidence": "sql_result rows show columns School, CharterNum, AvgScrWrite, sorted 630→535 etc."
    }
  },
  {
    "question_id": 239,
    "result": {
      "expected_answer": "The count of distinct bonds that involve any atom whose atom_id ends with '_19' (i.e., atom 19 of any molecule).",
      "sql_description": "Counts distinct bond_id in connected where atom_id or atom_id2 is exactly the string 'TR%_19'.",
      "reason": "Question requires matching any atom_id like 'TR%_19'; predicted SQL uses equality, not LIKE, so it misses all valid rows and returns 0, violating required anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 249,
    "result": {
      "expected_answer": "The element symbols (e.g., c, h, o, etc.) of both atoms that are connected by the bond whose bond_id is TR144_8_19.",
      "sql_description": "Looks at the connected table for the row with bond_id = 'TR144_8_19', joins to the atom table on either atom_id column, and returns the element field of those atoms (duplicates possible).",
      "reason": "Uses the correct bond_id anchor and retrieves the element of each atom involved; extra duplicate rows do not contradict the question, which does not demand distinctness.",
      "verdict": true,
      "evidence": "Returned rows: element -> [h, c, h, c] – the set {h, c} are the elements for the two atoms."
    }
  },
  {
    "question_id": 24,
    "result": {
      "expected_answer": "A list of school names where: 1) the proportion of students eligible for free meals in K-12 exceeds 0.1 (10%), and 2) the school has at least one SAT test taker whose total score is 1500 or higher.",
      "sql_description": "Joins schools with the FRPM and SAT tables by CDS code, filters rows where (Free Meal Count / Enrollment) > 0.1 and NumGE1500 > 0, and returns the School field.",
      "reason": "Both required anchors—free-meal eligibility rate > 0.1 and presence of SAT ≥1500 scorers—are explicitly enforced. Output is the requested school names; no missing or contradictory constraints.",
      "verdict": true,
      "evidence": "sql_result shows School column with 20 rows, e.g., FAME Public Charter, Alameda High, Berkeley High (row indices 0-19)."
    }
  },
  {
    "question_id": 522,
    "result": {
      "expected_answer": "For every card whose edhrecRank equals 1, return the card’s name together with each play format in which that card is banned.",
      "sql_description": "Finds all cards where edhrecRank = 1, joins to the legalities table, filters rows whose status is 'Banned', and outputs the card name and the corresponding banned format.",
      "reason": "The query applies the required anchors (edhrecRank = 1 and status = 'Banned') and returns exactly the requested columns (card name and banned format). Extra duplicates do not contradict the question.",
      "verdict": true,
      "evidence": "sql_result shows rows like (name='Sol Ring', format='duel') and (name='Sol Ring', format='legacy'), demonstrating the query lists banned formats for the edhrecRank-1 card."
    }
  },
  {
    "question_id": 197,
    "result": {
      "expected_answer": "A single numeric value: the mean count of oxygen (element = 'o') atoms per molecule among molecules that have at least one single bond (bond_type='-').",
      "sql_description": "For each molecule that has a single bond, it computes AVG(CASE WHEN element='o' THEN 1 ELSE 0 END) over the joined atom rows, producing the fraction of atoms that are oxygen for that molecule. Because of GROUP BY molecule_id, the query returns one ratio per molecule, not an overall average, and it returns a proportion rather than the count of oxygen atoms.",
      "reason": "1) It returns multiple rows (per-molecule) instead of a single overall average.\n2) It calculates the proportion of oxygen atoms, not the count; thus the metric is wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 173,
    "result": {
      "expected_answer": "Return two pieces of information for account_id = 3: (1) the number of transactions that correspond to a request for an account-statement release, and (2) the k_symbol (purpose) associated with the transaction(s) whose total debited amount equals 3539.",
      "sql_description": "Counts rows in trans where account_id = 3 and operation = 'STATEMENT RELEASE'; then fetches (only the first) k_symbol from a row where account_id = 3 and amount = 3539, regardless of debit/credit direction.",
      "reason": "The query anchors on operation = 'STATEMENT RELEASE', which is not part of the documented operation values and is unlikely to represent statement-release requests (these are indicated by k_symbol = 'SLUZBY'). Thus the first answer part is based on an incorrect or non-existent condition, giving 0 instead of the true count. The second part ignores whether the 3539 transaction is a debit (type = 'VYDAJ') and arbitrarily picks one row with LIMIT 1, so it may miss the correct ‘aim’. Required anchors (correct identification of statement-release transactions and debit direction) are not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 201,
    "result": {
      "expected_answer": "The percentage of atoms that are carbon (element = 'c') among all atoms involved in double-bond (bond_type = '=') connections.",
      "sql_description": "Finds all distinct atom_ids that appear in any bond whose type is '=', then computes 100 * (number of those atoms whose element is 'c') divided by the total number of such distinct atoms.",
      "reason": "Query correctly filters bonds of type '=', gathers the associated atoms through the connected table, deduplicates atom_ids, and calculates the carbon share as a percentage. This matches the formula given in the evidence; all required anchors (element='c', bond_type='=', percentage computation) are present.",
      "verdict": true,
      "evidence": "sql_result shows column percentage with value 82.592994, indicating calculation executed over atoms meeting the criteria."
    }
  },
  {
    "question_id": 36,
    "result": {
      "expected_answer": "Full name(s) (first and last) of the administrator(s) for the school that has the greatest number of students scoring 1500 or higher on the SAT (NumGE1500).",
      "sql_description": "Finds the school record in satscores with the maximum NumGE1500, joins that school to schools, and outputs up to three administrator names (AdmFName1-3 || AdmLName1-3).",
      "reason": "Query correctly identifies the top-scoring school via NumGE1500 and returns the administrators’ full names; required anchors (NumGE1500 max and admin names) are satisfied. Tie handling not specified, so selecting one top school is acceptable.",
      "verdict": true,
      "evidence": "sql_result rows: [full_name] -> row0: 'Michelle King'"
    }
  },
  {
    "question_id": 230,
    "result": {
      "expected_answer": "The elements present in molecule TR060 together with the molecule’s carcinogenic label (+ or -).",
      "sql_description": "Finds every atom whose molecule_id is 'TR060', joins to the molecule table, and returns the element of each atom along with the molecule’s label.",
      "reason": "All required anchors are satisfied: the query restricts to molecule TR060, returns its elements and the label. Duplicate element rows do not contradict the question, which does not explicitly require uniqueness.",
      "verdict": true,
      "evidence": "Rows show element values such as c, h, o with label '-' (e.g., row0 element=c label='-')."
    }
  },
  {
    "question_id": 83,
    "result": {
      "expected_answer": "1) A single overall count of magnet K-8 schools whose NSLP Provision Status is \"Multiple Provision Types\".\n2) For every city that has at least one magnet K-8 school, list the city name together with the number of such schools in that city (and also the total number of such cities, if interpreted literally).",
      "sql_description": "Builds the set of magnet schools that serve K-8 (k8_magnet_schools).  Builds the set of schools that have NSLP Provision Status = 'Multiple Provision Types' (multiple_provision_schools).  Joins the two and outputs, for EACH city, two columns: (a) count of magnet K-8 schools in that city and (b) count of those that are Multiple Provision Types in that city.",
      "reason": "It supplies city-level counts, but never returns the single OVERALL number of magnet K-8 schools with \"Multiple Provision Types\" requested in the first sentence, nor the total number of qualifying cities. Required aggregate anchors are missing, so the query only partially answers the question.",
      "verdict": false
    }
  },
  {
    "question_id": 219,
    "result": {
      "expected_answer": "Percentage of triple bonds among all bonds that belong to carcinogenic (label='+') molecules: compute 100 * (count of bonds where bond_type='#' and molecule label='+') / (count of all bonds whose molecule label='+').",
      "sql_description": "Calculates 100 * (number of carcinogenic molecules that possess at least one triple bond) / (total number of carcinogenic molecules). It counts DISTINCT molecule_id with a '#' bond versus all DISTINCT carcinogenic molecules.",
      "reason": "Question (and evidence) asks for ratio of triple-type bonds to all bonds within carcinogenic molecules, but SQL computes ratio of molecules having a triple bond to all carcinogenic molecules. Required bond-level anchor violated.",
      "verdict": false
    }
  },
  {
    "question_id": 234,
    "result": {
      "expected_answer": "A single integer: the number of bonds in molecule TR009 where atom 12 (atom id TR009_12) participates as either endpoint.",
      "sql_description": "Joins bond with connected, keeps bonds that belong to molecule TR009 and where connected lists TR009_12 in either atom_id column, then counts distinct bond_id.",
      "reason": "Satisfies both anchors: molecule_id = TR009 and participation of atom TR009_12 in either atom_id or atom_id2. Counting distinct bonds matches the requested quantity.",
      "verdict": true,
      "evidence": "Returned column COUNT(DISTINCT b.bond_id) with value 3."
    }
  },
  {
    "question_id": 282,
    "result": {
      "expected_answer": "The molecule TR006 label ('+' or '-') along with the ratio of hydrogen atoms to total atoms, i.e., SUM(hydrogen atoms) / COUNT(all atoms).",
      "sql_description": "Joins molecule with atom for TR006, groups by the molecule label and returns the label together with 100 * SUM(CASE element='h') / COUNT(*), effectively a percentage of hydrogen atoms.",
      "reason": "The evidence explicitly defines the required ratio as SUM(element='h') / COUNT(element). The predicted SQL multiplies this value by 100, outputting a percentage, thus contradicting the anchor formula and yielding a numerically different answer.",
      "verdict": false
    }
  },
  {
    "question_id": 98,
    "result": {
      "expected_answer": "Account IDs (and possibly amount) of those accounts whose loan approval date falls in 1997, whose account frequency equals the weekly issuance value ('POPLATEK TYDNE'), and whose approved loan amount is the smallest among that 1997 weekly-frequency cohort.",
      "sql_description": "Builds 1997 loans where status = 'Approved', joins to account, finds the minimum loan amount, then returns account_id, amount and frequency for rows with that min amount and frequency = 'POPLATEK TYDNE'.",
      "reason": "The loan table’s status codes are 'A','B','C','D'; filtering for status = 'Approved' discards all valid rows, so the query does not actually evaluate the intended set of 1997 loans. Required anchor (loans approved in 1997 irrespective of repayment status) is mishandled, producing an empty set and potentially omitting correct answers.",
      "verdict": false
    }
  },
  {
    "question_id": 25,
    "result": {
      "expected_answer": "For each school located in Riverside, list the school name and its funding type only if that school’s average SAT math score (averaged over all its SAT records) exceeds 400.",
      "sql_description": "Joins schools with their SAT score records, keeps rows where the school’s City is ‘Riverside’, groups by school, retains groups whose AVG(AvgScrMath) > 400, and outputs School and FundingType.",
      "reason": "All anchors are met: filters on Riverside (using City, a reasonable interpretation), calculates the per-school average of AvgScrMath, applies the >400 condition, and returns the requested fields. Ambiguity between city vs county is acceptable and not contradicted by schema.",
      "verdict": true,
      "evidence": "sql_result shows rows with columns School and FundingType for qualifying Riverside schools (e.g., 'La Sierra High' …)."
    }
  },
  {
    "question_id": 87,
    "result": {
      "expected_answer": "List of administrator email addresses (any of AdmEmail1-3) for schools in San Bernardino County, city of San Bernardino, in the San Bernardino City Unified district, that opened between 2009-01-01 and 2010-12-31, whose school type code is 62 (Intermediate/Middle, public) and district ownership code is 54 (Unified). Only non-null email values are logically wanted.",
      "sql_description": "Selects AdmEmail1-3 from schools where County='San Bernardino', City='San Bernardino', District='San Bernardino City Unified', OpenDate between 2009-01-01 and 2010-12-31, SOC='62', DOC='54', and at least one of the three email fields is not null.",
      "reason": "Query applies all required geographic, date and type filters and retrieves the administrator email columns. Though it may return NULLs in columns, guidelines allow this; the returned non-null values satisfy the request.",
      "verdict": true,
      "evidence": "sql_result shows two non-null addresses in columns AdmEmail1 and AdmEmail2 for the qualifying school (row 0)."
    }
  },
  {
    "question_id": 469,
    "result": {
      "expected_answer": "A yes/no (boolean) indicating whether any set containing the card named \"Angel of Mercy\" has a non-NULL mtgoCode, i.e., appeared on Magic: The Gathering Online.",
      "sql_description": "Checks for at least one card named 'Angel of Mercy', joins to its set, and returns 1 if that set's mtgoCode is not NULL, else 0.",
      "reason": "All required anchors are present: filters by card name, tests mtgoCode IS NOT NULL. Returns boolean answering the yes/no question. Ambiguity about multiple sets is reasonably resolved by treating appearance of any such set as sufficient.",
      "verdict": true,
      "evidence": "Returned column value 1 in first row indicating at least one qualifying set."
    }
  },
  {
    "question_id": 125,
    "result": {
      "expected_answer": "For each district that has at least one loan whose status is 'D' (running and client in debt), return the district name and the region together with the percentage change in unemployment rate from 1995 (A12) to 1996 (A13), calculated as 100*(A13-A12)/A12.",
      "sql_description": "Finds all loans with status 'D', gets their districts via the account table, then for each of those districts retrieves A2 (district name), A3 (region) and computes 100*(A13-A12)/A12 as the unemployment-rate increment.",
      "reason": "Uses the correct status anchor ('D'), joins through account to district, and applies the required formula based on A12 and A13. Output columns match the requested information; duplicate rows per district are not expressly forbidden, so the answer content is satisfied.",
      "verdict": true,
      "evidence": "sql_result shows columns district, state, unemployment_increment_rate with values (e.g., row0 Strakonice south Bohemia 40.0), indicating correct computation and requested fields present."
    }
  },
  {
    "question_id": 247,
    "result": {
      "expected_answer": "The set (or list) of element names belonging to atoms that do NOT appear in the connected table as either atom_id or atom_id2 – i.e., elements of atoms with no bonds.",
      "sql_description": "Looks at every atom, left-joins to connected on either side of the bond; keeps only rows where the join failed, then outputs that atom’s id and element.",
      "reason": "All required anchors are satisfied: it excludes any atom that appears in connected (either column) and returns the element for each such unbonded atom. Returning an extra atom_id column is harmless and still provides the requested information.",
      "verdict": true,
      "evidence": "sql_result shows column `element` (rows 0-19) with values like na, cl, h, zn, matching atoms that have no connections."
    }
  },
  {
    "question_id": 152,
    "result": {
      "expected_answer": "A single numeric value: the average A15 (crimes in 1995) for each region whose crime count is above 4000 and which has at least one account opened in 1997 or any later year (i.e., accounts dated 1997 or after).",
      "sql_description": "Takes all districts with A15 > 4000 that also have at least one account opened exactly in calendar year 1997; then computes the average of those districts’ A15 values.",
      "reason": "The accounts filter is too restrictive: it requires the opening year to equal 1997, excluding accounts opened in 1998, 1999, etc., even though \"starting from 1997\" implies 1997 or later. Therefore some qualifying regions may be omitted and the resulting average may be wrong. Anchor on account-year is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 484,
    "result": {
      "expected_answer": "Italian names of the card or cards in the Coldsnap set that have the maximum converted mana cost among all Coldsnap cards.",
      "sql_description": "Computes the maximum convertedManaCost for rows where setCode = 'Coldsnap', then returns fd.name from foreign_data for cards with that convertedManaCost, restricted to language = 'Italian'.",
      "reason": "Query applies the set filter, identifies the max converted mana cost, and returns Italian names for the matching cards; meets all explicit anchors.",
      "verdict": true,
      "evidence": "sql_result shows column [name] (0 rows). Absence of rows does not contradict correctness of logic."
    }
  },
  {
    "question_id": 100,
    "result": {
      "expected_answer": "Count of female clients born before 1950 whose district name is Sokolov and who have at least one associated account (i.e., they are linked to an opened account).",
      "sql_description": "Counts distinct client_ids for females (gender='F') with birth_date before 1950-01-01, whose district name (district.A2) is 'Sokolov', and who appear as OWNER in disp linked to an account.",
      "reason": "All required anchors—female gender, birth before 1950, district Sokolov, and existence of an opened account—are satisfied. Interpreting “among the account opened” as clients who are owners of an account is reasonable and not contradicted by the schema.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT c.client_id) = 7"
    }
  },
  {
    "question_id": 39,
    "result": {
      "expected_answer": "Average number of SAT test takers for schools located in Fresno that opened during the calendar year 1980 (i.e., opening date between 1980-01-01 and 1980-12-31).",
      "sql_description": "Joins satscores with schools, keeps rows where the school's City is 'Fresno' and the OpenDate year is 1980, then returns AVG(NumTstTakr).",
      "reason": "Captures Fresno city anchor, 1980 opening-date window, and averages NumTstTakr, matching the question. Acceptable to interpret “Fresno schools” as City rather than County.",
      "verdict": true,
      "evidence": "sql_result has single column AVG(s.NumTstTakr) with value 203.8."
    }
  },
  {
    "question_id": 273,
    "result": {
      "expected_answer": "Percentage of atoms that are chlorine within carcinogenic molecules: (number of chlorine atoms in molecules whose label is '+') divided by (total number of atoms in those molecules) * 100.",
      "sql_description": "Counts carcinogenic molecules that contain at least one chlorine atom, divides by total number of carcinogenic molecules, and returns that fraction as a percentage.",
      "reason": "Question/evidence define the metric at atom level (count of chlorine atoms over count of all atoms). Predicted SQL instead works at molecule level using DISTINCT, so both numerator and denominator measure molecules, not atoms, violating the required anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 195,
    "result": {
      "expected_answer": "The bond_type value that appears most frequently across all records in the bond table.",
      "sql_description": "Counts rows for each bond_type, orders by the count descending (ties broken alphabetically), and returns the top bond_type together with its count.",
      "reason": "Query correctly computes frequency per bond_type and returns the single most common one; extra count column is relevant and not disallowed.",
      "verdict": true,
      "evidence": "Returned row: bond_type='-' with count=7743 (columns: bond_type, count)."
    }
  },
  {
    "question_id": 89,
    "result": {
      "expected_answer": "The count of accounts whose frequency is 'POPLATEK PO OBRATU' (issuance after transaction) and whose branch’s region (district.A3) is 'East Bohemia'.",
      "sql_description": "Joins account with district and disp, filters for frequency = 'POPLATEK PO OBRATU', region = 'East Bohemia', and keeps only rows where an OWNER disposition exists, then counts distinct account IDs.",
      "reason": "All required anchors (frequency and region) are correctly applied. The extra OWNER filter is harmless because each account must have at least one owner, so it does not contradict the question.",
      "verdict": true,
      "evidence": "Result has column COUNT(DISTINCT a.account_id) with value 0."
    }
  },
  {
    "question_id": 37,
    "result": {
      "expected_answer": "Street, City, Zip and State of the school that has the lowest excellence rate (NumGE1500 divided by NumTstTakr) in the dataset.",
      "sql_description": "Joins schools with satscores, ignores rows where NumTstTakr is 0 to avoid division by zero, computes NumGE1500 / NumTstTakr, orders ascending to find the minimum rate, then returns the Street, City, Zip and State of that single school (first row).",
      "reason": "All required anchors are present: rate is correctly computed, lowest value is selected, address fields requested are returned. Filtering out zero-test-taker schools is reasonable to make the ratio meaningful and does not contradict the question.",
      "verdict": true,
      "evidence": "Returned columns: Street, City, Zip, State; first row shows '1900 Third Street', 'Alameda', '94501-1851', 'CA'."
    }
  },
  {
    "question_id": 136,
    "result": {
      "expected_answer": "Count of all loans approved between 1995-01-01 and 1997-12-31 whose amount is at least 250,000 and whose account has frequency = 'POPLATEK MESICNE' (monthly statement). No additional status restriction is stated.",
      "sql_description": "Counts loans where loan.date is within 1995-01-01 and 1997-12-31, loan.amount >= 250000, the linked account has frequency 'POPLATEK MESICNE', AND loan.status = 'A'.",
      "reason": "The query imposes an extra anchor (status = 'A'). The question only asks for ‘approved’ loans, which in this schema applies to every loan record regardless of its status. Filtering to status 'A' omits valid loans in other statuses (e.g., running contracts), so the count is incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 99,
    "result": {
      "expected_answer": "Account(s) having loan duration > 12 months and account opening year 1993 whose approved loan amount is the maximum among that group; return at least their account_id (amount/date optional).",
      "sql_description": "Joins loan with account, keeps rows with duration > 12 and account opening year 1993, then returns the row(s) whose approved_amount equals the maximum approved_amount within that filtered set, outputting account_id, amount and opening date.",
      "reason": "All required anchors (duration > 12, opening year 1993, highest approved amount within that subset) are present. Extra columns are permissible. Therefore the SQL answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row: account_id 10451 with approved_amount 482940 and account_opening_date 1993-08-29, fulfilling conditions."
    }
  },
  {
    "question_id": 168,
    "result": {
      "expected_answer": "The percentage (0-100 scale) of distinct clients who are female (gender = 'F') among those who are OWNERS of at least one account that was opened in a district whose average salary (A11) exceeds 10000.",
      "sql_description": "1) Picks districts with A11 > 10000.\n2) Gets all accounts in those districts.\n3) Retrieves owners of those accounts, but only when the client’s own district_id equals the account’s district_id.\n4) Counts owner rows that are female divided by all owner rows, multiplies by 100.",
      "reason": "The query double-filters by both client.district_id and account.district_id, adding a condition not required by the question and potentially excluding valid clients. More importantly, it does not deduplicate client_ids, so clients owning multiple qualifying accounts are counted multiple times, violating the explicit anchor “percentage of clients”. Distinct clients are required for a proper client-level percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 129,
    "result": {
      "expected_answer": "The names of the districts (A2) together with the monetary amounts for the ten largest withdrawal transactions (type = 'VYDAJ', i.e. non-credit-card) that occurred during January 1996.",
      "sql_description": "Joins trans→account→district, keeps rows where trans.type = 'VYDAJ' and trans.date starts with '1996-01', then orders the resulting transactions by amount descending and returns the first 10 rows with district_name and amount.",
      "reason": "All explicit anchors are met: type='VYDAJ' (non-credit-card per evidence) and date in January 1996. The query orders by amount and limits to 10, providing the top ten withdrawals and shows each related district name, matching the question’s intent. No contradictory constraints are missing.",
      "verdict": true,
      "evidence": "sql_result columns: district_name, amount; first rows show Trutnov 63700, Pelhrimov 59600, … Jihlava 52300 – 10 rows total."
    }
  },
  {
    "question_id": 128,
    "result": {
      "expected_answer": "Return the nine districts with the largest numbers of female account holders, ordered from highest to lowest, showing the district name and the corresponding count.",
      "sql_description": "Counts distinct female clients (gender='F') who are linked to an account as an OWNER via disp, groups by their district name (district.A2), orders the counts descending, and returns the top 9 districts with their counts.",
      "reason": "Query produces district names and counts of female account-owning clients, orders them descending, and limits to nine rows – matching the requirement. Using OWNER disposition is a reasonable interpretation of \"account holders\" and does not violate any explicit anchor.",
      "verdict": true,
      "evidence": "sql_result shows 9 rows with columns district_name and female_account_holders sorted descending."
    }
  },
  {
    "question_id": 169,
    "result": {
      "expected_answer": "Percentage change ((total loan amount for male clients in 1997 − total in 1996) ÷ total in 1996 × 100) – a single numeric growth rate value.",
      "sql_description": "Calculates total loan amount granted to male clients in 1996 and in 1997, then returns 100 × (diff / 1996 total) as growth_rate.",
      "reason": "Query filters gender='M', isolates 1996 and 1997 loans, sums amounts, and computes the percentage growth exactly as requested. No required anchors are missing.",
      "verdict": true,
      "evidence": "Result set contains one column growth_rate with value 25.36204 (row 0)."
    }
  },
  {
    "question_id": 159,
    "result": {
      "expected_answer": "All transactions of type withdrawal in cash (operation='VYBER') performed via any account belonging to client 3356, returned as a list with their details.",
      "sql_description": "Joins trans with account, disp, client to find every transaction whose operation is 'VYBER' and where the associated client_id is 3356; outputs trans_id, date, amount, balance.",
      "reason": "Satisfies both required anchors: 1) client_id = 3356 and 2) operation = 'VYBER' (cash withdrawal). No extraneous constraints are introduced. Result set matches the requested listing.",
      "verdict": true,
      "evidence": "sql_result shows 20 rows with columns trans_id, date, amount, balance all having operation 'VYBER'."
    }
  },
  {
    "question_id": 119,
    "result": {
      "expected_answer": "Account ids together with their district name (A2) and region (A3) for accounts opened in 1993 that have a statement-fee transaction (k_symbol or operation = 'POPLATEK PO OBRATU') which occurs after an ordinary transaction for the same account.",
      "sql_description": "Finds accounts whose opening date year is 1993, joins any transaction, and joins a loan on the same account whose payments value equals 'POPLATEK PO OBRATU', requiring the transaction date to be earlier than the loan date; returns that account id with district columns.",
      "reason": "Uses the loan table and the loan.payments field for the 'POPLATEK PO OBRATU' condition instead of the transaction attributes; therefore it does not actually look for statement-fee transactions. The logic of 'after transaction' is implemented with loan.date, not a statement date. Key anchor (statement fee in transaction) is missing / mis-applied.",
      "verdict": false
    }
  },
  {
    "question_id": 28,
    "result": {
      "expected_answer": "List of school names along with their DOCType for those locally funded schools whose (Enrollment K-12 − Enrollment Ages 5-17) exceeds the average of that same difference among all locally funded schools.",
      "sql_description": "1) Computes the average (Enrollment K-12 − Enrollment Ages 5-17) across schools where FundingType = 'Locally funded'. 2) Retrieves School and DOCType for schools that are also FundingType = 'Locally funded' and whose individual difference is greater than that computed average.",
      "reason": "Query correctly applies the locally funded filter both when calculating the average and when selecting schools, uses the proper difference formula, and returns the requested School and DOCType fields.",
      "verdict": true,
      "evidence": "sql_result shows columns School and DOCType for 20 locally funded schools (e.g., Mountain Oaks – County Office of Education (COE), Clovis Online Charter – Unified School District) indicating the intended list."
    }
  },
  {
    "question_id": 93,
    "result": {
      "expected_answer": "Number of male customers (gender='M') whose district region (A3) is 'North Bohemia' and whose district’s average salary (A11) is greater than 8000.",
      "sql_description": "Counts distinct clients linked to a disposition row of type 'OWNER', whose gender is male, whose district region is North Bohemia, and whose district average salary exceeds 8000.",
      "reason": "Adds an extra mandatory condition (must have a disp row with type='OWNER') and inner-joins to disp. Clients without such a disposition are wrongly excluded, so the count can be lower than asked. Required anchors are met, but the additional constraint violates the question scope.",
      "verdict": false
    }
  },
  {
    "question_id": 116,
    "result": {
      "expected_answer": "The percentage growth of the balance for the client whose very first-approved loan on 1993-07-05 was registered, computed as ((balance on 1998-12-27 – balance on 1993-03-22) / balance on 1993-03-22) * 100.",
      "sql_description": "1) Chooses a single loan dated 1993-07-05 with status = 'A', taking the smallest loan_id; 2) gets that loan’s account and its OWNER client; 3) fetches the last transaction on 1993-03-22 and on 1998-12-27 for that account; 4) returns 100 * (later balance – earlier balance) / earlier balance.",
      "reason": "Adds an invented constraint l.status = 'A' that the question never requires, potentially excluding the actual first loan on 1993-07-05 and therefore the correct client/account. This violates the no-extraneous-constraint rule, so the query cannot be accepted even though the rest of the logic matches.",
      "verdict": false
    }
  },
  {
    "question_id": 45,
    "result": {
      "expected_answer": "For every school that is administered by Ricci Ulrich, return the school’s name together with its average SAT writing score (one row per such school).",
      "sql_description": "Finds all schools where Ricci Ulrich appears as any of the three stored administrators, joins those schools to their SAT-score records, and reports the average of AvgScrWrite for each matched school.",
      "reason": "Query applies the required administrator anchor, joins to SAT scores, aggregates AvgScrWrite per school, and outputs the requested pair (school, average writing score). No conflicting constraints are missed.",
      "verdict": true,
      "evidence": "sql_result columns: School, avg_writing_score; e.g. row0 = (Buchanan High, 507.0)"
    }
  },
  {
    "question_id": 94,
    "result": {
      "expected_answer": "All account numbers of female owner-clients who are simultaneously the oldest among female clients and whose district has the lowest average salary, plus one number that equals (highest average salary of any female owner-client) minus (that lowest average salary).",
      "sql_description": "Builds female owner list with their birth-dates and district salaries; picks ONE row that is the earliest birth_date (if ties, the smaller salary) via ORDER BY birth_date ASC, avg_salary ASC LIMIT 1; independently finds MIN and MAX salaries among females; returns the chosen account_id and (max_salary – chosen salary) as the gap.",
      "reason": "The query does not guarantee that the selected account belongs to a client in the district with the overall lowest average salary—it only chooses the oldest client and uses her salary. Therefore the gap may use a non-minimum salary and the account list may omit other clients who meet both 'oldest AND lowest salary' criteria. Anchor ‘lowest average salary’ is not correctly enforced.",
      "verdict": false
    }
  },
  {
    "question_id": 186,
    "result": {
      "expected_answer": "The percentage (0-100) of clients with weekly statement frequency who are male, i.e. (distinct male clients with frequency = 'POPLATEK TYDNE') / (distinct clients with frequency = 'POPLATEK TYDNE') * 100.",
      "sql_description": "Counts distinct male clients tied to accounts whose frequency is 'POPLATEK TYDNE' and divides by all distinct clients tied to such accounts, multiplying by 100, outputting the percentage.",
      "reason": "The query applies the required weekly-statement anchor (frequency='POPLATEK TYDNE'), uses distinct client counts to avoid duplicates, and computes the proportion of those clients who are male, matching the question’s definition.",
      "verdict": true,
      "evidence": "Result column percentage_male_weekly_statements = 52.12766 (row 0)."
    }
  },
  {
    "question_id": 145,
    "result": {
      "expected_answer": "Identification numbers (client_id) of account holders (owners) who made at least one credit-card withdrawal (operation = 'VYBER KARTOU') in the year 1998 whose transaction amount was below the average amount of all such credit-card withdrawals in 1998.",
      "sql_description": "1) Computes the average amount of 1998 credit-card withdrawals (operation 'VYBER KARTOU'). 2) Selects distinct client_id values from disp with type 'OWNER' whose linked accounts have a 1998 credit-card withdrawal whose amount is less than that average.",
      "reason": "Query applies the required year filter, credit-card operation filter, compares transaction amount to the computed average, and returns owner client IDs. All explicit anchors are satisfied and no extraneous constraints added.",
      "verdict": true,
      "evidence": "sql_result shows one column client_id with 20 rows, e.g., 19, 41, 51, ... matching the requested output."
    }
  },
  {
    "question_id": 189,
    "result": {
      "expected_answer": "Account numbers of female clients who satisfy BOTH of these extremes: 1) they are the oldest women in the data set (earliest birth_date) AND 2) they live in the district with the lowest average salary (column A11). Every account that meets the conjunction should be listed.",
      "sql_description": "Builds a list of female OWNER dispositions, attaches their district’s A11 value, sorts by birth_date ascending and then A11 ascending, and returns only the single first account_id (LIMIT 1).",
      "reason": "The query picks one oldest female client and uses salary only as a tie-breaker; it does not guarantee that the chosen client also has the global minimum average salary. Thus the required conjunction of being oldest AND having the lowest salary is not enforced. It also arbitrarily limits output to one row and restricts to OWNER dispositions, neither demanded by the question.",
      "verdict": false
    }
  }
]