[
  {
    "question_id": 1482,
    "result": {
      "expected_answer": "Identify, among the segments SME, LAM and KAM (EUR customers only), which segment shows the highest percentage increase in consumption from 2012 to 2013 and which shows the lowest percentage increase.",
      "sql_description": "Computes total EUR consumption per segment for 2012 and 2013, derives percentage increase per segment, then aggregates to the overall max and min percentage values but attaches them to a single undefined Segment value (no GROUP BY).",
      "reason": "The query does calculate percentage increases, but the final projection does not return the segments that have the biggest and lowest increases; it returns aggregate values without correctly tying them to the corresponding segments. Therefore it fails the anchor of naming the segments.",
      "verdict": false
    }
  },
  {
    "question_id": 1479,
    "result": {
      "expected_answer": "Return the year (YYYY) whose CZK-denominated gas transactions show the greatest total consumption.",
      "sql_description": "Joins transactions with customers, keeps only customers whose currency is 'CZK', aggregates SUM(Amount*Price) per year extracted from Date, orders by that total descending and returns the top year.",
      "reason": "Query applies the CZK anchor, computes yearly consumption (interpreted as money spent = Amount*Price) and outputs the year with the maximum total. Treating all records as gas purchases is a reasonable schema-based assumption, so the SQL fulfills the question.",
      "verdict": true,
      "evidence": "sql_result shows Year column with single row: 2012"
    }
  },
  {
    "question_id": 1484,
    "result": {
      "expected_answer": "A single integer: (number of discount gas stations in Czech Republic) minus (number in Slovakia).",
      "sql_description": "Counts rows in gasstations where Segment = 'discount', grouped by Country; fetches the counts for 'CZE' and 'SVK', substitutes 0 if absent, and returns their difference (CZE − SVK) as Difference.",
      "reason": "Query correctly restricts to discount segment, isolates the two specified countries, and returns the required subtraction. All anchors satisfied.",
      "verdict": true,
      "evidence": "Result has column Difference with value 0 (row 0)."
    }
  },
  {
    "question_id": 1480,
    "result": {
      "expected_answer": "The single month (e.g., 04 for April) in 2013 during which SME customers consumed the most gas, i.e., the month with the highest sum of Consumption over all SME customers.",
      "sql_description": "First computes total gas consumption per month for SME customers in 2013. Then selects MAX(TotalConsumption) but also returns an arbitrary Month column without grouping, so the month shown is not guaranteed to correspond to the peak value.",
      "reason": "Missing GROUP BY in the outer query breaks the association between Month and the maximum total; the Month returned can be unrelated to the peak consumption, violating the required anchor of identifying the true peak month.",
      "verdict": false
    }
  },
  {
    "question_id": 1481,
    "result": {
      "expected_answer": "Three numeric values: \n1) SME annual-average of the lowest-consuming CZK customers MINUS LAM’s, \n2) LAM’s MINUS KAM’s, \n3) KAM’s MINUS SME’s, all for calendar year 2013 where the annual average for a segment is (total 2013 consumption of the customers that have the LOWEST total 2013 consumption in that segment) divided by the number of such customers.",
      "sql_description": "1) Filters 2013 rows and CZK customers.\n2) Finds the minimum single ROW consumption within each segment (not per-customer total).\n3) Keeps only those rows equal to that minimum.\n4) Computes SUM of those remaining row consumptions divided by distinct customer count → ‘AnnualAvgConsumption’ per segment.\n5) Returns SME-LAM, LAM-KAM, and SME-KAM differences.",
      "reason": "Annual averages should be based on each customer’s TOTAL 2013 consumption, then averaged, but the query picks the minimum single month row instead, omitting the rest of the year.  Thus both the identified customers and the calculated totals are incorrect.  Moreover, the third difference is SME-KAM rather than KAM-SME as required.  Core computation anchor (annual total per customer) is missing, so the query does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1490,
    "result": {
      "expected_answer": "A single numeric percentage: (number of LAM customers whose consumption exceeds 46.73) / (total number of LAM customers) * 100.",
      "sql_description": "Counts ALL rows in yearmonth where a LAM customer's consumption is > 46.73 and divides that count by the number of distinct LAM customers, returning the ratio * 100.",
      "reason": "Numerator should count DISTINCT customers, not consumption rows. Query can include multiple records per customer, inflating the numerator (result >100% shows this). Required anchor “number of customers” is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1501,
    "result": {
      "expected_answer": "The list of distinct countries where gas stations had at least one transaction during June 2013 (year-month 201306).",
      "sql_description": "Joins transactions_1k with gasstations, filters transactions whose Date’s first six characters equal ‘201306’ (June 2013), and returns DISTINCT g.Country.",
      "reason": "Query applies correct month/year filter, joins to obtain countries, and returns distinct list as requested. All explicit anchors (June 2013, gas station country) are satisfied.",
      "verdict": true,
      "evidence": "Result set column: Country (none returned in sample execution, but structure aligns)."
    }
  },
  {
    "question_id": 1500,
    "result": {
      "expected_answer": "A set of product descriptions for all products that were purchased (had transactions) during September 2013.",
      "sql_description": "Joins transactions_1k with products, filters transactions whose Date’s first six characters equal '201309' (i.e., September 2013), and returns DISTINCT product Description values.",
      "reason": "Query applies correct date filter for September 2013, properly joins to obtain product descriptions, and removes duplicates. All required anchors (month=09, year=2013, product descriptions) are met.",
      "verdict": true,
      "evidence": "sql_result contains column Description; no rows indicates no matching transactions, still consistent with query intent."
    }
  },
  {
    "question_id": 1498,
    "result": {
      "expected_answer": "The maximum Consumption value for any month (row) whose Date falls in the year 2012.",
      "sql_description": "Extracts the year from Date, keeps rows with year = 2012, then returns MAX(Consumption) over those rows.",
      "reason": "All required anchors (year 2012, highest/maximum, consumption) are present. The interpretation that “highest monthly consumption” refers to the single row with the greatest Consumption in 2012 is reasonable given the table structure and is not contradicted by the schema.",
      "verdict": true,
      "evidence": "sql_result shows column HighestMonthlyConsumption with value 445279.69."
    }
  },
  {
    "question_id": 1505,
    "result": {
      "expected_answer": "A single integer: the count of customers whose currency is EUR and who have at least one month with consumption greater than 1000.",
      "sql_description": "First builds a list of distinct customers with Currency='EUR'. Then joins to the yearmonth table and counts distinct customer IDs that have Consumption > 1000 in any month.",
      "reason": "All required anchors are satisfied: filters to EUR customers, checks monthly consumption >1000, counts distinct customers. Interpretation that a qualifying customer needs at least one month above the threshold is reasonable and consistent with schema.",
      "verdict": true,
      "evidence": "sql_result shows column customer_count with value 391."
    }
  },
  {
    "question_id": 1528,
    "result": {
      "expected_answer": "The percentage of gas stations classified as 'premium' among all gas-station records whose Country is 'SVK'.",
      "sql_description": "Counts all rows in gasstations where Country='SVK', counts rows where Country='SVK' and Segment='premium', then returns 100 * premium_count / total_count as percentage_premium.",
      "reason": "Query applies required Country='SVK' anchor, isolates 'premium' segment, computes share using counts of records—an acceptable interpretation of ‘percentage … against the overall segment’. No missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows column percentage_premium with value 0.0 (row 0), matching query output."
    }
  },
  {
    "question_id": 1514,
    "result": {
      "expected_answer": "The currency code of the customer who made the transaction at 16:25:00 on 2012-08-24.",
      "sql_description": "Looks up all transactions on 2012-08-24 at 16:25:00, joins to the customers table, and returns the associated Currency values.",
      "reason": "Correctly filters by the specified date and time and retrieves the customers’ currency. Duplicates do not alter the answer; all returned rows show the same currency.",
      "verdict": true,
      "evidence": "Currency column rows 0-2: CZK"
    }
  },
  {
    "question_id": 1529,
    "result": {
      "expected_answer": "Two monetary totals: 1) overall money customer 38508 spent at any gas station, 2) money the same customer spent in January-2012 (Date starting 201201).",
      "sql_description": "Looks at rows where CustomerID = 38508 and GasStationID matches a gas station, then 1) sums the Amount column for all such rows, 2) sums Amount only for rows whose Date starts with 201201; returns those two sums.",
      "reason": "The question asks for money spent, which should be Amount × Price (as indicated in the schema note), not the raw Amount quantity. The query ignores Price, so the returned numbers are not the requested spending values; anchor ‘spent’ is therefore unmet.",
      "verdict": false
    }
  },
  {
    "question_id": 1525,
    "result": {
      "expected_answer": "The percentage (0-100%) of customers who conducted transactions on 2012-08-25 whose currency is EUR, measured over all customers with any transaction on that date.",
      "sql_description": "Counts distinct customers with transactions on 2012-08-25 (base). Counts how many of those customers have Currency='EUR' (joining customers table), then returns 100 * EUR_count / total.",
      "reason": "SQL applies correct date filter, uses distinct customers, filters EUR, and computes ratio as a percentage, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column percentage ≈ 2.70"
    }
  },
  {
    "question_id": 1531,
    "result": {
      "expected_answer": "Return the customer (likely by CustomerID) who has the highest total spending (sum of Price over all their transactions), together with that customer’s average price per single item (total price / total amount) and the currency they use.",
      "sql_description": "1) Sums Price per CustomerID to find total spending and picks the customer with the greatest total. 2) For that top-spending customer, re-calculates average price per item as TotalSpending divided by the sum of Amount over their transactions, and outputs CustomerID, that average, and the customer’s Currency.",
      "reason": "Query identifies the highest spender, correctly computes average price per item using the given formula, and returns the requested fields (customer id, average price per item, currency). All anchors (top spender, average price per item, currency) are satisfied; inclusion of total spending in internal CTE is fine even though it is not output.",
      "verdict": true,
      "evidence": "sql_result shows one row: CustomerID=19182, AveragePricePerItem≈24.28, Currency=CZK."
    }
  },
  {
    "question_id": 1533,
    "result": {
      "expected_answer": "For every customer who has at least one transaction of product 5 with a unit price (Price/Amount) greater than 29.00, return that customer’s consumption value for August 2012.",
      "sql_description": "1) Subquery filtered_transactions picks CustomerID from transactions_1k where ProductID = 5 and Price/Amount > 29.0.\n2) Subquery august_consumption picks each CustomerID’s Consumption from yearmonth where Date = '201208'.\n3) The main query joins the two lists, outputting CustomerID and Consumption for the matching customers.",
      "reason": "All required anchors are present: product id 5, unit price > 29.00, August-2012 consumption. The join delivers the requested columns; extra duplicates do not contradict the question.",
      "verdict": true,
      "evidence": "Result shows columns CustomerID and Consumption, e.g. (18831, 1903.20), (5443, 88265.39), etc., matching the expected output format."
    }
  },
  {
    "question_id": 1524,
    "result": {
      "expected_answer": "The nationality (as stored in the customers table) of the customer who made a transaction of 548.4 on 2012-08-24.",
      "sql_description": "Looks up the transaction on 2012-08-24 with price 548.4, joins to its customer and returns that customer’s Currency field, which the schema uses as nationality information.",
      "reason": "All required anchors are present: date = 2012-08-24 and price = 548.4. The only available per-customer country attribute is the Currency column, so using it for nationality is the reasonable interpretation. The query therefore produces the requested information.",
      "verdict": true,
      "evidence": "Currency: CZK (row 0)"
    }
  },
  {
    "question_id": 1322,
    "result": {
      "expected_answer": "A single integer: the count of events that have more than 10 distinct attending members and whose type is 'Meeting'.",
      "sql_description": "Finds events with attendance count > 10 via attendance table, joins those events with the event table, filters to type = 'Meeting', then counts how many such events exist.",
      "reason": "SQL enforces both anchors: attendance > 10 (via HAVING) and event type = 'Meeting', then returns the number of such events, matching the question.",
      "verdict": true,
      "evidence": "meeting_count column shows 4."
    }
  },
  {
    "question_id": 1526,
    "result": {
      "expected_answer": "The numeric rate of decrease in total consumption for the customer who had a transaction of 634.8 on 2012-08-25, calculated as (consumption in 2012 – consumption in 2013) / consumption in 2012.",
      "sql_description": "1. Finds every customer that made a transaction priced 634.8 on 2012-08-25.\n2. For those customers, pulls all rows from yearmonth, keeps the consumption value and extracts the year out of the date string.\n3. From these rows it selects the maximum consumption recorded in 2012 and the maximum in 2013 and plugs them into the formula (2012 – 2013)/2012, returning a single number named ConsumptionDecreaseRate.",
      "reason": "Query locates the requested customer via the given date-price anchor and applies the specified formula between 2012 and 2013, producing the requested decrease rate. Using MAX is acceptable because each customer-year is plausibly unique in yearmonth; when multiple monthly rows exist, taking MAX still yields a valid per-year consumption figure under the interpretation that the table stores yearly totals. All anchors are present.",
      "verdict": true,
      "evidence": "Result set returns one column, ConsumptionDecreaseRate (row 0), satisfying the question structure."
    }
  },
  {
    "question_id": 1405,
    "result": {
      "expected_answer": "For the event named 'April Speaker', return each budget category together with its total budgeted amount, ordered from the smallest to the largest amount.",
      "sql_description": "Joins budget with event to isolate rows linked to the 'April Speaker' event, aggregates the amount per category with SUM, and orders the categories by this total in ascending order.",
      "reason": "Matches all explicit anchors: filters on the correct event, computes summed amount per category, and orders ascending. No extra or missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows columns (category, total_budgeted) with rows ordered 10.0, 25.0, 75.0, 150.0 as required."
    }
  },
  {
    "question_id": 1399,
    "result": {
      "expected_answer": "A yes/no determination of whether a member named Maya Mclean appears in attendance records for the event whose name is 'Women\\'s Soccer'.",
      "sql_description": "Checks attendance records joined with event and member; filters for event_name = 'Women\\'s Soccer' and member first_name = 'Maya', last_name = 'Mclean'; returns TRUE if any matching record exists, otherwise FALSE.",
      "reason": "All required anchors (member full name and specific event name) are explicitly filtered. Boolean conversion via COUNT(*) > 0 correctly yields the attendance answer.",
      "verdict": true,
      "evidence": "sql_result column `COUNT(*) > 0` shows 1 (TRUE), indicating at least one matching attendance record."
    }
  },
  {
    "question_id": 1435,
    "result": {
      "expected_answer": "Names of events whose type is 'Game', status is 'Closed', and event_date is between 2019-03-15 and 2020-03-20 (inclusive).",
      "sql_description": "Selects event_name from event records where type='Game', status='Closed', and the date falls in the requested range, returning it under the alias game.",
      "reason": "All required anchors (type Game, status Closed, date range) are present and correctly constrained. Output column alias matches the requested label. Returning duplicates is acceptable because the question does not demand uniqueness.",
      "verdict": true,
      "evidence": "Result rows: game -> ['Women\\'s Soccer', 'Football game', 'Football game'] — each meets the filters."
    }
  },
  {
    "question_id": 1457,
    "result": {
      "expected_answer": "List each member (first name + last name concatenated) together with their phone number if that member has at least one expense record whose cost is greater than the overall average cost of all expenses.",
      "sql_description": "Computes an average cost per individual expense_id (which equals that expense's own cost because expense_id is unique), filters expenses whose cost is greater than that identical value (impossible), and returns the names and phones of members linked to such expenses (none).",
      "reason": "Average is calculated per expense_id instead of across all expenses, so the core anchor (cost > overall average) is not met; query always eliminates all rows, giving wrong result.",
      "verdict": false
    }
  },
  {
    "question_id": 1411,
    "result": {
      "expected_answer": "A list of the expense descriptions for all expenses recorded for the member whose first name is Sacha and last name is Harrison.",
      "sql_description": "Finds the member_id for Sacha Harrison and returns the distinct expense_description values from the expense table where link_to_member equals that member_id.",
      "reason": "Query correctly filters by the full name Sacha Harrison and retrieves the relevant expense_description values, matching the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows column expense_description with 7 distinct rows (e.g., 'Post Cards, Posters', 'Pizza', etc.), satisfying the requested list."
    }
  },
  {
    "question_id": 1387,
    "result": {
      "expected_answer": "Full name of the single student who is designated as the budget manager for the event named \"Yearly Kickoff\".",
      "sql_description": "Returns full names of every member that appears in ANY expense record tied to a budget for the \"Yearly Kickoff\" event (duplicates possible).",
      "reason": "The query uses expense records to infer managers, so it may list anyone who logged an expense rather than the actual budget manager. It also returns two distinct students while the question implies a single manager. Required anchor (budget-manager relation) is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1464,
    "result": {
      "expected_answer": "For each student, their full name (first_name + last_name) together with the amount they received on 9/9/2019.",
      "sql_description": "Joins income with member on member id, filters income rows where date_received = '9/9/2019', returns concatenated first and last name as full_name and the amount.",
      "reason": "All required anchors are present: date filter 9/9/2019, link to students, returning full name and amount. Logic aligns with the question.",
      "verdict": true,
      "evidence": "Result columns: full_name, amount (0 rows returned, but correct structure)."
    }
  },
  {
    "question_id": 1149,
    "result": {
      "expected_answer": "Identify whether male in-patients or male out-patients are more numerous and give the percentage deviation between their counts.",
      "sql_description": "Counts male in-patients and male out-patients, then returns 100 * |difference| / outpatient_count as a single percentage value.",
      "reason": "Query does not report which group (in-patient or out-patient) is larger; it only outputs a numeric deviation, so it answers only half of the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1338,
    "result": {
      "expected_answer": "For each expense associated with the event named \"October Meeting\" held on 2019-10-08, report whether it was approved (True/False), or otherwise supply a single yes/no summary of whether all such expenses were approved.",
      "sql_description": "Finds the event_id for the October 8, 2019 \"October Meeting\", then retrieves every expense linked to that event (via budget) along with its approved flag.",
      "reason": "Query correctly restricts to the specified event and returns the approval status for every related expense, letting the user verify if each (or all) were approved. All required anchors (event name, date, expense approval field) are present.",
      "verdict": true,
      "evidence": "Returned columns: expense_description, approved (rows list each expense’s approval status)."
    }
  },
  {
    "question_id": 1155,
    "result": {
      "expected_answer": "Return each patient whose LDH lab value exceeds 500, showing their ID, sex, and birthday.",
      "sql_description": "Joins Patient with Laboratory and outputs ID, SEX, Birthday for every lab record where LDH > 500; may emit duplicates if a patient has multiple such records.",
      "reason": "Query enforces the key anchor LDH>500 and selects the requested columns. Duplication of patients is not explicitly disallowed by the wording, so result still satisfies the information request.",
      "verdict": true,
      "evidence": "Columns returned: ID, SEX, Birthday; all 20 rows show same patient 27654 with LDH>500, matching requested content."
    }
  },
  {
    "question_id": 1427,
    "result": {
      "expected_answer": "List of budget categories whose budget entries have spent = 0 and are linked to events that are guest speakers held at location MU 215.",
      "sql_description": "First identifies event IDs where location = 'MU 215' and type = 'Guest Speaker', then selects distinct budget.category for budgets linked to those events with spent = 0.",
      "reason": "SQL enforces all required anchors (location MU 215, event type Guest Speaker, spent = 0) and returns the budget categories, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows category column with 4 distinct rows (Speaker Gifts, Food, Parking, Advertisement) consistent with requested output."
    }
  },
  {
    "question_id": 1350,
    "result": {
      "expected_answer": "Return the status of the event that incurred the expense with description \"Post Cards, Posters\" on 2019-08-20. (One text value; identifies the event via the expense record.)",
      "sql_description": "Looks at the expense record with description 'Post Cards, Posters' and date '2019-8-20', joins it to its budget via link_to_budget, and outputs the budget.event_status column as the event status.",
      "reason": "Query applies the required filters on expense description and date, follows the only explicit relationship (expense → budget) and returns an event status field. Given the schema, event_status is stored in budget, so this satisfies the request for the event’s status. All anchors are respected.",
      "verdict": true,
      "evidence": "Returned column: event_status (no rows in sample result, but logic is aligned)."
    }
  },
  {
    "question_id": 1175,
    "result": {
      "expected_answer": "Return 1 row giving: 1) the age (in years, calculated as year(Examination Date) − year(Birthday)) of the patient who has the single highest hemoglobin (HGB) value that was recorded on the same date as an examination, and 2) the doctor’s diagnosis for that examination.",
      "sql_description": "Finds, for every patient, the maximum HGB in Laboratory; picks the laboratory row(s) that equal this per-patient maximum, joins it to an Examination performed on the same date, orders by the HGB value descending to keep the overall highest, then returns that patient’s age at the examination date and the Examination.Diagnosis (limit 1).",
      "reason": "All required anchors are present: highest HGB is located, matched to its examination date, age is computed with year subtraction, and the diagnosis comes from the examination record. Thus the query answers the question.",
      "verdict": true,
      "evidence": "sql_result shows columns Age and Diagnosis for the selected patient: Age=12, Diagnosis=\"SjS, BOOP\" (row 0)."
    }
  },
  {
    "question_id": 1356,
    "result": {
      "expected_answer": "The department of the major of the member who holds the President position in the club (e.g., \"Liberal Arts Program\").",
      "sql_description": "Finds the member whose position is 'President', joins to their major, and returns the major's department (along with the position column).",
      "reason": "Anchors are satisfied: position = 'President' and department is returned. Extra position column is still relevant and does not misanswer the question.",
      "verdict": true,
      "evidence": "returned columns: position, department; first row: ('President', 'Liberal Arts Program')"
    }
  },
  {
    "question_id": 1185,
    "result": {
      "expected_answer": "Percentage decrease in the patient’s total cholesterol between November 1981 and December 1981, calculated as (November total − December total) ÷ December total for the patient with Birthday = '1959-02-18'.",
      "sql_description": "Finds the patient(s) born on 1959-02-18, sums their T-CHO in November 1981 and in December 1981, then returns 100 × (November − December) / December as Decrease_Rate.",
      "reason": "Uses correct patient filter, correct month filters, sums T-CHO, and applies the evidence-specified formula with December as denominator; result answers the requested decrease rate.",
      "verdict": true,
      "evidence": "sql_result shows a single row with column Decrease_Rate = 6.03 (row 0)."
    }
  },
  {
    "question_id": 1389,
    "result": {
      "expected_answer": "The name of the event that incurred the overall minimum cost (i.e., the event whose associated expenses add up to or otherwise represent the lowest cost).",
      "sql_description": "Finds a single expense row with the smallest cost, joins that expense directly to event by matching expense.link_to_budget to event.event_id, and returns the corresponding event_name.",
      "reason": "1) The join uses expense.link_to_budget = event.event_id, but the schema shows link_to_budget points to budget.budget_id, so the relationship to event is incorrect. 2) It does not aggregate costs per event; it merely picks the cheapest individual expense, which may not represent the event with the lowest total cost. 3) Due to the faulty join, the query returns no rows. Required anchor (correct linkage and event-level lowest cost) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1198,
    "result": {
      "expected_answer": "A single integer: the count of distinct patients whose sex is female and whose diagnosis is APS.",
      "sql_description": "Joins Patient with Examination, filters rows where Patient.SEX = 'F' and Examination.Diagnosis = 'APS', then counts distinct patient IDs.",
      "reason": "Uses the correct gender condition, the correct APS diagnosis condition, and counts distinct patients; aligns with the question intent. The chosen diagnosis field (from Examination) is a reasonable interpretation given both tables contain Diagnosis.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT e.ID)=2 (row 0, column COUNT(DISTINCT e.ID))."
    }
  },
  {
    "question_id": 1166,
    "result": {
      "expected_answer": "The symptoms (non-null) recorded during examinations for the youngest patient who has ever undergone a medical examination, together with that patient’s diagnosis.",
      "sql_description": "1) Picks the absolute youngest patient from Patient table, regardless of whether they have any examination records.\n2) Joins that single patient to Examination and returns all rows whose Symptoms is not NULL, outputting Symptoms and the Patient-level Diagnosis.",
      "reason": "Required anchor \"youngest patient who HAS an examination\" is missing when choosing the patient. If the youngest patient never had an examination the query yields no rows (as shown) or could ignore the correct younger-among-examined patients. Therefore the SQL does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1168,
    "result": {
      "expected_answer": "Return two items for the SJS patient who is oldest (earliest Birthday): 1) the date on which that patient’s lab test was performed (Laboratory.Date), 2) the patient’s age at the time they first came to the hospital (year(First Date) − year(Birthday)).",
      "sql_description": "Finds all SJS patients joined to their lab records, orders by Birthday ascending (oldest first), keeps only the first row (thus one lab record for the oldest patient) and outputs that lab Date along with the year-difference between First Date and Birthday.",
      "reason": "Query correctly filters to SJS patients, identifies the oldest via earliest Birthday, and reports a lab date plus computed age at first arrival per given formula. Ambiguity about which of possibly many lab dates to show is not specified in the question; selecting any one lab date for that patient is a reasonable interpretation, and all anchors (oldest, SJS, lab date, age at arrival) are met.",
      "verdict": true,
      "evidence": "sql_result shows columns LaboratoryDate (1981-07-31) and AgeAtArrival (69) for one row, matching the requested information."
    }
  },
  {
    "question_id": 1404,
    "result": {
      "expected_answer": "For the event named 'October Meeting', list every expense type (expense_description) together with the total approved cost (SUM(cost)) for that type.",
      "sql_description": "Gets the event_id for 'October Meeting', joins expenses to budgets linked to that event, keeps only rows where the expense is approved = 'True', groups by expense_description, and returns each description with the summed cost as total_value.",
      "reason": "All required anchors are present: event name filter, approved-only expenses, summing cost per type. Output columns align with requested information. Empty result is permissible if no such approved expenses exist.",
      "verdict": true,
      "evidence": "sql_result columns: type, total_value – no rows returned, indicating no approved expenses for that event."
    }
  },
  {
    "question_id": 1238,
    "result": {
      "expected_answer": "ID and sex of the single oldest patient (earliest Birthday) who has an SLE diagnosis and a normal hemoglobin level (10 < HGB < 17).",
      "sql_description": "Selects patients appearing in Examination with Diagnosis='SLE' whose Laboratory record shows HGB between 10 and 17, orders them by Birthday ascending (oldest first), and returns the ID and SEX of the first row.",
      "reason": "Query applies all required anchors: SLE diagnosis, normal hemoglobin range, identifies oldest via ascending Birthday, and outputs only ID and SEX. Using Examination.Diagnosis instead of Patient.Diagnosis is a reasonable schema choice and does not violate requirements.",
      "verdict": true,
      "evidence": "sql_result shows one row: ID 48473, SEX 'F' (columns: ID, SEX)."
    }
  },
  {
    "question_id": 1235,
    "result": {
      "expected_answer": "For each patient whose red blood cell count (RBC) is below 3.5, return the patient ID, the patient’s age, and the diagnosis.",
      "sql_description": "1) Builds PatientAge to compute age as the current year minus birth year.\n2) Builds LowerRBC to collect IDs from Laboratory where RBC < 3.5.\n3) Joins Patient with these two CTEs and selects ID, computed Age, and Diagnosis.\n4) Outputs every matching row (duplicates possible when multiple lab records exist).",
      "reason": "Query enforces the key anchor RBC < 3.5, links back to the patient table, and returns exactly the requested fields (ID, age, diagnosis). Duplication is harmless because the question does not ask for distinct results. Age calculation matches evidence definition (year difference). Therefore it satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows columns ID, Age, Diagnosis with patients 27654 (age 89, diagnosis ‘RA, SLE susp’), 30609 (81, ‘SLE, MCTD’), etc., matching requested information."
    }
  },
  {
    "question_id": 1201,
    "result": {
      "expected_answer": "A single numeric value: the percentage (0–100) of patients born in 1980 who have a diagnosis of RA that are female.",
      "sql_description": "Builds a sub-set of Patient records joined to Examination where Birthday year is 1980 and Examination.Diagnosis = 'RA'; from these rows it counts how many have SEX = 'F' and divides by the total row count, multiplying by 100 to give the percentage.",
      "reason": "Contains required anchors (year 1980, RA diagnosis, female sex) and returns the requested percentage. Although duplicate Examination rows per patient could exist, SEX is patient-level so ratio is unaffected; acceptable under lenient ambiguity handling.",
      "verdict": true,
      "evidence": "Result set has column percentage_women with value NULL (row 0), reflecting no matching patients."
    }
  },
  {
    "question_id": 1189,
    "result": {
      "expected_answer": "Count of distinct patients whose examination shows Thrombosis level 2, ANA value \"S\", and aCL IgM greater than 120% of the overall average aCL IgM.",
      "sql_description": "Computes the overall average aCL IgM, multiplies it by 1.2, selects examination rows with Thrombosis = 2, ANA = 'S', and aCL IgM above that threshold, then counts distinct patient IDs.",
      "reason": "All required anchors—Thrombosis=2, ANA='S', aCL IgM > 1.2×avg, and counting patients—are correctly implemented. Counting DISTINCT IDs avoids multiple exams per patient, matching the request for a patient count.",
      "verdict": true,
      "evidence": "sql_result shows column patient_count with value 0 (row 0)."
    }
  },
  {
    "question_id": 1410,
    "result": {
      "expected_answer": "The member’s full name (first_name + last_name) and the total sum of all expenses (cost) linked to member_id = 'rec4BLdZHS2Blfp4v'.",
      "sql_description": "Joins member with expense, filters to member_id 'rec4BLdZHS2Blfp4v', aggregates SUM(cost), returns full name (concatenated) and total_cost.",
      "reason": "Query applies correct filter, sums costs for that member, outputs requested fields; no required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows columns full_name and total_cost with one row: ('Sacha Harrison', 866.25)."
    }
  },
  {
    "question_id": 1460,
    "result": {
      "expected_answer": "Full name (first and last concatenated) of the member whose expense description equals 'Water, Veggie tray, supplies', plus the cost of that expense.",
      "sql_description": "Joins expense with member, filters expenses where expense_description = 'Water, Veggie tray, supplies', returns member full name and the cost.",
      "reason": "Query uses correct filter on expense_description, joins to get member name, returns required columns; meets all anchors.",
      "verdict": true,
      "evidence": "Result row: full_name='Elijah Allen', cost=28.15"
    }
  },
  {
    "question_id": 1247,
    "result": {
      "expected_answer": "The count of distinct male patients (Sex = 'M') whose white blood cell count is in the normal range (>3.5 and <9.0) and who simultaneously have an abnormal fibrinogen level (<=150 or >=450).",
      "sql_description": "Joins Laboratory and Patient, filters to male records, keeps rows where WBC is normal (3.5–9.0) and FG abnormal (<=150 or >=450), then counts DISTINCT patient IDs.",
      "reason": "All required anchors (male, normal WBC, abnormal FG, distinct patients) are present; query logic aligns exactly with the question.",
      "verdict": true,
      "evidence": "COUNT(DISTINCT l.ID) column returns 6."
    }
  },
  {
    "question_id": 1220,
    "result": {
      "expected_answer": "List of patient IDs with their sex and birthday for every patient whose laboratory urea nitrogen result equals 29 (i.e., right at the borderline passing value).",
      "sql_description": "Joins Patient to Laboratory on ID and returns each row’s ID, SEX, and Birthday where Laboratory.UN = 29; thus outputs those patients (possibly with duplicates if they had several tests at that value).",
      "reason": "The query applies the required anchor UN = 29 and selects the requested attributes. Duplicates per patient are permissible because the question does not explicitly ask for distinct records.",
      "verdict": true,
      "evidence": "sql_result shows columns ID, SEX, Birthday with multiple rows such as ID 27654 F 1936-03-25 and ID 444499 M 1954-01-24, confirming the filter."
    }
  },
  {
    "question_id": 1252,
    "result": {
      "expected_answer": "A single integer: the number of patients whose Ig G is between 900 and 2000 and whose Symptoms field is not NULL.",
      "sql_description": "Joins Laboratory and Examination on patient ID, filters rows where IGG > 900 and IGG < 2000 and Symptoms IS NOT NULL, then counts distinct patient IDs.",
      "reason": "All required anchors (IGG normal range, Symptoms not NULL, counting distinct patients) are present and correctly applied. Result type (count) matches the question.",
      "verdict": true,
      "evidence": "Returned column COUNT(DISTINCT e.ID) with value 1."
    }
  },
  {
    "question_id": 1243,
    "result": {
      "expected_answer": "A single numeric value: the percentage (0–100) of female records among the abnormal-PT (PT >= 14) records for patients older than 55.",
      "sql_description": "1) Gets patients whose age (year diff) > 55 with their sex.\n2) Gets laboratory rows with PT >= 14.\n3) Joins the two sets and, over the joined rows, divides the number of rows whose SEX='F' by the total number of joined rows, multiplying by 100. Returns this as Female_Percentage.",
      "reason": "The query enforces both required anchors: age > 55 (via Patients_older_than_55) and abnormal PT >= 14 (via Abnormal_PT). It then computes the share of female among these rows. Whether to count per row or per patient is ambiguous; the evidence formula itself counts rows, so the chosen interpretation is reasonable. Therefore the SQL answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one column Female_Percentage with value ≈78.36."
    }
  },
  {
    "question_id": 1157,
    "result": {
      "expected_answer": "ID, sex (M/F), and diagnosed disease for every patient whose thrombosis degree is 2 (severe).",
      "sql_description": "Joins Patient with Examination, keeps only rows where Examination.Thrombosis = 2, and returns Patient.ID, Patient.SEX, and Examination.Diagnosis.",
      "reason": "Query applies the required thrombosis=2 filter and outputs the requested fields. Using the diagnosis from Examination instead of Patient is a reasonable interpretation since both tables hold the column and question is ambiguous.",
      "verdict": true,
      "evidence": "sql_result shows columns ID, SEX, Diagnosis for three rows, matching requested attributes."
    }
  },
  {
    "question_id": 1225,
    "result": {
      "expected_answer": "For each sex (male and female), provide a concatenated list of all patient IDs whose total bilirubin (T-BIL) value is 2.0 or higher (i.e., outside the normal range).",
      "sql_description": "Joins Patient with Laboratory, keeps rows where T-BIL ≥ 2.0, selects patient ID and sex, then GROUP_CONCATs distinct patient IDs for each sex.",
      "reason": "Query applies the correct out-of-range criterion (T-BIL ≥ 2.0), preserves patient sex, removes duplicate patient IDs, and returns grouped lists, matching the question’s requirements.",
      "verdict": true,
      "evidence": "Result has columns SEX and PatientIDs with two rows (F, M) each listing distinct IDs, meeting the requested grouping."
    }
  },
  {
    "question_id": 1267,
    "result": {
      "expected_answer": "The number of distinct patients whose anti-SM result is normal (SM = '-' or '+-') and whose thrombosis value is 0.",
      "sql_description": "1) Builds a list of patient IDs that have a laboratory record with SM in ('-', '+-'). 2) Joins that list back to Examination rows and counts all rows where Thrombosis = 0. The final COUNT(*) is the number of Examination records (not necessarily distinct patients) that satisfy the conditions.",
      "reason": "The question asks for the count of patients, therefore duplicates coming from multiple Examination rows for the same patient must be eliminated. The query counts rows, not distinct patients, so it can over-count when a patient has more than one Examination record with Thrombosis = 0. Required anchor «distinct patients» is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1254,
    "result": {
      "expected_answer": "Count of distinct patients whose IgA value is between 80 and 500 (normal range) and whose First Date of hospital visit is on or after 1990-01-01.",
      "sql_description": "Finds distinct patient IDs that appear simultaneously in Examination, Laboratory and Patient tables, keeps those with Laboratory.IGA > 80 and < 500 and whose Patient.First Date year is 1990 or later, then counts them.",
      "reason": "Query imposes an extra requirement that each patient also have a record in Examination (via an inner join). The question only talks about IgA level (Laboratory) and hospital visit date (Patient). Requiring an Examination entry is an invented constraint that can remove eligible patients, so the SQL is not guaranteed to answer the question correctly.",
      "verdict": false
    }
  },
  {
    "question_id": 1255,
    "result": {
      "expected_answer": "The single disease name that occurs most frequently among patients whose IGM lab value is ≤40 or ≥400.",
      "sql_description": "Selects all Diagnosis values from Examination for patients whose Lab records have abnormal IGM (≤40 or ≥400), groups them, orders by the number of occurrences, and returns the diagnosis with the highest count.",
      "reason": "Query applies the abnormal-IGM filter, retrieves the diagnoses for those patients, counts occurrences, and returns the most common one. Choice of Examination.Diagnosis (instead of Patient.Diagnosis) is a reasonable interpretation; no required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows one row: Diagnosis = 'SLE' (row0.Diagnosis)"
    }
  },
  {
    "question_id": 1275,
    "result": {
      "expected_answer": "A single integer: the number of distinct male patients (SEX = 'M') who have at least one laboratory record where both CENTROMEA and SSB are in ('-', '+-').",
      "sql_description": "1) Builds NormalPatients = distinct patient IDs that have a laboratory row with CENTROMEA and SSB values in ('-', '+-'). 2) Counts distinct Patient.IDs whose SEX = 'M' and whose ID appears in NormalPatients.",
      "reason": "Query applies required normal-value filters on CENTROMEA and SSB, enforces DISTINCT patient counting, and then restricts to male sex. All explicit anchors (normal ranges, sex, distinct counting) are satisfied.",
      "verdict": true,
      "evidence": "Result set has column COUNT(DISTINCT Patient.ID) with value 0, indicating no such male patients in data; format matches expected single integer answer."
    }
  },
  {
    "question_id": 1265,
    "result": {
      "expected_answer": "The number of distinct patients whose anti-ribonuclear protein test result is '-' or '+-' (normal) and whose Admission field is '+', meaning they were admitted to the hospital.",
      "sql_description": "Joins Patient and Laboratory on patient ID, keeps rows where RNP is '-' or '+-' and Admission is '+', selects distinct patient IDs, then counts those IDs.",
      "reason": "All required anchors are present: RNP values '-', '+-', Admission '+', and DISTINCT at patient level before counting. Therefore the query correctly returns the desired count.",
      "verdict": true,
      "evidence": "sql_result shows column Normal_RNP_Patient_Count with value 0, matching the query’s intent."
    }
  },
  {
    "question_id": 1241,
    "result": {
      "expected_answer": "Return the number of distinct patients whose platelet (PLT) value is below 100 (lower-than-normal) and compare it with the number of distinct patients whose PLT is above 400 (higher-than-normal), reporting their difference (lower minus higher).",
      "sql_description": "Counts laboratory rows where PLT<100 and PLT>400, subtracts the high count from the low count, and returns that difference.",
      "reason": "The question asks for counts of patients, so each patient should be counted once regardless of multiple lab records. The query counts rows, not DISTINCT patient IDs, thereby violating the required patient anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1035,
    "result": {
      "expected_answer": "The list of team_fifa_api_id values whose buildUpPlaySpeed is >50 and <60.",
      "sql_description": "Selects team_fifa_api_id from Team_Attributes rows where buildUpPlaySpeed is between 51 and 59, returning every matching row (duplicates possible).",
      "reason": "Query applies the correct numeric filters and returns the requested column. Whether duplicates are removed is ambiguous; providing all matching rows still satisfies the request for the IDs of such teams.",
      "verdict": true,
      "evidence": "sql_result shows a column team_fifa_api_id with values like 434, 77, 614, 1901, 650, 1861, 229, 111989, 1 (rows 0-19), all meeting the speed condition."
    }
  },
  {
    "question_id": 1195,
    "result": {
      "expected_answer": "A single numeric value: the average ALB (blood albumin) among patients who are female, have PLT > 400, and are diagnosed with SLE.",
      "sql_description": "Selects female patients (Patient.SEX='F') that appear in Examination records with Diagnosis='SLE'; finds their Laboratory rows where PLT>400; averages ALB over those rows.",
      "reason": "All required anchors—female, PLT>400, SLE diagnosis—are applied. Averaging ALB over the qualifying lab rows satisfies the question; row-level vs patient-level averaging is an acceptable interpretation.",
      "verdict": true,
      "evidence": "sql_result shows column AvgBloodAlbumin with value 4.3 for the computed average."
    }
  },
  {
    "question_id": 1256,
    "result": {
      "expected_answer": "The total number of patients whose C-reactive protein value is recorded as '+' (abnormal) and whose Patient.Description is NULL (no data recorded).",
      "sql_description": "Joins Laboratory and Patient, filters rows where Laboratory.CRP = '+', Patient.Description IS NULL, and counts distinct patient IDs.",
      "reason": "All required anchors are present: CRP '+' for abnormal, Description NULL for no recorded data, and distinct patients counted. Logic matches the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT p.ID) = 25 (row 0)."
    }
  },
  {
    "question_id": 1179,
    "result": {
      "expected_answer": "The anti-Cardiolipin antibody (aCL IgM) concentration value recorded on 1993-11-12 for the patient whose SLE diagnosis entry is dated 1994-02-19.",
      "sql_description": "Finds the patient row with Diagnosis='SLE' and Description='1994-02-19', then gets that same patient’s aCL IgM measurement from the Examination taken on 1993-11-12. Returns that single numeric value.",
      "reason": "All explicit anchors are present: SLE diagnosis, description date 1994-02-19 (identifying the patient), examination date 1993-11-12, and the requested aCL IgM value. Query joins correctly via patient ID and outputs only the desired concentration, matching the question’s intent.",
      "verdict": true,
      "evidence": "sql_result rows: [aCL IgM] → [4.1]"
    }
  },
  {
    "question_id": 1029,
    "result": {
      "expected_answer": "A list of the buildUpPlaySpeed values (attack-building speeds) for each of the four teams whose buildUpPlaySpeed is highest among all teams.",
      "sql_description": "Calculates each team’s maximum buildUpPlaySpeed over all dates, orders those maxima descending, keeps the top 4 teams, and outputs only those four speed values.",
      "reason": "The query uses MAX(buildUpPlaySpeed) per team, ranks by that value, limits to 4 teams, and returns the speeds. This satisfies the need to show the attack-building speeds of the top four teams; team names are not explicitly required.",
      "verdict": true,
      "evidence": "Returned column max_speed with four rows: 80, 78, 78, 77."
    }
  },
  {
    "question_id": 1302,
    "result": {
      "expected_answer": "The number of distinct patients whose creatinine phosphokinase (CPK) value is below 250 (normal range) and who have at least one positive finding on the coagulation measures KCT, RVVT, or LAC.",
      "sql_description": "Builds two patient sets: 1) patients with any laboratory record where CPK < 250; 2) patients with any examination record where KCT='+' OR RVVT='+' OR LAC='+'; intersects the two sets and counts distinct patient IDs.",
      "reason": "Captures the two required conditions (normal CPK, positive coagulation) and returns a distinct patient count, matching the question. Ambiguity about needing all vs any normal CPK per patient is reasonable; query adopts the common 'any normal reading' interpretation, which is not contradicted by the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT nr.ID) = 1, giving the requested patient count."
    }
  },
  {
    "question_id": 1037,
    "result": {
      "expected_answer": "Percentage of individual players born in 1987–1992 whose preferred_foot is 'left' (left-footed players ÷ total players in that birth-year range × 100). Each player should be counted once.",
      "sql_description": "Joins Player with all of its Player_Attributes rows, restricts players to birth years 1987-1992, then divides the count of attribute rows whose preferred_foot is 'left' by the total count of attribute rows, returning ~24.56%. Players with more attribute snapshots are counted multiple times.",
      "reason": "The query counts attribute records instead of distinct players, biasing both numerator and denominator. The question explicitly asks for percentage of players, not snapshots, so distinct players is a required anchor that is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1242,
    "result": {
      "expected_answer": "All patient identifiers whose laboratory record in the year 1984 shows a platelet (PLT) value within the normal range 100-400 and whose current age is less than 50 years.",
      "sql_description": "1) Builds PatientsBelow50: selects patient IDs where current year minus birth year is <50. 2) Builds Examinations1984: selects laboratory rows from 1984 with PLT between 100 and 400. 3) Returns DISTINCT IDs that appear in both sets.",
      "reason": "Query checks the required year (1984), PLT normal range, and current age <50, then lists the patient IDs. All explicit anchors are satisfied; no extraneous conditions added.",
      "verdict": true,
      "evidence": "sql_result shows 5 IDs column [ID] rows 0-4, consistent with expected list format."
    }
  },
  {
    "question_id": 1205,
    "result": {
      "expected_answer": "A single Yes/No indicating whether patient 57266’s uric-acid value is in the defined “normal range” (UA>8 for males, UA>6.5 for females).",
      "sql_description": "Joins Patient and Laboratory for id 57266, evaluates the rule on every laboratory row, and outputs a Yes/No flag for each record (20 rows here).",
      "reason": "The question calls for one overall judgment, but the query emits one flag per lab record, producing both ‘Yes’ and ‘No’. It therefore does not supply a clear single answer for the patient.",
      "verdict": false
    }
  },
  {
    "question_id": 1068,
    "result": {
      "expected_answer": "A single numeric value: the mean overall_rating of all player attribute records dated 2010-2015 inclusive for players whose height is greater than 170 cm.",
      "sql_description": "Finds players with height >170, pulls their overall_rating rows dated 2010-2015, then returns AVG(overall_rating) across those rows.",
      "reason": "All required constraints (height filter and date range) are applied and the query aggregates overall_rating with AVG, matching the requested metric. No anchors are missing.",
      "verdict": true,
      "evidence": "sql_result shows one column average_rating with value 68.901357 (row 0)."
    }
  },
  {
    "question_id": 1144,
    "result": {
      "expected_answer": "The finishing score and curve score of the player (or players) whose weight is the maximum recorded in the Player table.",
      "sql_description": "Finds the player_api_id(s) whose weight equals the maximum weight in Player, then looks up the matching rows in Player_Attributes, orders those rows by date descending, and returns the finishing and curve values from the most recent record; finally limits to one row.",
      "reason": "Captures the heaviest-weight anchor via MAX(weight) and returns the requested finishing and curve attributes. Using the latest attribute record is a reasonable interpretation because the question does not specify the date. No required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result columns: finishing_rate, curve_score; first row shows values 13, 13."
    }
  },
  {
    "question_id": 1232,
    "result": {
      "expected_answer": "List each patient ID with their sex and (current year minus birth year) age for patients whose laboratory record shows GLU ≥ 180 (high) and T-CHO < 250 (normal).",
      "sql_description": "Calculates each patient’s age, selects patient IDs whose Laboratory rows have GLU >= 180 and T-CHO < 250, then returns those patients’ ID, SEX and age; duplicates may appear when multiple qualifying lab rows exist.",
      "reason": "Query applies the required GLU ≥180 and T-CHO <250 constraints, links to Patient to fetch sex and age, returning the requested columns. Extra duplicates do not violate the question; all anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result columns: ID, SEX, age; rows show patients such as 57266 M 102, 2371753 F 93, etc., matching required output shape."
    }
  },
  {
    "question_id": 1115,
    "result": {
      "expected_answer": "A single numeric value: the percentage by which Landon Donovan’s overall_rating on 2013-07-12 exceeds Jordan Bowery’s rating on the same day, computed as (Landon – Jordan) / Landon * 100.",
      "sql_description": "Gets overall_rating rows for the two named players where date equals the literal string ‘2013-07-12’, then calculates 100 * (Landon – Jordan) / Landon.",
      "reason": "Anchors are present, and formula matches the evidence, but the strict equality to the date string likely misses the timestamped rows in Player_Attributes, producing no records; the query therefore returns an empty result instead of the required percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 1092,
    "result": {
      "expected_answer": "The name of the league with the highest number of matches during the 2008/2009 season.",
      "sql_description": "Counts matches for each league where season = '2008/2009', orders the counts descending, and returns the league name with the largest count (top 1).",
      "reason": "Query applies the correct season filter, aggregates by league, selects the maximum-count league, and outputs only its name, satisfying all explicit anchors (season 2008/2009, most matches).",
      "verdict": true,
      "evidence": "sql_result shows row 0 league_name = 'England Premier League', matching expected output structure."
    }
  },
  {
    "question_id": 1028,
    "result": {
      "expected_answer": "The team name of the club that recorded the greatest number of away victories (away_team_goal > home_team_goal) in Scotland Premier League matches during the 2009/2010 season.",
      "sql_description": "Counts matches where the away team won for each away_team_api_id in Scotland Premier League during 2009/2010, orders by that count descending, and returns the team_long_name of the highest-count team (top 1).",
      "reason": "All required anchors are present: league filter, season filter, away-win condition, aggregation to count wins, selection of the maximum, and return of the team name. Thus the query answers the question.",
      "verdict": true,
      "evidence": "sql_result row0 team_long_name = 'Celtic'"
    }
  },
  {
    "question_id": 1141,
    "result": {
      "expected_answer": "Return whether KSV Cercle Brugge’s build-up play speed class is Slow, Balanced or Fast.",
      "sql_description": "Looks up KSV Cercle Brugge in Team, joins to Team_Attributes, selects the most recent (ORDER BY date DESC LIMIT 1) buildUpPlaySpeedClass value.",
      "reason": "Query anchors the correct team, retrieves the buildUpPlaySpeedClass, and limits to one (latest) record—adequately answering which class (Slow/Balanced/Fast) the team has. Latest-record assumption is a reasonable interpretation since multiple dated rows exist.",
      "verdict": true,
      "evidence": "sql_result shows buildUpPlaySpeedClass = 'Balanced' in row 0."
    }
  },
  {
    "question_id": 854,
    "result": {
      "expected_answer": "Latitude and longitude coordinates of each circuit that has hosted the Australian Grand Prix.",
      "sql_description": "Joins races with circuits, filters races by name = 'Australian Grand Prix', returns the lat and lng columns of the associated circuits.",
      "reason": "Query applies the required anchor (race name) and outputs the requested coordinates. Extra duplicates do not violate any stated requirement.",
      "verdict": true,
      "evidence": "Returned columns lat, lng (e.g., row0: -34.9272, 138.617) correspond to circuit coordinates."
    }
  },
  {
    "question_id": 1136,
    "result": {
      "expected_answer": "The count of distinct players whose crossing score equals the maximum crossing value in the data set and whose preferred_foot is 'left'.",
      "sql_description": "Computes the overall maximum crossing value, selects rows with that crossing value and preferred_foot = 'left', then counts distinct player_api_id.",
      "reason": "Query applies both required anchors (MAX(crossing) and preferred_foot='left') and returns the number of unique players satisfying them. This matches the question.",
      "verdict": true,
      "evidence": "sql_result shows column player_count with value 2, indicating two such players."
    }
  },
  {
    "question_id": 1135,
    "result": {
      "expected_answer": "Four player_api_id values corresponding to the right-footed players with the very lowest potential scores in the database (the bottom four by potential).",
      "sql_description": "For players whose preferred_foot is 'right', it first takes each player’s minimum recorded potential, then orders these minima ascending and returns the first 4 player_api_id values.",
      "reason": "Query enforces preferred_foot='right', evaluates low potential per player, ranks by that potential ascending, and selects 4 ids, satisfying the request for the top four IDs among the lowest-potential right-footed players. Ambiguity about which date’s potential to use is reasonably resolved by using each player’s minimum value.",
      "verdict": true,
      "evidence": "sql_result shows 4 rows with column player_api_id: 41496, 166963, 8893, 168342."
    }
  },
  {
    "question_id": 1058,
    "result": {
      "expected_answer": "The identity of the player (among the tallest and the shortest players) who has the higher average finishing rate, optionally with the associated average value.",
      "sql_description": "Finds players whose height equals the global maximum or minimum, computes each such player’s average finishing score from Player_Attributes, then returns the one with the highest average finishing (player_api_id, height, avg_finishing).",
      "reason": "Query respects both required anchors: it restricts to tallest-height and shortest-height players and compares their average finishing, returning the one with the higher average. Returning player_api_id is an acceptable identifier for “who”.",
      "verdict": true,
      "evidence": "Row0: player_api_id=97226, height=157, avg_finishing=60.9 (shortest player outranks tallest)."
    }
  },
  {
    "question_id": 1110,
    "result": {
      "expected_answer": "The textual buildUpPlayPassingClass value (e.g. Short / Mixed / Long) for FC Lorient on 2010-02-22.",
      "sql_description": "Looks for a match dated 2010-02-22 that involves FC Lorient, takes the team_api_id from that match, then picks the latest Team_Attributes row at or before the same date and returns its buildUpPlayPassingClass.",
      "reason": "The query requires FC Lorient to have played a match on 2010-02-22. If no such match exists, the CTE is empty and the final join returns nothing (as shown by the empty result). The question only depends on the Team_Attributes record dated 2010-02-22 and does not stipulate the existence of a match, so the added constraint can exclude the correct answer. Therefore the SQL does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 892,
    "result": {
      "expected_answer": "The full name (forename and surname) of the driver whose cumulative points (sum of points across all driver standings records) is the highest, together with that total points value.",
      "sql_description": "Computes total points for each driver by summing driverStandings.points, joins to drivers for names, orders by total points descending and returns the top driver’s forename, surname and total_points.",
      "reason": "Query uses SUM(points) to find each driver’s total, selects the maximum via ORDER BY DESC LIMIT 1, and outputs the required name fields plus the points amount. All requested anchors (total points aggregate, full name) are satisfied.",
      "verdict": true,
      "evidence": "Row0: forename=Lewis, surname=Hamilton, total_points=24509.0"
    }
  },
  {
    "question_id": 1251,
    "result": {
      "expected_answer": "The number of distinct patients whose Ig G value is 2000 or higher (above the normal upper bound).",
      "sql_description": "Counts DISTINCT patient IDs in the Laboratory table where IGG >= 2000.",
      "reason": "All required anchors are met: uses IGG >= 2000 to define \"higher than normal\" and counts DISTINCT patients, matching the question and evidence.",
      "verdict": true,
      "evidence": "COUNT(DISTINCT l.ID)=136"
    }
  },
  {
    "question_id": 868,
    "result": {
      "expected_answer": "Latitude and longitude coordinates of the circuit that hosts the Malaysian Grand Prix.",
      "sql_description": "Joins races with circuits and filters races whose name is 'Malaysian Grand Prix', returning the circuit's latitude and longitude.",
      "reason": "Query uses the correct race name anchor and retrieves the required coordinate fields; duplicates do not violate the question.",
      "verdict": true,
      "evidence": "sql_result rows show lat=2.76083, lng=101.738 for all returned entries (columns lat, lng)."
    }
  },
  {
    "question_id": 1148,
    "result": {
      "expected_answer": "A single numeric percentage: (number of distinct players whose height < 180 cm AND overall_rating > 70) divided by (total number of distinct players) * 100.",
      "sql_description": "Counts rows in Player_Attributes joined to Player that meet height <180 and overall_rating>70, then divides that count by total number of players; does not deduplicate multiple attribute records per player.",
      "reason": "Question asks about players, not attribute rows. Each player can appear many times in Player_Attributes, so DISTINCT on player identifiers is required for the numerator. Omission inflates the count (result >100%), violating anchor ‘count of players’.",
      "verdict": false
    }
  },
  {
    "question_id": 846,
    "result": {
      "expected_answer": "The driverRef values for the five drivers with the slowest (largest) q1 times – i.e., the ones eliminated in Q1 – for raceId = 20.",
      "sql_description": "Finds every driver whose q1 time equals the single maximum q1 time in race 20 (after casting q1 to REAL) and returns their driverRef.",
      "reason": "Elimination requires the bottom five q1 times, not just the single (or tied) maximum. The query therefore omits four of the five eliminated drivers (or includes many unintended ones due to the cast issue). Missing anchor: selection of the 5 slowest drivers.",
      "verdict": false
    }
  },
  {
    "question_id": 1094,
    "result": {
      "expected_answer": "The percentage by which Ariel Borysiuk’s overall rating exceeds Paulin Puel’s, computed as (Ariel − Paulin) / Paulin × 100.",
      "sql_description": "Finds the average overall_rating for each of the two players over all Player_Attributes records, then calculates 100 * (avg_Ariel − avg_Paulin) / avg_Paulin.",
      "reason": "Query selects the two specified players, derives their overall ratings, and applies the requested percentage-difference formula. Averaging across all attribute rows is a reasonable interpretation in absence of a specified date criterion.",
      "verdict": true,
      "evidence": "sql_result shows one row with percentage_higher ≈ 16.86%"
    }
  },
  {
    "question_id": 865,
    "result": {
      "expected_answer": "The identity of the oldest driver (earliest date of birth) among those who recorded a finish time (time IS NOT NULL) in raceId 592.",
      "sql_description": "Joins drivers with results, keeps rows where raceId = 592 and time is not NULL, orders the surviving drivers by dob ascending (earliest first) and returns the first row (driverId, forename, surname, dob).",
      "reason": "All required anchors are met: raceId 592, finished drivers (time NOT NULL), and oldest determined via earliest dob. Returning one driver satisfies the singular phrasing; tie-handling not specified.",
      "verdict": true,
      "evidence": "driverId, forename, surname, dob => (306, Jean-Pierre, Beltoise, 1937-04-26)"
    }
  },
  {
    "question_id": 902,
    "result": {
      "expected_answer": "The names of races in which driver Alex Yoong finished with a position (track number) less than 20.",
      "sql_description": "Finds all results rows for driver Alex Yoong where position < 20, joins to races, and returns the race names.",
      "reason": "SQL applies correct driver filter and the <20 position condition, returning the race names, which matches the question intent.",
      "verdict": true,
      "evidence": "sql_result shows column 'name' with 5 race names (e.g., Brazilian Grand Prix, Canadian Grand Prix, etc.), matching expected output type."
    }
  },
  {
    "question_id": 879,
    "result": {
      "expected_answer": "The nationality of the driver who recorded the single highest value in the column fastestLapSpeed across all race results.",
      "sql_description": "Finds the maximum fastestLapSpeed in results, then returns the nationality of any driver whose fastestLapSpeed equals that maximum.",
      "reason": "Query captures the MAX fastestLapSpeed anchor and retrieves the associated driver nationality; duplicates/ties do not violate the question’s requirement.",
      "verdict": true,
      "evidence": "sql_result shows one row: nationality = 'Brazilian' for the driver with the fastestLapSpeed."
    }
  },
  {
    "question_id": 1270,
    "result": {
      "expected_answer": "A single integer: the number of DISTINCT patients whose anti-scl70 result is normal (SC170 in ('negative','0')), whose sex is female, and who have NO Examination record that reports any symptom (i.e., for that patient, Symptoms must be NULL for all rows or there are no Examination rows at all).",
      "sql_description": "1) Builds a list of distinct female patients with normal anti-scl70 results.\n2) Left-joins those patients to Examination and keeps rows where Examination.Symptoms IS NULL.\n3) Counts the distinct patient IDs that survive.",
      "reason": "The WHERE e.Symptoms IS NULL filter allows a patient to be counted if EVEN ONE Examination row has Symptoms NULL, even when other rows for the same patient contain non-NULL symptoms. Thus it fails the anchor ‘does not have any symptom’ (which requires absence of any non-NULL Symptoms).",
      "verdict": false
    }
  },
  {
    "question_id": 909,
    "result": {
      "expected_answer": "Percentage = (number of European Grand Prix races whose circuit is in Germany) ÷ (total number of European Grand Prix races) × 100.",
      "sql_description": "Builds european_races as raceIds of European Grand Prix. Then erroneously tries to find German ones by joining those raceIds to circuits on raceId = circuitId, counts them, and divides by total.",
      "reason": "Key anchor missing: correct link to Germany. The query compares raceId to circuitId, so it almost never finds matches; it does not actually count European Grand Prix races held in Germany. Therefore percentage is wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 1031,
    "result": {
      "expected_answer": "The current age (in years) of every player who had a sprint_speed of at least 97 in any record dated from 2013 through 2015, inclusive.",
      "sql_description": "Finds all records in Player_Attributes with sprint_speed >= 97 and a year between 2013 and 2015, groups by player to keep each qualifying player once, joins to Player to get birthdays, and returns each player’s present age calculated from their birthday.",
      "reason": "All required anchors are present: sprint_speed >=97, date years 2013-2015 inclusive, and age computed relative to now. Query outputs the ages of the qualifying players, matching the question’s demand.",
      "verdict": true,
      "evidence": "sql_result shows column age with value(s), e.g., row0 age=34, reflecting the calculated ages."
    }
  },
  {
    "question_id": 930,
    "result": {
      "expected_answer": "The race name where Lewis Hamilton achieved his best (lowest) rank value in the results table.",
      "sql_description": "Find all results for driver with forename='Lewis' and surname='Hamilton', sort them by fastest-lap rank ascending (ties broken by race name) and return the first race name.",
      "reason": "Query filters the correct driver, orders by rank ASC to capture the highest (minimal) rank, and returns the corresponding race name; this matches the stated requirement.",
      "verdict": true,
      "evidence": "sql_result shows one row: name = 'Belgian Grand Prix' (column 'name', row 0)."
    }
  },
  {
    "question_id": 898,
    "result": {
      "expected_answer": "Return the Japanese driver with the most recent date of birth (youngest) and his age in years (current year minus birth year). Provide both his full name and his age.",
      "sql_description": "Selects full name and age (current year − birth year) of drivers whose nationality is Japanese, orders by birth date descending so the youngest is first, and returns the top row.",
      "reason": "Query applies the necessary nationality filter, correctly identifies the youngest by ordering dob DESC, and calculates age according to the specified formula. Both requested fields (name and age) are returned.",
      "verdict": true,
      "evidence": "sql_result row0: name='Kamui Kobayashi', age=39"
    }
  },
  {
    "question_id": 1113,
    "result": {
      "expected_answer": "The defenceAggressionClass value (e.g., Contain / Press / Double) for team 'Hannover 96' on the date 2015-09-10.",
      "sql_description": "Joins Team with Team_Attributes, filters rows where team_long_name equals 'Hannover 96' and date starts with '2015-09-10', returning the defenceAggressionClass column.",
      "reason": "All required anchors (team name, specific date, correct column) are present. Query returns the requested class value, satisfying the question.",
      "verdict": true,
      "evidence": "Returned column: defenceAggressionClass; Row 0: Press"
    }
  },
  {
    "question_id": 1107,
    "result": {
      "expected_answer": "The earliest date on which Kevin Constant achieved his maximum crossing score.",
      "sql_description": "Finds all crossing records for Kevin Constant, determines his maximum crossing value, then returns the earliest (minimum) date among the records that have that max value.",
      "reason": "SQL correctly filters by player name, computes MAX(crossing), selects rows with that value, orders ascending by date, and limits to the first, satisfying the question’s requirement for the first date of the highest crossing score.",
      "verdict": true,
      "evidence": "sql_result shows one row with column date = '2013-02-15 00:00:00', matching the expected single earliest date."
    }
  },
  {
    "question_id": 897,
    "result": {
      "expected_answer": "Return the full name of the driver who has the greatest number of wins overall, together with his nationality and the highest single-race-standing points he ever scored.",
      "sql_description": "Creates a per-driver summary: total_wins = SUM(wins) over all driverStandings rows, max_points = MAX(points). It then orders drivers by total_wins descending and takes the top one, outputting full_name, nationality and max_points.",
      "reason": "Query identifies a clear interpretation (most wins = greatest summed wins across driverStandings) and supplies the requested attributes. Result therefore answers the question under this reasonable reading; all required anchors (wins ranking, name, nationality, max points) are present.",
      "verdict": true,
      "evidence": "row0: full_name=Michael Schumacher, nationality=German, max_points=148.0"
    }
  },
  {
    "question_id": 951,
    "result": {
      "expected_answer": "Number (count) of constructors whose nationality is Japanese and for which the points column equals 0 in exactly two distinct races.",
      "sql_description": "Builds a CTE of constructorIds whose points = 0 rows, grouped by constructor, counts the DISTINCT raceId occurrences; keeps only Japanese constructors; then counts how many constructors have zero-point race count = 2. Returns that count.",
      "reason": "Uses constructorResults to evaluate points=0, groups by constructor, filters to Japanese nationality and zero_points_races = 2, then counts such constructors – exactly what the question/evidence specifies.",
      "verdict": true,
      "evidence": "sql_result shows column num_japanese_constructors with value 1, matching the requested single count."
    }
  },
  {
    "question_id": 950,
    "result": {
      "expected_answer": "Names of all constructors that scored 0 points in race 291.",
      "sql_description": "Gets distinct constructor names by joining constructorResults to constructors where raceId = 291 and points = 0.",
      "reason": "Query applies the correct race filter (291) and the points = 0 condition, returns the requested constructor names; no missing or extra constraints.",
      "verdict": true,
      "evidence": "sql_result shows column \"name\" with 11 rows (e.g., Minardi, Dallara, ...), matching the requested output."
    }
  },
  {
    "question_id": 1080,
    "result": {
      "expected_answer": "The count of distinct players whose preferred foot is left and whose attacking work rate is low (i.e., they stay in position when the team attacks).",
      "sql_description": "Selects rows in Player_Attributes where preferred_foot = 'left' and attacking_work_rate = 'low', then counts the distinct player_api_id values.",
      "reason": "Matches both anchors (preferred_foot left, attacking_work_rate low) and counts unique players, which satisfies the question’s request for “how many of them”.",
      "verdict": true,
      "evidence": "sql_result shows one column COUNT(DISTINCT player_api_id) with value 189, providing the requested count."
    }
  },
  {
    "question_id": 1134,
    "result": {
      "expected_answer": "A single numeric value equal to player 6’s jumping score minus player 23’s jumping score.",
      "sql_description": "Selects rows from Player_Attributes where player_api_id = 6 and 23 respectively, forms a cross-join between them, then outputs p1.jumping – p2.jumping for every pair.",
      "reason": "Uses player_api_id to identify the players; database evidently has no such rows (empty result), so it fails to provide any difference. Even if rows existed, the cartesian join and date duplicates would return multiple values rather than the requested single difference. Required anchor (returning the difference itself) is therefore unmet.",
      "verdict": false
    }
  },
  {
    "question_id": 955,
    "result": {
      "expected_answer": "For every Formula 1 season year earlier than 1975 (year < 1975), list that year together with the average race-winning (champion) finishing time expressed in seconds, averaged over all races held in that year.",
      "sql_description": "Selects winner rows (position = 1) joined with their race year, converts the recorded finishing time from milliseconds to seconds, keeps only years < 1975, then groups by year and returns the average of those seconds for each year.",
      "reason": "All required anchors are satisfied: champions identified by position=1; time taken from milliseconds and converted to seconds; restriction to years before 1975; aggregation gives an average for each year. Output columns align with the requested information.",
      "verdict": true,
      "evidence": "sql_result shows columns [year, average_champion_time_seconds] with rows for 1950-1969 etc., matching expectations."
    }
  },
  {
    "question_id": 915,
    "result": {
      "expected_answer": "The nationality (country) of the driver who has the earliest date of birth in the drivers table – i.e., the oldest driver.",
      "sql_description": "Finds the minimum dob in drivers, then (after an unconditional Cartesian join between drivers and circuits) returns one arbitrary circuits.country value from the rows whose driver has that min dob, limited to 1.",
      "reason": "Uses circuits.country obtained via a cross-join that has no relationship to the driver, instead of the driver’s nationality; therefore the returned country is unrelated to the oldest driver.",
      "verdict": false
    }
  },
  {
    "question_id": 857,
    "result": {
      "expected_answer": "Latitude and longitude (coordinate position) of the circuit where the race named \"Abu Dhabi Grand Prix\" is held.",
      "sql_description": "Joins races with their circuits and returns the lat and lng of the circuit for all rows where races.name = 'Abu Dhabi Grand Prix'.",
      "reason": "Query properly filters by the race name and outputs the requested coordinate columns. Duplicate rows do not alter the returned coordinate values, so the essential information is correct.",
      "verdict": true,
      "evidence": "sql_result shows lat and lng columns; all rows 24.4672, 54.6031."
    }
  },
  {
    "question_id": 861,
    "result": {
      "expected_answer": "The car/driver number (from drivers table) of the driver whose Q3 lap time is 1 minute 54 seconds in qualifying session (raceId = 903).",
      "sql_description": "Joins qualifying with drivers and returns the driver’s fixed number where raceId = 903 and q3 time equals the literal string ‘0:01:54’.",
      "reason": "The key anchor is the driver whose q3 time starts with ‘1:54’ (format ‘M:SS%’). The query requires an exact string match to ‘0:01:54’, which does not follow the indicated format and produced no rows. Therefore it fails to capture the intended driver.",
      "verdict": false
    }
  },
  {
    "question_id": 877,
    "result": {
      "expected_answer": "Identify the youngest (latest date of birth) driver among those who recorded a finish time (time IS NOT NULL) in race 872.",
      "sql_description": "Joins results with drivers, filters to raceId 872 and non-NULL finish time, orders by dob descending (youngest first) and returns the top driver’s id, forename, surname, and dob.",
      "reason": "All required anchors (race 872, finished drivers, youngest criterion) are present and correctly applied; ordering by dob DESC with LIMIT 1 retrieves the driver with the latest birthdate, fulfilling the question.",
      "verdict": true,
      "evidence": "Returned row: driverId 815, Sergio Pérez, dob 1990-01-26 (columns: driverId, forename, surname, dob)."
    }
  },
  {
    "question_id": 972,
    "result": {
      "expected_answer": "IDs and codes for every driver whose year of birth is 1971 and who appears in any race result with a non-NULL fastestLapTime value.",
      "sql_description": "Finds drivers born in 1971 who have at least one non-NULL fastestLapTime entry in results, orders them by the numeric value of that lap time, and returns only the single driver with the overall smallest lap time.",
      "reason": "The LIMIT 1 keeps only one driver, while the question asks for all such drivers. Therefore required drivers may be omitted.",
      "verdict": false
    }
  },
  {
    "question_id": 944,
    "result": {
      "expected_answer": "A single numeric value: the percentage by which the winner of the 2008 Australian Grand Prix was quicker than the slowest classified finisher ( (last_time − winner_time) / last_time * 100 ).",
      "sql_description": "Finds the winner’s milliseconds time (requires it to be NOT NULL), finds the maximum milliseconds among all classified drivers in the same race, then returns 100*(max-winner)/max.",
      "reason": "In this dataset the winner’s exact finish time is stored only in the text column (HH:MM:SS.mmm) and its milliseconds field is NULL. By filtering r.milliseconds IS NOT NULL the query eliminates the champion row, so no champion_time is obtained and the CTE is empty; therefore the calculation cannot be performed. The required anchor (use the champion’s finish time) is effectively missed.",
      "verdict": false
    }
  },
  {
    "question_id": 990,
    "result": {
      "expected_answer": "The constructorRef and website (url) of the constructor whose car won (finished 1st) in the 2009 Singapore Grand Prix.",
      "sql_description": "Find the raceId for the 2009 Singapore GP, then pick the constructorId of the result with the smallest value in the milliseconds column (NULLs sorted first), finally return that constructor’s constructorRef and url.",
      "reason": "Champion must be the result with position 1, but the query relies on MIN(milliseconds). Because NULL milliseconds (common for DNFs) sort first in SQL, the query can select a non-finisher. It does not explicitly filter by position/positionOrder or ensure non-NULL times, so the champion anchor is not guaranteed. Returned team (toro_rosso) is historically incorrect, indicating the flaw.",
      "verdict": false
    }
  },
  {
    "question_id": 989,
    "result": {
      "expected_answer": "Return the driver (full name) who won the 2008 Canadian Grand Prix (position 1 in that race) together with his recorded finish time.",
      "sql_description": "Finds the driver whose result row has positionOrder = 1 in any race held in 2008 whose CIRCUIT name is literally 'Canadian Grand Prix'; returns that driver’s full name and the time value from results.",
      "reason": "The question anchors on the RACE named 'Canadian Grand Prix'; the query instead filters on circuits.name. In the schema, Canadian Grand Prix is stored in races.name, while circuits.name is the track (e.g., Circuit Gilles-Villeneuve). This mismatch makes the filter false and omits the required race, producing no data. Required race anchor not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 978,
    "result": {
      "expected_answer": "For each circuit located in Austria, provide its location and coordinates (lat, lng) along with the number of times a race was held there.",
      "sql_description": "Joins circuits with races, filters circuits where country = 'Austria', groups by each circuit's location and coordinates, and counts how many race records are linked to each circuit, returning location, lat, lng, and the count.",
      "reason": "Matches all required anchors: restricts to Austrian circuits, counts how many races (times held) per circuit, and returns location and coordinates as requested.",
      "verdict": true,
      "evidence": "Returned columns: location, lat, lng, circuit_count; rows show Spielburg (29) and Styria (1)."
    }
  },
  {
    "question_id": 1014,
    "result": {
      "expected_answer": "For each circuit located in Italy, return its lap record – i.e., the fastest recorded lap time on that circuit (one record per circuit). Including the driver is optional.",
      "sql_description": "Fetches all lap times for races held on Italian circuits, orders them by absolute fastest milliseconds, and returns only the single overall fastest lap among those (LIMIT 1).",
      "reason": "The query returns just one overall fastest lap instead of one lap-record per Italian circuit, so required circuit-level anchors are missing.",
      "verdict": false
    }
  },
  {
    "question_id": 847,
    "result": {
      "expected_answer": "Surname of the driver who recorded the lowest (fastest) q2 lap time for raceId 19 (i.e., race number 19).",
      "sql_description": "Finds all qualifying rows for race 19, orders them by q2 converted to REAL ascending, and returns the first driver's surname.",
      "reason": "The query does not exclude NULL q2 values. If any driver in race 19 has no q2 time (NULL), that row will sort before valid times and be incorrectly chosen, violating the `best lap time` anchor. Therefore it is not guaranteed to return the driver with the fastest recorded lap.",
      "verdict": false
    }
  },
  {
    "question_id": 962,
    "result": {
      "expected_answer": "The percentage (0–100%) of drivers who competed in races from 2000-2005 that are (a) born before 1985 and (b) have at least one recorded lap number greater than 50.",
      "sql_description": "1) drivers_filtered keeps drivers born before 1985.\n2) laps_filtered keeps drivers who have any lapTimes row with lap > 50.\n3) race_filtered keeps drivers that appear in lapTimes for races whose year is between 2000 and 2005.\n4) Intersection of the three sets gives the numerator; denominator is all distinct drivers in race_filtered. Percentage = 100 * numerator / denominator.",
      "reason": "All required anchors are present: race years 2000-2005 (race_filtered), birth year before 1985 (drivers_filtered), lap number >50 (laps_filtered). Numerator and denominator are constructed exactly as specified in evidence, so the query answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column percentage with value 100.0 for the computed percentage."
    }
  },
  {
    "question_id": 896,
    "result": {
      "expected_answer": "A numeric percentage representing the share of Lewis Hamilton’s races from 2010 onward in which his finishing position was not 1.",
      "sql_description": "Builds Hamilton’s result rows, keeps only those from races in 2010 or later, counts all classified finishes (position>0) as the denominator and those with position>1 as the numerator, then multiplies by 100.",
      "reason": "All mandated anchors—surname ‘Hamilton’, races with year≥2010, and condition position>1 for the numerator—are present. Treating only classified results (position>0, non-NULL) as the population is a reasonable interpretation of ‘at the 1st track’ vs ‘not at 1st track’, so the computed percentage satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows one column percentage_not_first with value 61.6"
    }
  },
  {
    "question_id": 866,
    "result": {
      "expected_answer": "Identify the driver in race 161 whose recorded lap time is 0:01:27, and provide that driver’s introduction website (url). The answer should at least contain the driver identity (name or id) plus the url.",
      "sql_description": "Returns only the url from drivers whose lapTimes.time equals exactly '1:27' for raceId 161.",
      "reason": "1) Omits the driver identity, so does not answer the \"Who\" part. 2) Uses strict equality to '1:27', not the '0:01:27' pattern, risking missing the correct row. Thus required anchors/results are not fully satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 736,
    "result": {
      "expected_answer": "Superhero name(s) whose Intelligence attribute value is the lowest among all superheroes.",
      "sql_description": "Builds a list of (hero_id, intelligence value); computes the minimum intelligence value but also keeps an arbitrary hero_id (no GROUP BY). Returns the superhero whose id matches that arbitrary hero_id, constrained only by the fact that the computed min_intelligence equals the global minimum.",
      "reason": "Because hero_id is not grouped, the hero_id chosen in LowestIntelligence is not guaranteed to belong to a hero with the minimum Intelligence value. The query can therefore return a superhero that is not actually the dumbest, violating the required anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1002,
    "result": {
      "expected_answer": "Full name of the most recently born driver, plus that driver’s nationality and the name of the first race in which the driver appeared.",
      "sql_description": "Finds the driver with the latest DOB (youngest). Then looks up that driver’s earliest race by joining results to races and taking the minimum race date. Returns the driver’s full name, nationality, and that earliest race name.",
      "reason": "SQL correctly identifies the youngest driver using MAX(dob) via ORDER BY DESC LIMIT 1, and fetches the first race they entered by ordering their races by date ASC LIMIT 1. All required fields—full name, nationality, first-joined race—are selected, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result row0: full_name=Lance Stroll, nationality=Canadian, race_name=Chinese Grand Prix"
    }
  },
  {
    "question_id": 881,
    "result": {
      "expected_answer": "The percentage of drivers who finished the race held on 1983-07-16 (i.e., number of drivers whose time field is not NULL divided by total drivers entered for that specific race).",
      "sql_description": "Gets the list of drivers from the 1983-07-16 race, then counts (1) all result rows of those drivers across every race that have a non-NULL time and (2) all result rows of those drivers across every race, and returns completed/total as a percentage.",
      "reason": "The numerator and denominator are calculated over every race those drivers ever ran, not restricted to the 1983-07-16 race. Thus it does not compute the completion rate for the target race itself, violating the essential date/race anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 769,
    "result": {
      "expected_answer": "Name of the Dark Horse Comics superhero whose durability attribute value is highest among all Dark Horse Comics heroes.",
      "sql_description": "Finds all superheroes published by Dark Horse Comics, joins to the durability attribute, orders them by durability value descending (with name tiebreak), and returns the first superhero name.",
      "reason": "Query applies required publisher filter, targets the durability attribute, orders to identify the maximum, and returns the superhero name. Satisfies all anchors; tie-handling is acceptable since question does not specify.",
      "verdict": true,
      "evidence": "sql_result shows column superhero_name but no rows; absence of rows does not affect logical correctness of query for evaluation."
    }
  },
  {
    "question_id": 901,
    "result": {
      "expected_answer": "List each 2005 Formula-1 race held in September, showing the race name together with its circuit name and the circuit’s location city.",
      "sql_description": "Joins races with circuits, filters rows where the race date is in 2005 and month 09, and outputs r.name, circuit name and location.",
      "reason": "All required anchors (year 2005, month September) are applied; selected columns match requested race, circuit name, and location. Returned rows therefore answer the question.",
      "verdict": true,
      "evidence": "Columns: race_name, circuit_name, location. Rows include Italian Grand Prix / Autodromo Nazionale di Monza / Monza, Belgian Grand Prix / Circuit de Spa-Francorchamps / Spa, Brazilian Grand Prix / Autódromo José Carlos Pace / São Paulo."
    }
  },
  {
    "question_id": 906,
    "result": {
      "expected_answer": "The name of Lewis Hamilton’s first Formula-1 Grand Prix (the race occurring in the earliest season he competed – min(races.year) for him) together with the number of championship points he scored in that debut race.",
      "sql_description": "Finds all of Hamilton’s race results, orders them by season year (ascending) and by the race date, then picks the very first row and returns that race’s name and the points he earned.",
      "reason": "The query intends to pick the earliest race, but because it simply ORDERs then LIMIT 1 on the (driver × race) rows, the chosen row depends on the internal row order when several races share the same earliest year. In the data it returned the ‘Malaysian Grand Prix’, which is not Hamilton’s first race in the 2007 season (the Australian GP is earlier). Hence the query does not reliably satisfy the ‘first race = min(year)’ requirement and produces an incorrect answer for the given data.",
      "verdict": false
    }
  },
  {
    "question_id": 728,
    "result": {
      "expected_answer": "A list of eye colours among Marvel Comics superheroes, each with the number of Marvel heroes having that colour, ordered from highest count to lowest.",
      "sql_description": "Filters superheroes to those whose publisher_name is 'Marvel Comics', joins to colour to get the colour name, counts heroes per eye colour, then orders the counts in descending order.",
      "reason": "Query applies required Marvel Comics filter, counts heroes per eye colour, and orders results by popularity descending, exactly matching the ranking request.",
      "verdict": true,
      "evidence": "sql_result shows columns: colour, popularity; first rows Blue 126, Brown 89, ... ordered descending, confirming correct aggregation and ordering."
    }
  },
  {
    "question_id": 794,
    "result": {
      "expected_answer": "The superhero name(s) whose Speed attribute value is the highest in the data.",
      "sql_description": "Finds all heroes whose Speed attribute equals the maximum Speed value and returns their superhero_name.",
      "reason": "Uses attribute_name = 'Speed' anchor, computes the max speed, and returns the corresponding hero name(s). This satisfies the question; multiple names are acceptable if they share the top speed.",
      "verdict": true,
      "evidence": "sql_result rows: superhero_name column lists Air-Walker, Angela, Ardina, …, Jesse Quick (20 rows) all representing max-speed heroes."
    }
  },
  {
    "question_id": 981,
    "result": {
      "expected_answer": "Return the year when the youngest driver in the drivers table made his first qualifying appearance, together with that driver's name, the race name, and the race's date and time.",
      "sql_description": "Gets the driver with the latest date-of-birth (youngest), finds that driver’s minimum race date across the qualifying table, joins back to races to fetch its year, name, date and time, and outputs these five fields.",
      "reason": "Meets all anchors: youngest driver selected via DOB DESC LIMIT 1; first qualifying race determined by MIN(races.date); returns requested year, driver name, race name, date, and time. Join on date suffices given races have unique dates, so result answers the question.",
      "verdict": true,
      "evidence": "sql_result columns: year, name, race_name, date, time → row0: (2017, \"Lance Stroll\", \"Chinese Grand Prix\", 2017-04-09, 06:00:00)."
    }
  },
  {
    "question_id": 928,
    "result": {
      "expected_answer": "Reference name (driverRef) of the driver who finished 1st (winner) at the 2007 Canadian Grand Prix.",
      "sql_description": "Finds the race record where name is 'Canadian Grand Prix' and year 2007, gets the associated result rows where finishing position = 1, and returns the corresponding driver's driverRef.",
      "reason": "Query applies correct race name and year anchors and selects the winner (position 1), returning driverRef, exactly matching the information requested.",
      "verdict": true,
      "evidence": "sql_result shows driverRef = 'hamilton' (row 0, column driverRef)."
    }
  },
  {
    "question_id": 954,
    "result": {
      "expected_answer": "Share (in percent) of Japanese driver participations in 2007-2009 races that ended with a recorded finish time (time IS NOT NULL). Numerator: each race row for a Japanese driver with non-NULL time; Denominator: all race rows for Japanese drivers in those years.",
      "sql_description": "Counts DISTINCT drivers, not race rows: denominator = number of Japanese drivers who appeared 2007-2009; numerator = Japanese drivers that have at least one finished race; divides the two and multiplies by 100.",
      "reason": "Question asks for race-level completion percentage, evidence explicitly defines counting driverID rows. Query instead computes driver-level fraction, ignoring multiple participations and missing many required rows. Anchor on counting all relevant race results is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 959,
    "result": {
      "expected_answer": "The lap number on which the 2009 world-champion driver set his single quickest lap in any 2009 Grand Prix.",
      "sql_description": "Finds all lap-time records from 2009 where the driver had position = 1 in the driverStandings for that same race (i.e., was leading the championship), orders those laps by elapsed milliseconds ascending, and returns the lap number of the overall minimum.",
      "reason": "Query anchors year = 2009, restricts to the championship-leading driver(s), chooses the minimum milliseconds (fastest lap) and outputs its lap number. Under the reasonable interpretation that the champion is represented by driverStandings.position = 1 (the points leader, which for 2009 is the eventual champion in every race), all conditions are satisfied and the returned lap number matches the request.",
      "verdict": true,
      "evidence": "sql_result shows one row: lap=46 (column \"lap\", row 0), giving the requested lap number."
    }
  },
  {
    "question_id": 758,
    "result": {
      "expected_answer": "The colour(s) of the hair of any superhero whose race is human and whose height is exactly 185 cm.",
      "sql_description": "Gets hair_colour_id of superheroes, joins to colour table, and returns c.colour where s.height_cm = 185 and r.race = 'human'.",
      "reason": "Query includes all required anchors (height 185, race human, hair colour) and returns the requested attribute without extra constraints. Empty result does not contradict logic.",
      "verdict": true,
      "evidence": "Result set has column [colour] with 0 rows."
    }
  },
  {
    "question_id": 798,
    "result": {
      "expected_answer": "The name(s) of the publisher(s) associated with the superheroes Hawkman, Karate Kid, and Speedy.",
      "sql_description": "Looks up the publisher_id for each of the three specified superheroes and returns the distinct publisher_name(s).",
      "reason": "Query filters on all three heroes and returns their publisher names; this satisfies the request for the publisher of those heroes. A single distinct list is a reasonable interpretation of the singularly phrased question.",
      "verdict": true,
      "evidence": "sql_result shows one row: publisher_name = 'DC Comics'"
    }
  },
  {
    "question_id": 544,
    "result": {
      "expected_answer": "The display name (string) of the user who most recently edited the specified post.",
      "sql_description": "Looks up the post with the exact given title in posts and returns its LastEditorDisplayName field.",
      "reason": "Query uses Title filter to locate the post and outputs LastEditorDisplayName, which is the requested data. No missing anchors or mismatched columns.",
      "verdict": true,
      "evidence": "sql_result shows column LastEditorDisplayName with one row (value None), indicating query ran and produced the requested field."
    }
  },
  {
    "question_id": 1003,
    "result": {
      "expected_answer": "A single integer: the number of accidents (statusId = 3 rows) recorded by the driver who has the most such accidents in the Canadian Grand Prix race(s).",
      "sql_description": "Filters results rows to the race whose name is 'Canadian Grand Prix', keeps only those with statusId = 3, counts these per driver, then returns the maximum of those counts (i.e., the accident total of the driver with the highest count).",
      "reason": "All explicit anchors are met: Canadian Grand Prix is selected via name, accidents are limited to statusId = 3, counts are taken per driver and the highest count returned. The query answers the question directly under the reasonable interpretation that the Canadian Grand Prix refers to the single race present in the dataset (for which the sub-query returns exactly one raceId).",
      "verdict": true,
      "evidence": "sql_result shows column max_accidents with value 1 (row 0), matching the required output."
    }
  },
  {
    "question_id": 963,
    "result": {
      "expected_answer": "A single integer: the number of distinct French drivers whose lap time is under 2 minutes (i.e., <120 seconds).",
      "sql_description": "Joins lapTimes with drivers, keeps only rows where nationality is 'French' and lap time in milliseconds converted to seconds is <120, then counts distinct driverId values.",
      "reason": "All required anchors are present: French nationality filter and lap time <120 s. Distinct driver count is appropriate for \"how many drivers\". Therefore the SQL answers the question.",
      "verdict": true,
      "evidence": "Result set has one column COUNT(DISTINCT lt.driverId) with value 9."
    }
  },
  {
    "question_id": 829,
    "result": {
      "expected_answer": "Identify whether DC Comics or Marvel Comics has the higher number of superheroes and give the numerical difference between their counts.",
      "sql_description": "Counts superheroes for the two publishers, then returns only the absolute difference between the two counts (163). It does not return which publisher has the larger count.",
      "reason": "The question asks both which publisher has more superheroes and the difference. The query supplies only the difference, omitting the publisher comparison result, so one required anchor (the winning publisher) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 584,
    "result": {
      "expected_answer": "Texts of all comments on the specified post, but only those authored by the user(s) who edited that post.",
      "sql_description": "Finds the post id with the given title and returns the text of every comment attached to that post, without regard to who wrote them.",
      "reason": "Question explicitly requires limiting to comments made by the post’s editor(s). The query omits any check against LastEditorUserId (or equivalent), so the editor anchor is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 586,
    "result": {
      "expected_answer": "DisplayName of any user(s) who awarded a bounty of 50 on a post whose Title contains the word \"variance\".",
      "sql_description": "Joins votes with users and posts, filters votes where BountyAmount = 50 and the associated post title contains 'variance', then returns the users' DisplayName.",
      "reason": "All required anchors are present: BountyAmount = 50, post title includes 'variance', and the query returns the relevant users' display names. Multiple names are acceptable for the singular phrasing since the question does not explicitly require a single result.",
      "verdict": true,
      "evidence": "sql_result rows: DisplayName → ['chl', 'shabbychef']"
    }
  },
  {
    "question_id": 801,
    "result": {
      "expected_answer": "A single numeric value: the ratio of male superheroes to female superheroes, computed as count(gender_id = 1) divided by count(gender_id = 2) according to the evidence mapping.",
      "sql_description": "Counts superheroes with gender_id = 2 (labelled as male in the query) and gender_id = 1 (labelled as female), then returns male_count / female_count.",
      "reason": "Evidence explicitly defines the ratio as SUM(gender_id = 1) / SUM(gender_id = 2). The SQL reverses this, using SUM(gender_id = 2) / SUM(gender_id = 1). Thus the numerator-denominator anchor is violated, so the returned value is the inverse of the requested ratio.",
      "verdict": false
    }
  },
  {
    "question_id": 988,
    "result": {
      "expected_answer": "Names (forename + surname) and average pit-stop durations of the three German drivers born between 1980 and 1985 who have the lowest average pit-stop time (shortest average).",
      "sql_description": "Computes AVG(duration) for each driver in pitStops after keeping only drivers whose nationality is 'German' and whose birth year is 1980–1985 inclusive; orders these averages ascending and returns the first three drivers with their full names and averages.",
      "reason": "Query applies every explicit anchor: nationality, birth-year window, average pit-stop per driver, ascending order, top 3 limit. Returned columns match required information.",
      "verdict": true,
      "evidence": "full_name, avg_duration columns; 3 rows e.g. (Nico Rosberg 23.2676, Adrian Sutil 23.4671, Timo Glock 23.6894)."
    }
  },
  {
    "question_id": 1001,
    "result": {
      "expected_answer": "Full name (forename + surname) of the driver with the fastest Q3 time in the 2008 qualifying session held at Marina Bay Street Circuit.",
      "sql_description": "Looks at the 2008 race at Marina Bay Street Circuit; finds the row(s) whose q3 time equals the minimum q3 time for that race (after casting q3 to REAL) and returns that driver’s full name.",
      "reason": "q3 values are stored as lap-time strings like '1:44.997'. Casting such strings to REAL turns them into 1.0 (or NULL), so MIN(CAST(q3 AS REAL)) is 1 or NULL, which rarely matches any real q3 value; this caused an empty result and would generally pick the wrong (or no) driver. Thus the query does not reliably identify the true fastest Q3 driver.",
      "verdict": false
    }
  },
  {
    "question_id": 743,
    "result": {
      "expected_answer": "Return 1) the percentage of all superheroes whose alignment is 'Bad' (treated as those acting in their own self-interest / own moral code) and 2) how many of those bad-aligned superheroes were published by Marvel Comics.",
      "sql_description": "Builds list of bad-aligned heroes, counts them, counts total superheroes, computes 100*bad/total for the percentage, and separately counts how many of the bad-aligned heroes have publisher_name = 'Marvel Comics'. Returns both values.",
      "reason": "Uses alignment='Bad' as specified in evidence, divides by total heroes, and restricts the Marvel count correctly; all required anchors (alignment filter, percentage calculation, Marvel publisher filter) are present.",
      "verdict": true,
      "evidence": "sql_result columns: bad_percentage (row0=28.266667), marvel_bad_heroes_count (row0=118)"
    }
  },
  {
    "question_id": 766,
    "result": {
      "expected_answer": "The full name of the superhero whose strength attribute value is the highest among all heroes (ties acceptable to list, but one name is sufficient).",
      "sql_description": "Builds a set of strength values per hero, finds the hero with the maximum strength (ORDER BY max strength DESC LIMIT 1), then returns that hero’s full_name from the superhero table.",
      "reason": "Query filters on attribute_name = 'strength', identifies the hero with the greatest attribute_value, and outputs full_name, satisfying the question’s requirement.",
      "verdict": true,
      "evidence": "sql_result contains column full_name; no rows returned but structure matches expected output."
    }
  },
  {
    "question_id": 634,
    "result": {
      "expected_answer": "The display name (either \"Harvey Motulsky\" or \"Noah Snyder\") whose posts accumulate the greater total view count, i.e., whose posts are overall more popular.",
      "sql_description": "Aggregates posts for the two authors, sums their ViewCount values, orders by this total descending, and returns the OwnerDisplayName with the highest summed views (LIMIT 1).",
      "reason": "Interpreting the question as asking which author’s body of posts is more popular (supported by given evidence formula). Query applies correct filter, correctly aggregates ViewCount, and returns the author with the larger sum. Tie-break not specified, so LIMIT 1 is acceptable.",
      "verdict": true,
      "evidence": "Execution output column: OwnerDisplayName (no rows in sample run, but query logic aligns with requirements)."
    }
  },
  {
    "question_id": 557,
    "result": {
      "expected_answer": "Return the percentage (0–100) of posts whose Score > 5 that are owned by users older than 65.",
      "sql_description": "Creates set of post IDs with Score > 5; creates subset where the posts’ owners have Age > 65; divides the count of the elder-owned posts by the total high-score posts and multiplies by 100.",
      "reason": "SQL captures both required anchors: Score > 5 and owner Age > 65, counts posts, computes percentage correctly. Joins avoid duplicates and treat non-matching owners properly. Logic aligns with question.",
      "verdict": true,
      "evidence": "Result set has column Percentage; row0 Percentage ≈0.165722 indicating calculation executed."
    }
  },
  {
    "question_id": 726,
    "result": {
      "expected_answer": "A list of Marvel Comics heroes ordered from tallest to shortest (may include their heights).",
      "sql_description": "Selects superhero_name and height_cm from superheroes whose publisher is Marvel Comics and orders the list by height descending, tie-breaking alphabetically.",
      "reason": "Matches required publisher filter and correct descending height ordering, returning appropriate columns.",
      "verdict": true,
      "evidence": "sql_result rows show Marvel heroes (superhero_name, height_cm) sorted 30480 > 3050 > 1520 etc., confirming descending order."
    }
  },
  {
    "question_id": 672,
    "result": {
      "expected_answer": "A single integer: the count of users whose location is 'United Kingdom' and who have (at least one) post with FavoriteCount ≥ 4. (Interpretation: the threshold applies per post, not the sum across a user’s posts, as suggested by the evidence.)",
      "sql_description": "Gets all posts with FavoriteCount ≥ 4, grabs their OwnerUserId, joins to users located in the United Kingdom, and counts the distinct user ids.",
      "reason": "All required anchors are present: location filter (United Kingdom) and FavoriteCount ≥ 4 on posts. The query counts distinct users having any qualifying post, matching the adopted per-post interpretation, which is explicitly backed by the evidence note. Therefore it answers the question.",
      "verdict": true,
      "evidence": "sql_result has column NumUsers with value 14 (row 0)."
    }
  },
  {
    "question_id": 1011,
    "result": {
      "expected_answer": "Full name (forename, surname) of the driver who is in the top-20 of the driver standings at least once and whose recorded lap time is the overall shortest ever in the lapTimes table.",
      "sql_description": "1) Builds TopDrivers = all drivers who ever had position ≤20 in driverStandings. 2) For every driver, finds their personal minimum lap time in milliseconds. 3) Gets the global minimum of those times and keeps the driver(s) who both belong to TopDrivers and hold that global minimum. 4) Returns their forename and surname.",
      "reason": "Query respects the ‘top 20 driver’ filter and identifies the absolute shortest lap time ever, then returns the full name of the driver(s) that meet both conditions, matching the question’s intent. No anchors are missing.",
      "verdict": true,
      "evidence": "sql_result shows columns [forename, surname] with row 0 = ('Lewis', 'Hamilton'), consistent with expected format."
    }
  },
  {
    "question_id": 639,
    "result": {
      "expected_answer": "The numeric percentage of all posts authored by display name \"Community\" that include the R tag (tagname = 'r').",
      "sql_description": "Counts all posts whose OwnerDisplayName is 'Community', separately counts those whose Tags string contains '<r>', then returns 100 * (r-tagged count) / (total Community count).",
      "reason": "Query applies both required anchors: author \"Community\" and tag 'r'. Uses LIKE '%<r>%' which matches the exact '<r>' tag, and divides by the total Community posts. Logic directly yields the requested percentage; NULLIF safeguard does not violate requirements.",
      "verdict": true,
      "evidence": "Result set provides single column Percentage (row 0 shown as None because dataset has zero Community posts), matching the requested output format."
    }
  },
  {
    "question_id": 753,
    "result": {
      "expected_answer": "Names of superheroes whose height_cm is between 170 and 190 inclusive and whose eye_colour_id points to a colour record with colour = 'No Colour'.",
      "sql_description": "Gets superheroes in the height range, then joins colour ON superhero.id = colour.id and keeps those with colour = 'No Colour'; returns the superhero_name.",
      "reason": "The join should match superhero.eye_colour_id to colour.id, not superhero.id to colour.id. Therefore the \"no eye colour\" anchor is applied incorrectly and the result set is unreliable.",
      "verdict": false
    }
  },
  {
    "question_id": 345,
    "result": {
      "expected_answer": "The legality status (e.g., Legal/Restricted/Banned) of every card whose types include only Artifact and that has no multi-face indication (side NULL) in the Vintage play format.",
      "sql_description": "Filters cards where types = 'Artifact' and side IS NULL, joins their uuids to the legalities table restricted to format = 'vintage', and outputs the status column (one row per matching printing).",
      "reason": "Query applies all explicit anchors (Artifact type, single-face, Vintage format) and returns the requested legality status. Duplicates are harmless for this informational question.",
      "verdict": true,
      "evidence": "sql_result rows: status column shows 'Legal' for all 20 returned records, indicating these cards are legal in Vintage."
    }
  },
  {
    "question_id": 598,
    "result": {
      "expected_answer": "A single numeric value: (count of 'Student' badges in 2010 / total 'Student' badges)*100 minus (count of 'Student' badges in 2011 / total 'Student' badges)*100, i.e., the percentage-point difference between 2010 and 2011.",
      "sql_description": "Counts 'Student' badges for years 2010 and 2011, counts all 'Student' badges overall, then computes 100*((count2010/total) - (count2011/total)). Returns this difference as percentage_difference.",
      "reason": "Query filters Name='Student', isolates 2010 and 2011 counts, gets total, and applies the specified percentage-difference formula. All required anchors (badge type, years, percentage computation) are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows column percentage_difference with one value (row0: 0.0), matching expectation of a single numeric answer."
    }
  },
  {
    "question_id": 772,
    "result": {
      "expected_answer": "For every superhero whose gender is Female and whose publisher is Dark Horse Comics, return a list of that hero’s eye colour, hair colour and skin colour (as colour names).",
      "sql_description": "Finds superheroes, filters to those with gender='Female' and publisher_name='Dark Horse Comics'; joins the colour table three times to translate each of eye_colour_id, hair_colour_id, skin_colour_id into their colour names, then outputs those three colour names per matching hero.",
      "reason": "All required filters (female gender, Dark Horse Comics publisher) are applied and correct columns (eye, hair, skin colour names) are selected. Result rows therefore satisfy question.",
      "verdict": true,
      "evidence": "sql_result shows columns eye_colour, hair_colour, skin_colour with colour names for 5 matching female Dark Horse Comics heroes."
    }
  },
  {
    "question_id": 571,
    "result": {
      "expected_answer": "The ratio (number of posts ÷ number of votes) for user 24.",
      "sql_description": "Counts posts where OwnerUserId = 24, counts votes where UserId = 24, divides the post count by the vote count, returning the ratio as 'times'.",
      "reason": "Query uses correct filters for posts and votes tied to user 24 and returns their quotient, matching the requested metric.",
      "verdict": true,
      "evidence": "times=0.375 in result row 0"
    }
  },
  {
    "question_id": 791,
    "result": {
      "expected_answer": "The mean (average) of the height_cm values for every superhero in the table, expressed in centimeters.",
      "sql_description": "Calculates AVG(height_cm) over all rows in superhero, returning one value named average_height.",
      "reason": "The query directly computes the requested overall average height. The question does not explicitly require filtering out zero-values, so including them is a reasonable interpretation. Thus the SQL satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows one column average_height with value 267.751445"
    }
  },
  {
    "question_id": 405,
    "result": {
      "expected_answer": "A single integer: the number of distinct sets whose block is 'Commander' and that have at least one translation in 'Portuguese (Brasil)'.",
      "sql_description": "Collects all set codes with Portuguese (Brasil) translations, collects all set codes in the Commander block, intersects the two lists, and counts the resulting distinct set codes.",
      "reason": "All explicit anchors are present: language='Portuguese (Brasil)', block='Commander', counting distinct set codes. Duplicates in translations are removed via DISTINCT, so the count reflects unique sets, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 0, consistent with a numeric answer."
    }
  },
  {
    "question_id": 788,
    "result": {
      "expected_answer": "The percentage obtained by dividing the number of female heroes whose publisher is Marvel Comics by the total number of female heroes (irrespective of publisher) and multiplying by 100.",
      "sql_description": "Counts female heroes published by Marvel (numerator) and divides by the total number of Marvel heroes (denominator) to give the share of Marvel heroes that are female.",
      "reason": "The query’s denominator is total Marvel heroes, not total female heroes; thus it returns the percentage of Marvel heroes who are female, not the requested percentage of female heroes that belong to Marvel. Anchor ‘total female heroes’ is missing/incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 533,
    "result": {
      "expected_answer": "A single number: the count of user records whose LastAccessDate is later than 2014-09-01.",
      "sql_description": "Counts all rows in the users table where LastAccessDate > '2014-09-01'.",
      "reason": "Query applies the correct date filter and returns the total number of users satisfying it; no other constraints are required.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 5146."
    }
  },
  {
    "question_id": 683,
    "result": {
      "expected_answer": "A single numeric percentage: (posts created in 2011 whose owner’s reputation > 1000) ÷ (all posts created in 2011) × 100.",
      "sql_description": "Creates list of 2011 posts with high-rep owners, list of all 2011 posts, then returns 100*count(high-rep posts)/count(all posts).",
      "reason": "Query applies the 2011 year filter to posts, joins to users to enforce reputation>1000 for the numerator, and divides by total 2011 posts. All required anchors (year 2011, reputation>1000, percentage on post counts) are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows column percentage with one value (≈49.83), matching expected single numeric output."
    }
  },
  {
    "question_id": 587,
    "result": {
      "expected_answer": "For every post whose Tags include '<humor>', return: 1) the post title, 2) a comment text belonging to that post, and 3) that post’s average (i.e., its ViewCount or the averaged value) view count.",
      "sql_description": "Creates a list of humor-tagged posts with a computed AvgViewCount (essentially the same as ViewCount) then joins to postHistory to output only the Title and Comment columns for each related history row.",
      "reason": "Required anchor \"average view count\" is not included in the final SELECT, so the query does not calculate or return it. Output misses a requested attribute.",
      "verdict": false
    }
  },
  {
    "question_id": 531,
    "result": {
      "expected_answer": "Identify the one of the two users (Harlan or Jarrod Dixon) whose Reputation value is higher; returning that user (optionally with the reputation value).",
      "sql_description": "Looks up the two specified DisplayNames in users, orders them by Reputation descending, and returns the first (highest-reputation) row, giving the display name and reputation.",
      "reason": "Query correctly restricts to the two target users, ranks them by Reputation, and outputs the top one, satisfying the comparison asked.",
      "verdict": true,
      "evidence": "Returned row: DisplayName='Harlan', Reputation=457 (column names: DisplayName, Reputation)."
    }
  },
  {
    "question_id": 687,
    "result": {
      "expected_answer": "Return the number of comments whose PostId corresponds to the post that has the maximum Score among all posts.",
      "sql_description": "Finds the Id(s) of posts whose Score equals the maximum Score, then counts rows in comments whose PostId equals that Id (effectively the comment count for the highest-scored post).",
      "reason": "Query anchors on MAX(Score) as required and counts comments linked to that post. Singular phrasing in the question allows treating one highest-score post even if ties exist, so the approach is acceptable. All needed constraints are present.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 3 for the selected post."
    }
  },
  {
    "question_id": 637,
    "result": {
      "expected_answer": "Distinct tag names that appear in posts authored by the user whose DisplayName is 'Mark Meckes' where those posts have CommentCount = 0.",
      "sql_description": "Selects all Tags strings from posts written by Mark Meckes with zero comments, then finds every tag in the tags table whose TagName occurs inside those tag strings, returning them DISTINCT.",
      "reason": "Query applies both required filters (author = 'Mark Meckes', CommentCount = 0) and returns distinct tag names, satisfying the question intent. The LIKE-matching approach is a reasonable interpretation of extracting tags from the angle-bracket string, so logic aligns.",
      "verdict": true,
      "evidence": "sql_result shows one row with TagName='books', consistent with expected output structure."
    }
  },
  {
    "question_id": 565,
    "result": {
      "expected_answer": "Indicate if the post that received a comment from user 23853 at 2013-07-12 09:08:18 was well-finished (ClosedDate NOT NULL) or not (ClosedDate NULL).",
      "sql_description": "Joins posts with comments, finds the comment made by UserId 23853 at the specified timestamp, and returns 'Well-Finished' when the linked post has a non-NULL ClosedDate, otherwise 'Not Well-Finished'.",
      "reason": "Query applies both required anchors (user id, comment timestamp) and evaluates ClosedDate with correct polarity, so it directly answers whether that specific post was well-finished.",
      "verdict": true,
      "evidence": "sql_result shows PostStatus column with value 'Well-Finished' for the matched post"
    }
  },
  {
    "question_id": 483,
    "result": {
      "expected_answer": "Return the Italian-language ruling text for every card whose set is Coldsnap (s.name = 'Coldsnap' AND foreign_data.language = 'Italian'); the output should be the Italian text strings.",
      "sql_description": "Outputs r.text from the English rulings table for cards in the Coldsnap set, restricting to cards that merely possess some Italian entry in foreign_data.",
      "reason": "The query supplies English ruling text, not the Italian text requested. It never selects foreign_data.text, so the language anchor ('Italian') is not satisfied for the returned text.",
      "verdict": false
    }
  },
  {
    "question_id": 563,
    "result": {
      "expected_answer": "Return the FavoriteCount value of the post that received the comment made by user 3025 at 2014-04-23 20:29:39.",
      "sql_description": "Joins comments with posts, filters for comment with UserId 3025 and CreationDate '2014/4/23 20:29:39.0', then outputs the associated post's FavoriteCount.",
      "reason": "All required anchors—user id, exact comment timestamp, linkage to the post, and retrieval of FavoriteCount—are present. Query directly answers the question.",
      "verdict": true,
      "evidence": "Query returns FavoriteCount column; result set currently empty (no matching row), but logic aligns with the question."
    }
  },
  {
    "question_id": 530,
    "result": {
      "expected_answer": "For every card illustrated by Allen Williams: show its frameVersion (frame style) and the card name, indicating whether the card is banned.",
      "sql_description": "Finds all cards whose artist is 'Allen Williams', joins to legalities entries with status 'Banned' and labels each of those cards as 'Banned' or 'Not Banned'. Returns frameVersion, asciiName, ban_status for each card.",
      "reason": "Query applies the artist filter, retrieves frameVersion and card name, checks for banned status via legalities, and outputs a per-card list meeting the stated requirements. No required anchor is missing.",
      "verdict": true,
      "evidence": "Result columns: frameVersion, asciiName, ban_status; multiple rows returned for Allen Williams cards with ban_status values ('Not Banned' in rows 0-19)."
    }
  },
  {
    "question_id": 595,
    "result": {
      "expected_answer": "List the user IDs of users who have post history records for exactly one distinct post and whose profile has at least 1000 views.",
      "sql_description": "First counts, from postHistory, the number of distinct posts each user has appeared on and keeps only those with exactly one such post; then joins these users to the users table and returns the UserId of those whose Views column is 1000 or greater.",
      "reason": "Interprets \"only one post history per post\" as the user being associated with exactly one distinct PostId, a reasonable reading. Applies the required view threshold and returns the requested users. All anchors satisfied.",
      "verdict": true,
      "evidence": "Query returns column UserId; execution produced no rows, which is acceptable if no user meets the criteria."
    }
  },
  {
    "question_id": 581,
    "result": {
      "expected_answer": "Display name of the user who owns the post whose Title is exactly \"Open source tools for visualizing multi-dimensional data?\"",
      "sql_description": "Selects display names from users joined to posts where posts.Title equals 'Open source tools for visualizing multi-dimensional data' (no question mark).",
      "reason": "The title filter omits the trailing question-mark present in the question, so the required anchor (exact post title) is not satisfied; the query may return nothing or the wrong post.",
      "verdict": false
    }
  },
  {
    "question_id": 710,
    "result": {
      "expected_answer": "A single integer: the number of comments whose score equals 0 and whose associated post has exactly one comment (CommentCount = 1).",
      "sql_description": "Creates a list of post ids where CommentCount = 1, then counts all rows in comments whose PostId is in that list and whose Score = 0.",
      "reason": "Query applies both required anchors (posts with exactly one comment; comments with score 0) and returns their count, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 10997."
    }
  },
  {
    "question_id": 349,
    "result": {
      "expected_answer": "Return the card(s) whose uuid has the greatest number of rows in rulings, giving for each its name, artist, and whether it is a promotional printing (isPromo).",
      "sql_description": "Counts rulings per uuid, keeps the single uuid with the highest count, joins to cards, and outputs cards.name, cards.artist, and a Yes/No flag derived from cards.isPromo.",
      "reason": "All required anchors are satisfied: ruling_count is used to find the max, the card name and artist are returned, and promotional status is included. Tie-handling is acceptable with LIMIT 1.",
      "verdict": true,
      "evidence": "sql_result columns: card_name='Teferi's Protection', artist='Chase Stone', promotional_printing='No'."
    }
  },
  {
    "question_id": 682,
    "result": {
      "expected_answer": "The id and owner display name of the post(s) created in 2010 that has the highest FavoriteCount (i.e., the single most ‘valuable’ post of that year).",
      "sql_description": "Filters posts to those whose CreationDate year is 2010, finds the maximum FavoriteCount among them, then returns the id and OwnerDisplayName of the post whose FavoriteCount equals that maximum (with LIMIT 1 in case of ties).",
      "reason": "Query applies the required 2010 year filter, uses FavoriteCount to measure value, determines the maximum, and outputs the requested id and owner display name. All explicit anchors are satisfied.",
      "verdict": true,
      "evidence": "sql_result columns: PostId (1595), OwnerDisplayName (None) – one row returned as expected."
    }
  },
  {
    "question_id": 694,
    "result": {
      "expected_answer": "Text content and commenter display-name for the 10 most recent comments attached to the post titled 'Analysing wind data with R'.",
      "sql_description": "Gets the Id of the post whose Title matches the given string, then fetches comments whose PostId equals that Id, orders them by CreationDate descending, and returns the first 10 rows with Text and UserDisplayName.",
      "reason": "All required anchors are met: correct post, latest (ORDER BY CreationDate DESC LIMIT 10), returns comment text plus display name. Potential duplicate title ambiguity is acceptable; query commits to one reasonable interpretation and works when only one matching post exists, which is typical.",
      "verdict": true,
      "evidence": "sql_result shows 10 rows with columns Text and UserDisplayName, matching the requested fields."
    }
  },
  {
    "question_id": 640,
    "result": {
      "expected_answer": "A single number: total view count of Mornington’s posts minus total view count of Amos’s posts.",
      "sql_description": "Computes SUM(ViewCount) for rows where OwnerDisplayName='Mornington', computes SUM(ViewCount) for rows where OwnerDisplayName='Amos', then subtracts the latter from the former and returns that difference.",
      "reason": "All required anchors are present (OwnerDisplayName filters for both Mornington and Amos, summing ViewCount). The subtraction order matches the evidence (Mornington – Amos). Therefore the query fulfils the question.",
      "verdict": true,
      "evidence": "sql_result columns: ViewCountDifference, row 0 value 0 (example result)."
    }
  },
  {
    "question_id": 341,
    "result": {
      "expected_answer": "Names of all cards whose borderColor is 'borderless' and that do NOT have a powerful foil, i.e., where NOT(cardKingdomFoilId is not null AND cardKingdomId is not null).",
      "sql_description": "Fetches card names from cards table where borderColor='borderless' and at least one of the two fields cardKingdomFoilId or cardKingdomId is NULL, thereby excluding cards that have both IDs present (powerful foils).",
      "reason": "Matches the required borderless filter and correctly negates the powerful-foil condition using OR between the NULL checks. Returns the requested names.",
      "verdict": true,
      "evidence": "sql_result shows a list of 20 card names column 'name' (rows 0-19) satisfying the conditions."
    }
  },
  {
    "question_id": 347,
    "result": {
      "expected_answer": "For every card whose artist is Stephen Daniele, list the card (id) together with the text of each of its rulings, and indicate for each card whether it has missing/degraded properties (hasContentWarning = 1 → Yes, else No).",
      "sql_description": "Selects cards where artist = 'Stephen Daniele', joins to rulings on uuid, returns the card id, the ruling text, and a Yes/No flag based on hasContentWarning.",
      "reason": "All required anchors are present: artist filter, ruling text, and content-warning flag. The join provides ruling descriptions; the CASE maps hasContentWarning as requested. Including only cards that have rulings is a reasonable interpretation because the question focuses on describing the ruling text.",
      "verdict": true,
      "evidence": "Returned columns: card_id, ruling_text, has_missing_or_degraded_properties (rows 0-19 shown)."
    }
  },
  {
    "question_id": 358,
    "result": {
      "expected_answer": "The color of the card border for the card named \"Ancestor's Chosen\".",
      "sql_description": "Retrieves the borderColor field for every row in cards whose name exactly matches \"Ancestor's Chosen\".",
      "reason": "Query applies required name filter and returns the requested borderColor attribute. Duplicate rows do not alter the answer; all values returned are identical.",
      "verdict": true,
      "evidence": "sql_result shows column borderColor with four rows, all having value 'black'."
    }
  },
  {
    "question_id": 40,
    "result": {
      "expected_answer": "Telephone number of the Fresno Unified school whose average SAT reading score is the lowest among all schools in that district.",
      "sql_description": "Joins satscores with schools, filters to rows where dname = 'Fresno Unified', computes each school’s average AvgScrRead, orders by that value ascending, and returns the Phone of the first (lowest-scoring) school.",
      "reason": "Captures the district anchor, correctly identifies the school with the minimal reading average, and returns its phone number; no conflicting constraints are omitted.",
      "verdict": true,
      "evidence": "Returned column Phone with value (559) 490-4290 (row 0)."
    }
  },
  {
    "question_id": 473,
    "result": {
      "expected_answer": "Return Yes if the set(s) that contain the card named \"Adarkar Valkyrie\" are marked isForeignOnly = 1 (only outside the U.S.); otherwise return No.",
      "sql_description": "Looks up every set that prints a card named 'Adarkar Valkyrie', checks their isForeignOnly flag, and returns 'Yes' only if every such set has isForeignOnly = 1; else 'No'.",
      "reason": "Query correctly anchors on the card name, joins to the sets table, evaluates the isForeignOnly attribute, and produces a Yes/No answer matching the question’s intent. This is a reasonable interpretation of the singular phrasing ('the set') when a card can appear in multiple sets.",
      "verdict": true,
      "evidence": "sql_result shows column is_only_available_outside_us with value 'No' (row 0), satisfying the expected Yes/No output."
    }
  },
  {
    "question_id": 685,
    "result": {
      "expected_answer": "Return the view count (ViewCount) of the post titled/text 'Computer Game Datasets' together with the display name (DisplayName) of the user who most recently posted/edited that post.",
      "sql_description": "1) Finds the most recent record in postHistory whose Text equals 'Computer Game Datasets'. 2) Takes that record’s UserId and treats it as the latest poster. 3) Locates the post whose Title matches that same text to fetch its ViewCount. 4) Joins to users to fetch the DisplayName of that UserId. 5) Outputs ViewCount and DisplayName.",
      "reason": "Query covers both requested fields, anchors on the target post title and selects the last occurrence via ORDER BY CreationDate DESC LIMIT 1, satisfying the ‘last time’ requirement. Logical joins retrieve the correct ViewCount and user name; no required constraint is missing or contradicted.",
      "verdict": true,
      "evidence": "Result columns ViewCount, DisplayName returned (no rows in sample run but structure is correct)."
    }
  },
  {
    "question_id": 377,
    "result": {
      "expected_answer": "The number of cards whose originalType is exactly \"Summon - Angel\" and whose subtypes field does not contain the word \"Angel\".",
      "sql_description": "Selects cards where originalType = 'Summon - Angel' and either subtypes is NULL or does not include the substring 'Angel', then counts those rows.",
      "reason": "Query applies required anchor on originalType and excludes all records whose subtypes include 'Angel', matching a reasonable reading of \"subtype other than Angel\". It returns the count, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 0, giving the requested count."
    }
  },
  {
    "question_id": 487,
    "result": {
      "expected_answer": "A numeric percentage indicating what portion of cards in the set \"Coldsnap\" are \"incredibly powerful\" (i.e., have both cardKingdomFoilId and cardKingdomId not null).",
      "sql_description": "1) Finds cards whose name is 'Coldsnap'. 2) Counts how many of those cards have both cardKingdomFoilId and cardKingdomId (powerful_count). 3) Counts total Coldsnap cards (total_count). 4) Returns 100 * powerful_count / total_count as percentage.",
      "reason": "All required anchors are present: it restricts to the Coldsnap set (name = 'Coldsnap'), applies the \"incredibly powerful\" condition, and computes the ratio as a percentage. Logic matches the question.",
      "verdict": true,
      "evidence": "sql_result shows column [percentage] (row0 = None), confirming the query produced the requested field though underlying data had no matching rows."
    }
  },
  {
    "question_id": 716,
    "result": {
      "expected_answer": "Percentage (0–100) of distinct users who authored any comment with score between 5 and 10 whose UpVotes value in users table equals 0, relative to all distinct users who authored comments with score between 5 and 10.",
      "sql_description": "1) Picks all UserIds from comments where Score is between 5 and 10. 2) Picks all user IDs whose UpVotes = 0. 3) Computes 100 * (number of DISTINCT UserIds in the first set that are also in the zero-up-votes set) divided by (number of DISTINCT UserIds in the first set). Returns that single percentage value.",
      "reason": "SQL respects both anchors: comment score range and user UpVotes = 0. It measures percentage at user level, a reasonable interpretation of 'percentage of the users'. Result therefore answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one column Percentage with value 4.87013."
    }
  },
  {
    "question_id": 371,
    "result": {
      "expected_answer": "A single percentage value: (number of Story Spotlight cards that have French language versions) divided by (total number of Story Spotlight cards) * 100.",
      "sql_description": "Builds list of Story Spotlight card ids, then counts rows in foreign_data where foreign_data.id = cards.id and language = 'French'; divides that count by total Story Spotlight card rows and multiplies by 100.",
      "reason": "Key anchor – linking cards to their foreign language data – should use cards.uuid = foreign_data.uuid as indicated by the schema. The query instead joins on id columns that are unrelated, so the numerator may count unrelated or miss relevant cards. Also counts rows not distinct cards. Thus it does not reliably compute the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 198,
    "result": {
      "expected_answer": "A single scalar value: the average number of single bonds (bond_type='-') per atom among molecules whose label is '+'.",
      "sql_description": "Counts all single-bond records in carcinogenic molecules, counts all atoms belonging to carcinogenic molecules, and divides the former by the latter to return the average single bonds per atom.",
      "reason": "Query applies the carcinogenic filter (label='+'), restricts bonds to single ones (bond_type='-'), and divides their count by the number of carcinogenic atoms, exactly matching the specified formula.",
      "verdict": true,
      "evidence": "sql_result shows one column average_single_bonded with value 0.833694, matching the expected single scalar output."
    }
  },
  {
    "question_id": 344,
    "result": {
      "expected_answer": "Names of cards whose mythic-rarity printings are banned in the Gladiator format.",
      "sql_description": "Joins cards with legalities, filters to records where the card’s rarity is 'mythic' and the legality entry is format = 'gladiator' with status = 'Banned', then returns the distinct card names.",
      "reason": "All required anchors (rarity = mythic, format = gladiator, status = banned) are present. The query outputs the card names satisfying them, matching the requested list.",
      "verdict": true,
      "evidence": "sql_result shows two rows: name → 'Oko, Thief of Crowns' (row0), 'Nexus of Fate' (row1)."
    }
  },
  {
    "question_id": 407,
    "result": {
      "expected_answer": "A list (deduplicated) of every combination of subtypes and supertypes that appear on cards whose foreign language entry is German, considering only rows where both subtypes and supertypes are not NULL.",
      "sql_description": "Selects distinct pairs of cards.subtypes and cards.supertypes from cards joined to foreign_data, keeping only records where the foreign_data.language is 'German' and both subtype and supertype fields are non-NULL.",
      "reason": "The query filters on German language, enforces non-NULL subtypes and supertypes, and returns the requested type information. This aligns with the question and evidence; no required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result columns: subtypes, supertypes; 20 distinct German card type pairs returned."
    }
  },
  {
    "question_id": 72,
    "result": {
      "expected_answer": "The numeric count of students aged 5–17 enrolled in 2014-2015 at any school in Fremont whose EdOpsCode is 'SSS' (State Special School).",
      "sql_description": "Joins frpm with schools, filters year 2014-2015, City = Fremont, EdOpsCode = 'SSS', then sums the \"Enrollment (Ages 5-17)\" values to produce that total.",
      "reason": "All explicit anchors—academic year, city, State Special School identification via EdOpsCode, and the age-5-17 enrollment field—are correctly applied; the aggregate sum returns the requested count.",
      "verdict": true,
      "evidence": "sql_result columns: total_enrollment; first row 375.0"
    }
  },
  {
    "question_id": 352,
    "result": {
      "expected_answer": "Percentage (0-100) representing how many cards have a Chinese Simplified language version, i.e., number of cards whose language is 'Chinese Simplified' divided by total number of cards, times 100.",
      "sql_description": "Counts total rows in cards, counts rows in foreign_data where language = 'Chinese Simplified', divides the latter by the former and multiplies by 100, returning that value as percentage.",
      "reason": "Query uses correct language filter, correct total-card base, performs division and scaling to 100. Ambiguity about duplicate foreign_data rows is acceptable: question evidence defines numerator as raw id count, which this query follows. All explicit anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result shows a single column 'percentage' with value ~35.38 (row 0)."
    }
  },
  {
    "question_id": 215,
    "result": {
      "expected_answer": "A single number: the count of distinct atoms whose element is iodine ('i') or sulfur ('s') and that belong to molecules having at least one single bond (bond_type='-').",
      "sql_description": "1) Finds all molecule_ids that appear in the bond table with bond_type='-'. 2) Selects all distinct atom_ids whose molecule_id is among those and whose element is 'i' or 's'. 3) Counts those distinct atom_ids.",
      "reason": "Query satisfies key anchors: filters element to iodine or sulfur, restricts to molecules that possess single bonds, counts distinct atoms. Ambiguity on whether a \"single bond molecule\" must have only single bonds is reasonable; the adopted interpretation (at least one single bond) is not contradicted by evidence. Result therefore answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one column atom_count with value 97."
    }
  },
  {
    "question_id": 469,
    "result": {
      "expected_answer": "A yes/no indication of whether at least one set containing the card named \"Angel of Mercy\" has a non-NULL mtgoCode, meaning that set was available on Magic: The Gathering Online.",
      "sql_description": "Checks for the existence of any card named 'Angel of Mercy' whose set (joined via setCode) has a non-NULL mtgoCode, returning 1 if such a set exists, 0 otherwise.",
      "reason": "Query implements the required condition: card name filter plus mtgoCode IS NOT NULL anchor. EXISTS returns the requested yes/no. Satisfies the question.",
      "verdict": true,
      "evidence": "Result column EXISTS(...) row1 = 1 → indicates at least one matching set, answering \"yes\"."
    }
  },
  {
    "question_id": 115,
    "result": {
      "expected_answer": "The percentage of male clients (gender='M') among all clients belonging to the district situated in the South Bohemia region that has the highest number of inhabitants (largest A4).",
      "sql_description": "1) Picks the South Bohemia district with the maximum inhabitants (A4) using ORDER BY CAST(A4 AS INTEGER) DESC LIMIT 1.\n2) Counts clients from that district whose gender='M'.\n3) Counts all clients from that district.\n4) Computes 100 * male_count / total_count and returns this percentage.",
      "reason": "All explicit anchors are satisfied: region filter (A3='south Bohemia'); selecting district with largest A4; computing male/total client ratio. The resulting figure (40.0) answers the percentage asked.",
      "verdict": true,
      "evidence": "sql_result column male_percentage row0 = 40.0"
    }
  },
  {
    "question_id": 366,
    "result": {
      "expected_answer": "The set of play formats (rules) that apply to the card \"Benalish Knight\" – e.g., commander, legacy, modern, etc.",
      "sql_description": "Looks up the uuid of the card named 'Benalish Knight' in cards, then retrieves every format in the legalities table that shares this uuid.",
      "reason": "Question asks for the card’s play rule, defined in evidence as its format list; query correctly filters by the card and returns all associated formats, satisfying the requirement.",
      "verdict": true,
      "evidence": "sql_result shows column [format] with rows: commander, duel, legacy, modern, pauper, penny, premodern, vintage."
    }
  },
  {
    "question_id": 231,
    "result": {
      "expected_answer": "Return the bond type with the greatest number of occurrences in molecule TR010 and report whether TR010 is carcinogenic (Yes/No).",
      "sql_description": "Counts bonds in molecule TR010, keeps the bond_type with the highest count, then reports that bond_type together with \"Yes\" if the molecule label equals the literal string 'carcinogenic', otherwise 'No'.",
      "reason": "Although it correctly identifies the majority bond type for TR010, it determines carcinogenicity by checking for the string 'carcinogenic', while the schema indicates the label uses '+' for carcinogenic and '-' for non-carcinogenic. This mis-mapping can yield an incorrect Yes/No value, so the query does not reliably answer the second part of the question.",
      "verdict": false
    }
  },
  {
    "question_id": 484,
    "result": {
      "expected_answer": "Italian-language card names whose converted mana cost equals the maximum among all cards in the set \"Coldsnap\".",
      "sql_description": "Finds the maximum convertedManaCost for cards in the set Coldsnap, then returns all foreign_data names where language is Italian for cards in that set whose convertedManaCost equals that maximum.",
      "reason": "Query correctly anchors on set name 'Coldsnap', filters to Italian names, computes and uses the global max convertedManaCost within that set, and returns the corresponding card names, satisfying the request.",
      "verdict": true,
      "evidence": "sql_result shows 12 rows with column name (e.g., Devastazione Solare, Jokulmorder, Wurm Panglaciale, …), matching requirement to list Italian names."
    }
  },
  {
    "question_id": 412,
    "result": {
      "expected_answer": "The French foreign name(s) of every card illustrated by Matthew D. Wilson whose layout is normal, border colour is black, and whose type includes Creature.",
      "sql_description": "Joins cards with foreign_data on uuid, filters cards to type containing 'Creature', layout 'normal', borderColor 'black', artist 'Matthew D. Wilson', and keeps only foreign_data rows where language = 'French'; returns the foreign name column.",
      "reason": "All anchors—type Creature, normal layout, black border, artist Matthew D. Wilson, French language—are explicitly enforced. The query outputs exactly the requested French foreign name(s); plurality is acceptable given the question wording.",
      "verdict": true,
      "evidence": "sql_result shows column 'name' with 20 French card names (e.g., 'Escouade de balistes', 'Reya Aubevenant', ...), matching the requested field."
    }
  },
  {
    "question_id": 137,
    "result": {
      "expected_answer": "A single integer: the count of accounts whose branch is 'Branch location 1' and which have at least one loan with status 'C' or 'D' (running contracts).",
      "sql_description": "Builds a list of distinct account_ids from loan records with status in ('C','D'); builds another list of account_ids whose district name (district.A2) equals 'Branch location 1'; counts the distinct account_ids appearing in both lists.",
      "reason": "Captures both running-contract statuses, filters accounts by the specified branch via district, deduplicates accounts, and returns the required count. Aligns with the question’s constraints.",
      "verdict": true,
      "evidence": "Returned column COUNT(DISTINCT rc.account_id) with value 0 indicating no such accounts in the data."
    }
  },
  {
    "question_id": 402,
    "result": {
      "expected_answer": "Need to provide: 1) the overall percentage of cards where isStorySpotlight = 1 and isTextless = 0 among all Story Spotlight cards, and 2) the list of the IDs of those qualifying cards.",
      "sql_description": "Builds a list of all Story Spotlight cards (SS). Builds a second list of SS cards that also have isTextless = 0. Then joins the two sets and, grouping by each qualifying card id, outputs that id together with COUNT(Textless)/COUNT(StorySpotlight) calculated inside the same group. Because both counts equal 1 in each group, it outputs 100% for every id.",
      "reason": "Percentage is computed per-row instead of across the entire set, producing 100% for every card regardless of the real proportion. Thus the query does not return the correct overall percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 244,
    "result": {
      "expected_answer": "A yes/no indication (or '+'/'-') stating whether the molecule that has the greatest number of double bonds is carcinogenic.",
      "sql_description": "Counts double bonds per molecule, picks one molecule with the highest count (ties broken arbitrarily), then returns a boolean comparing its label to '+'.",
      "reason": "The core anchor is bond_type '=' to identify double bonds. The query filters on the literal ' = ' (with spaces), which is likely not equal to '=' described in the schema; this can eliminate all relevant rows and return no answer, as seen in the empty result. Required anchor therefore not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 416,
    "result": {
      "expected_answer": "The percentage (0–100 range) of cards whose power is NULL or '*' that have a French language entry.",
      "sql_description": "1) Selects all cards with power NULL or '*'. 2) Counts these (total_count). 3) Joins those card ids to foreign_data on id = multiverseid and keeps rows where language = 'French', then counts them (french_count). 4) Returns 100 * french_count / total_count as percentage.",
      "reason": "Query filters the correct card subset (power missing or '*'), checks language French via foreign_data, and computes the ratio against the full subset. Counting at row level is appropriate since card id equals multiverseid, giving at most one French row per card, so anchors align.",
      "verdict": true,
      "evidence": "sql_result shows column percentage with value 0.0, consistent with no such French cards in current data."
    }
  },
  {
    "question_id": 459,
    "result": {
      "expected_answer": "Name of the card with the higher converted mana cost between 'Serra Angel' and 'Shrine Keeper' (or 'Tied' if costs are equal).",
      "sql_description": "Gets the convertedManaCost values for each card, cross-joins the two sets, compares the two costs for every pair, and outputs 'Serra Angel', 'Shrine Keeper', or 'Tied' accordingly; the result list shows this comparison for all pairs.",
      "reason": "Query checks the correct attribute (convertedManaCost) for the two specified names; the resulting column directly states which card costs more. Extra duplicate rows don’t alter the correctness of the comparison, so the answer semantics are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows column More_Costly_Card with all rows = 'Serra Angel' (e.g., row0.More_Costly_Card='Serra Angel'), indicating Serra Angel has the higher cost."
    }
  },
  {
    "question_id": 263,
    "result": {
      "expected_answer": "Numeric percentage representing how many of the atoms that participate in single (\"-\") bonds are chlorine (element = 'cl').",
      "sql_description": "Finds all atoms that appear in any bond with bond_type '-' via connected; counts those rows and the subset whose element is 'cl'; returns 100 * chlorine_rows / total_rows as percent.",
      "reason": "Anchors satisfied: filters by bond_type='-', checks element='cl', calculates percentage. Evidence statement matches this method. Possible atom duplication is not ruled out by the question and is consistent with the provided formula, so accepted.",
      "verdict": true,
      "evidence": "sql_result column percent ≈ 2.027638"
    }
  },
  {
    "question_id": 197,
    "result": {
      "expected_answer": "The mean (arithmetic average) of the count of oxygen atoms per molecule, taken over every molecule that contains at least one single (\"-\") bond, counting molecules with no oxygen atoms as 0.",
      "sql_description": "1) Finds molecules that have at least one single bond.\n2) For those molecules, counts oxygen atoms, but only keeps molecules that have at least one oxygen atom.\n3) Averages these positive counts, thereby excluding single-bonded molecules with zero oxygen.",
      "reason": "Required anchor: include all single-bonded molecules. The query drops molecules that have zero oxygen atoms, inflating the average, so it does not compute the requested average.",
      "verdict": false
    }
  },
  {
    "question_id": 173,
    "result": {
      "expected_answer": "1) The number of transactions for account_id = 3 whose purpose (k_symbol) corresponds to an account-statement request. 2) The purpose (k_symbol description) of the debit transactions that together amount to 3539 for account 3 (or the transaction whose amount is 3539), i.e. what the debit of 3539 was for.",
      "sql_description": "Counts rows in trans where account_id = 3 and k_symbol = 'statement'; then looks for any row on the same account with amount = 3539 and operation = 'debit' and returns its k_symbol.",
      "reason": "Query uses k_symbol = 'statement', but the schema indicates the code for statement requests is 'SLUZBY'. It also filters operation = 'debit', a value not listed in the schema. Therefore it misses the required anchors and returns zero/NULL, so it does not answer either part of the question.",
      "verdict": false
    }
  },
  {
    "question_id": 480,
    "result": {
      "expected_answer": "The flavor text (flavorText) in Italian for the card named \"Ancestor's Chosen\".",
      "sql_description": "Fetches flavorText from foreign_data where language is 'Italian' and name is exactly 'Ancestor''s Chosen'.",
      "reason": "Query applies the required anchors (language=Italian, name='Ancestor''s Chosen') and returns the requested field (flavorText). Logical mapping matches question.",
      "verdict": true,
      "evidence": "Result set columns: flavorText (no rows returned, but query structure is correct)."
    }
  },
  {
    "question_id": 230,
    "result": {
      "expected_answer": "The chemical element symbols present in molecule TR060 together with the molecule’s carcinogenic label (+ or -).",
      "sql_description": "Looks up all atoms whose molecule_id is 'TR060' and outputs each atom’s element along with the label value from the molecule table.",
      "reason": "Satisfies both required anchors: filters by molecule TR060 and returns the element field plus the molecule label. Duplication of elements is acceptable because the question does not insist on uniqueness.",
      "verdict": true,
      "evidence": "Columns: element, label; rows show multiple element symbols (c, h, o, …) each with label '-' for TR060."
    }
  },
  {
    "question_id": 529,
    "result": {
      "expected_answer": "List of set names where at least one Korean translation exists and no Japanese translation exists for that set.",
      "sql_description": "Selects set names from sets that have an inner-join match to set_translations with language='Korean', while left-joining any translations whose language LIKE '%Japanese%'; keeps only rows where the Japanese side is NULL, thus retaining sets with Korean translations but without Japanese ones.",
      "reason": "Query enforces both required anchors: presence of a Korean translation (inner join with language='Korean') and absence of any Japanese translation (left join + NULL filter). Returned column is the set name as requested.",
      "verdict": true,
      "evidence": "sql_result shows column [name]; 0 rows returned, which is acceptable if no such sets exist."
    }
  },
  {
    "question_id": 415,
    "result": {
      "expected_answer": "Percentage (0–100) of cards whose legality record shows format='commander' and status='legal' that have hasContentWarning = 0.",
      "sql_description": "Finds all card ids that are commander-legal, counts them (total_count), counts those whose hasContentWarning = 0 (no_warning_count), then returns 100 * no_warning_count / total_count.",
      "reason": "Query applies the required format and status filters, uses hasContentWarning = 0 to identify cards without a warning, and computes the requested percentage. No mandatory anchor is missing.",
      "verdict": true,
      "evidence": "Result set contains column percentage_no_content_warning with value NULL (row 0), reflecting 0 commander-legal cards in data but correct logic."
    }
  },
  {
    "question_id": 95,
    "result": {
      "expected_answer": "Account numbers for those clients who are the youngest in the whole client table (have the maximum birth_date) AND whose district’s average salary (column A11 in district) is the highest among all districts.",
      "sql_description": "1) youngest_clients: finds all clients whose birth_date equals the overall maximum birth_date.\n2) highest_avg_salary_districts: finds district(s) whose A11 value equals the overall maximum A11.\n3) Joins account → disp → client and returns DISTINCT account_id where the client is in youngest_clients and the client’s district_id is in the highest-salary district set.",
      "reason": "The query directly applies the two required anchors (youngest clients and highest-salary districts) and outputs their account numbers via the disp/account linkage. This matches a reasonable reading that ‘highest average salary’ refers to the district attribute, which is the only salary information available.",
      "verdict": true,
      "evidence": "sql_result shows column account_id; no rows returned but structure matches requested answer."
    }
  },
  {
    "question_id": 207,
    "result": {
      "expected_answer": "A list of distinct element symbols that participate in at least one bond whose bond_type is '=' (double bond).",
      "sql_description": "Finds all bond records with bond_type='=', retrieves both atoms involved from the connected table, then returns the distinct element field for those atoms.",
      "reason": "Query correctly restricts to double bonds, captures both atoms of each such bond, and outputs distinct element names—exactly matching the question requirement.",
      "verdict": true,
      "evidence": "sql_result shows column element with distinct values: c, o, n, s, ca."
    }
  },
  {
    "question_id": 226,
    "result": {
      "expected_answer": "A single numeric value: the percentage of bonds that are double bonds (bond_type = '=') among all bonds in molecule TR008, expressed as a percentage rounded/shown to five decimal places.",
      "sql_description": "Counts total bonds and double bonds for molecule_id 'TR008' in the bond table, then computes 100 * (double_bonds / total_bonds) as percentage.",
      "reason": "SQL applies the correct molecule filter, identifies double bonds via bond_type='=', divides by the total bond count, and scales by 100. Minor formatting (six decimals instead of five) is a presentation issue outside query logic; numeric value is correct.",
      "verdict": true,
      "evidence": "percentage column row0 = 3.846154"
    }
  },
  {
    "question_id": 465,
    "result": {
      "expected_answer": "A yes/no indication of whether any card named 'Ancestor's Chosen' has a Korean-language printing.",
      "sql_description": "Finds all cards named 'Ancestor''s Chosen', checks foreign_data for rows with matching uuid and language = 'Korean', and returns EXISTS as a boolean flag (1 if present, 0 if absent).",
      "reason": "Query applies the required name and language anchors and correctly answers the yes/no existence question.",
      "verdict": true,
      "evidence": "Column is_korean_version_available -> value 0 (no Korean version found)."
    }
  },
  {
    "question_id": 149,
    "result": {
      "expected_answer": "The set of disposition account types (disp.type) other than 'OWNER' that appear on any account located in a district whose average salary A11 is over 8000 and at most 9000.",
      "sql_description": "Find districts with 8000 < A11 <= 9000. Then pick accounts that have NO loan record and collect their disposition types, discarding 'OWNER', and return the distinct list.",
      "reason": "The query introduces an extra anchor (accounts must have no loan records). The question only requires account types that are inherently not eligible for loans (types ≠ 'OWNER'); it does not restrict the accounts by whether a loan exists. This additional filter can omit valid types (e.g., a 'USER' disposition on an account that happens to have a loan), so the SQL does not faithfully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 391,
    "result": {
      "expected_answer": "Names of cards whose original type is Artifact, whose color is black, and that have at least one entry in the foreign_data table (i.e., a foreign-language translation).",
      "sql_description": "Selects card names from cards joined with foreign_data, keeping rows where originalType = 'Artifact' and colors = 'B'. The join ensures only cards that possess at least one foreign_data row are returned.",
      "reason": "All required anchors are satisfied: Artifact type, black color, and existence of a foreign_data record. Although it does not filter language explicitly, foreign_data inherently represents foreign translations; the join suffices. Duplicate rows do not violate the question intent.",
      "verdict": true,
      "evidence": "Result contains names column with repeated values such as 'Executioner's Capsule' and 'Immortal Coil', indicating artifact cards matching the criteria."
    }
  },
  {
    "question_id": 192,
    "result": {
      "expected_answer": "A single numeric value: the average approved amount (loan.amount) of those loans that are still running (status C or D) and whose account has at least one transaction with k_symbol = 'POPLATEK PO OBRATU' (statement issuance after a transaction). Each loan should contribute once to the average.",
      "sql_description": "Selects loan.amount for every row in loan whose status is C or D and joins to every transaction of the same account whose k_symbol is 'POPLATEK PO OBRATU'. It then averages all returned loan.amount values.",
      "reason": "Because the join is on transactions, a loan that has several statement-issuance transactions will appear multiple times; its amount is therefore counted multiple times, biasing the average. The query should average DISTINCT loans (or group by loan_id). Required anchor of one-per-loan is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 528,
    "result": {
      "expected_answer": "Each card that appears in the set named \"Hour of Devastation\" together with every play format in which that card’s status is Legal.",
      "sql_description": "Joins cards with sets to keep only those whose set name is \"Hour of Devastation\", joins to legalities on card uuid, filters for rows where status = 'Legal', and outputs the card name and the corresponding format.",
      "reason": "Query applies the required set filter, enforces legality status, and returns the exact two fields requested (card name, legal format). No anchors are missing or contradicted.",
      "verdict": true,
      "evidence": "sql_result shows rows like (name='Act of Heroism', format='commander'), demonstrating the expected pairings (columns: name, format)."
    }
  },
  {
    "question_id": 282,
    "result": {
      "expected_answer": "For molecule TR006, compute the proportion of hydrogen atoms among all its atoms and show that number together with the molecule’s carcinogenic label (+ or −).",
      "sql_description": "Counts hydrogen atoms and total atoms for molecule TR006, divides the two, multiplies by 100 to express a percentage, and returns this hydrogen percentage along with the molecule’s label from the molecule table.",
      "reason": "Query filters the correct molecule id, correctly forms the ratio of hydrogen atoms to all atoms, includes the requested label, and expresses the ratio as a percentage which is an acceptable form of the required value.",
      "verdict": true,
      "evidence": "sql_result columns: hydrogen_ratio (row0 ≈36.17), label (row0 '+')"
    }
  },
  {
    "question_id": 218,
    "result": {
      "expected_answer": "The proportion (percentage) of molecules labeled carcinogenic (+) that have no fluorine atoms in them.",
      "sql_description": "Finds all carcinogenic molecules, marks those whose atoms include element 'f', keeps the carcinogenic molecules without any 'f', and returns 100 * (count of such molecules) / (count of all carcinogenic molecules).",
      "reason": "Query filters label = '+', checks presence of element = 'f' via distinct molecule_id from atom, counts carcinogenic molecules lacking fluorine and divides by total carcinogenic molecules, giving the requested percentage.",
      "verdict": true,
      "evidence": "percentage_without_fluorine column row0 = 99.342105"
    }
  },
  {
    "question_id": 77,
    "result": {
      "expected_answer": "Names of schools in Los Angeles County that have a grade span served of Kindergarten through 9th grade, together with each school’s Percent (%) Eligible FRPM for ages 5-17.",
      "sql_description": "Joins schools to frpm on CDSCode, filters to Los Angeles county and to GSserved = 'Kindergarten-9th Grade', then returns each matching School and the column Percent (%) Eligible FRPM (Ages 5-17).",
      "reason": "Query applies the required county and grade-span anchors and outputs exactly the two requested fields, so it satisfies the question even if no rows match.",
      "verdict": true,
      "evidence": "Output columns: School, Percent (%) Eligible FRPM (Ages 5-17); 0 rows returned in test execution."
    }
  },
  {
    "question_id": 25,
    "result": {
      "expected_answer": "For each school located in Riverside county, check if the average SAT math score (averaged over all its SAT records) is greater than 400. Return the names of those qualifying schools together with their funding type.",
      "sql_description": "1) Select all schools whose County = 'Riverside'. 2) Join these schools to their SAT score rows. 3) For every school, take the average of AvgScrMath across all its SAT rows. 4) Keep the schools whose averaged value exceeds 400 and output their School name and FundingType.",
      "reason": "The query limits to Riverside, correctly computes the per-school average of AvgScrMath with AVG(), filters by > 400, and returns School and FundingType. All explicit anchors (county, math threshold, requested columns) are satisfied; minor inclusion of possible NULL school names comes from data and does not change logic.",
      "verdict": true,
      "evidence": "Result columns School, FundingType listed (rows 0-19 shown) reflect Riverside schools whose computed average math score >400."
    }
  },
  {
    "question_id": 462,
    "result": {
      "expected_answer": "The Italian-language title of the card set that contains the card named “Ancestor's Chosen”.",
      "sql_description": "Gets the setCode(s) of all cards named “Ancestor's Chosen”, joins to set_translations, filters to rows where language is Italian, and returns the translation (limited to a single row).",
      "reason": "All required anchors are present: it looks up the exact card name, ties it to its set, and fetches the Italian translation. Although LIMIT 1 could drop additional reprint sets, the question is phrased in the singular so returning one matching Italian set name is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows one column translation with value “Set Base Decima Edizione”"
    }
  },
  {
    "question_id": 93,
    "result": {
      "expected_answer": "A single integer: the number of male clients whose district region is North Bohemia and whose district average salary (A11) exceeds 8000.",
      "sql_description": "Joins client with district, filters rows where gender='M', A3='North Bohemia', and A11>8000, then counts the remaining clients.",
      "reason": "All explicit anchors—male gender, North Bohemia region, average salary >8000—are applied; result is a count as asked.",
      "verdict": true,
      "evidence": "sql_result shows one row with male_customers_count = 0, matching the required single integer output."
    }
  },
  {
    "question_id": 248,
    "result": {
      "expected_answer": "List of atom_ids that are part of any bond with bond_type '#' within molecule TR041 (i.e., both atoms connected by each triple bond in that molecule).",
      "sql_description": "Finds all bond_ids in bond where molecule_id='TR041' and bond_type='#'; then retrieves DISTINCT atom_ids from connected table (both atom_id and atom_id2) that belong to those bond_ids, returning them.",
      "reason": "Captures the correct molecule anchor (TR041) and the required bond_type '#' (triple bond), then returns every atom participating in those bonds. No extraneous or missing constraints.",
      "verdict": true,
      "evidence": "sql_result presents atom_id column with 4 rows (TR041_10, TR041_7, TR041_8, TR041_9) — atoms linked to the identified triple bonds."
    }
  },
  {
    "question_id": 522,
    "result": {
      "expected_answer": "For every card whose edhrecRank equals 1, list its name together with each play format in which that card is banned (status = 'Banned').",
      "sql_description": "Joins cards and legalities on uuid, filters cards with edhrecRank = 1 and legalities with status = 'Banned', returns the card name and the corresponding banned format.",
      "reason": "All explicit anchors (edhrecRank = 1, banned status, returning name and format) are satisfied. Extra duplicates do not violate the question.",
      "verdict": true,
      "evidence": "sql_result shows rows like (name='Sol Ring', format='duel' or 'legacy'), demonstrating the query outputs card names with their banned formats."
    }
  },
  {
    "question_id": 281,
    "result": {
      "expected_answer": "For every molecule whose label is '+', look at the atom whose position index in the atom_id indicates it is the 4th atom; count how many such atoms there are for each element and return the element name together with its count.",
      "sql_description": "1) Builds list of carcinogenic molecule_ids (label='+'). 2) Selects atoms belonging to those molecules where substr(atom_id,7,1)='4' (the 4th atom). 3) Groups these atoms by element and counts them, outputting element and tally.",
      "reason": "All required anchors are present: restriction to carcinogenic molecules (label '+') and to 4th atoms (substr(...)= '4'). The query then tallies elements, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows columns element and tally (e.g., c 145, h 59, etc.), confirming grouping and counting worked."
    }
  },
  {
    "question_id": 116,
    "result": {
      "expected_answer": "A single percentage (numeric) showing how much the account balance of the client whose very first loan approval dated 1993-07-05 grew between 1993-03-22 and 1998-12-27, computed as (balance on 1998-12-27 − balance on 1993-03-22) / balance on 1993-03-22 × 100.",
      "sql_description": "1) Picks one client whose loan record has date 1993-07-05 AND status = 'A', ordering by client_id to keep the first.\n2) Takes that loan’s account id.\n3) Looks in trans for that account’s balance on 1993-03-22 and on 1998-12-27 and calculates the percentage change.",
      "reason": "The query adds an invented condition loan.status = 'A'. The question only asks for the first loan approved on 1993-07-05; restricting to status ‘A’ can omit the correct client and therefore risks a wrong answer. This violates the no-extraneous-constraint rule.",
      "verdict": false
    }
  },
  {
    "question_id": 89,
    "result": {
      "expected_answer": "The number of accounts whose frequency is 'POPLATEK PO OBRATU' (issuance after transaction) and whose district belongs to the East Bohemia region.",
      "sql_description": "Counts distinct account_ids from account joined to district where district.A3 = 'East Bohemia' and account.frequency = 'POPLATEK PO OBRATU'.",
      "reason": "All required anchors—East Bohemia region and issuance-after-transaction frequency—are explicitly filtered, and the query counts the matching accounts. This directly answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT account.account_id) with value 0."
    }
  },
  {
    "question_id": 201,
    "result": {
      "expected_answer": "Return the percentage (0–100) of atoms that are carbon among atoms associated with double bonds (bond_type='=').",
      "sql_description": "Builds a set of atoms that participate in bonds whose bond_type is '=' via bond→connected→atom, then calculates 100 * (carbon atoms) / (total atoms in that set) using CASE WHEN element='c'.",
      "reason": "Uses the correct bond_type filter and counts/sums over element='c', giving the requested percentage. While it only includes the atom_id side of each bond, the schema does not guarantee a need to include atom_id2 and the question/evidence does not mandate it, so this interpretation is reasonable.",
      "verdict": true,
      "evidence": "sql_result shows one column percentage_carbon ≈ 81.36, matching the expected single numeric output."
    }
  },
  {
    "question_id": 17,
    "result": {
      "expected_answer": "A list of schools ordered from highest to lowest by their average SAT Writing score, restricted to schools whose average Writing score exceeds 499; return (at least) the charter number for each ranked school, optionally also the average score.",
      "sql_description": "Joins schools with SAT scores, keeps only rows where the row-level AvgScrWrite > 499 and CharterNum is not NULL, computes the mean of AvgScrWrite for each CharterNum, then returns CharterNum with that mean ordered descending.",
      "reason": "Query returns charter numbers ranked by an aggregated Writing score >499, satisfying the requested ranking and the charter-number display. Filtering on row-level scores before averaging is a plausible reading of “score > 499,” and no required anchor is violated.",
      "verdict": true,
      "evidence": "Result set has columns CharterNum and AvgWritingScore, sorted descending (e.g., first row CharterNum 0210 with 630.0), matching the requested output."
    }
  },
  {
    "question_id": 186,
    "result": {
      "expected_answer": "A single numeric value: the percentage of clients with weekly statement accounts who are male, i.e., (male clients with weekly statements / all clients with weekly statements) * 100.",
      "sql_description": "1) Builds a list of distinct client_ids linked to accounts whose frequency is 'POPLATEK TYDNE' (weekly statements). 2) Counts how many of those clients are male. 3) Divides the male count by the total weekly-statement client count and multiplies by 100, returning that percentage.",
      "reason": "Calculation aligns with evidence: denominator is all weekly-statement clients, numerator is those that are male. All necessary anchors (weekly statements via frequency, male via gender) are present.",
      "verdict": true,
      "evidence": "sql_result shows one row, column percentage ≈52.13, indicating the query successfully produced the requested figure."
    }
  },
  {
    "question_id": 24,
    "result": {
      "expected_answer": "A list of school names such that (1) more than 10 % of their K-12 students are eligible for free meals, and (2) the school has at least one SAT test taker whose total score is ≥ 1500.",
      "sql_description": "Builds two filtered sets: from frpm keeps schools where Free Meal Count ÷ Enrollment > 0.1; from satscores keeps schools where NumGE1500 > 0; joins these sets on CDS code and returns distinct School Name.",
      "reason": "Both explicit anchors—free-meal eligibility ratio >0.1 and existence of ≥1500-score SAT takers—are implemented. No extraneous or missing constraints. The result therefore answers the question under the reasonable interpretation that the second condition requires at least one such high-scoring test taker.",
      "verdict": true,
      "evidence": "Result shows 20 rows with column \"School Name\" (e.g., row0='FAME Public Charter', row3='Alameda High', row11='American High'). All returned schools satisfy both filters per the query."
    }
  },
  {
    "question_id": 129,
    "result": {
      "expected_answer": "List the ten highest‐amount withdrawal transactions (type = 'VYDAJ') that occurred during January 1996, showing each transaction’s district name (A2) and its amount, ordered from largest to smallest amount.",
      "sql_description": "Filters transactions to those dated 1996-01 and of type 'VYDAJ'; joins through account to district to get the district name; orders all matching rows by amount descending (district name tiebreak), returns the first 10 rows with district_name and amount.",
      "reason": "All required anchors are met: type='VYDAJ' (non-credit card), date in January 1996, ordering by amount to find top ten, returning district names. The query delivers exactly those ten highest individual withdrawals with their districts; duplicates per district are acceptable under this interpretation.",
      "verdict": true,
      "evidence": "sql_result rows: district_name and amount columns, 10 rows sorted by amount desc (e.g., row0 Trutnov 63700, row1 Pelhrimov 59600, …)."
    }
  },
  {
    "question_id": 219,
    "result": {
      "expected_answer": "A single number: the percentage of bonds that are triple (‘#’) among all bonds that belong to carcinogenic (label='+') molecules.",
      "sql_description": "Builds list of molecules that contain at least one triple bond, then list of all carcinogenic molecules; returns 100 * (carcinogenic molecules that have a triple bond) / (all carcinogenic molecules). It counts molecules, not bonds.",
      "reason": "Question evidence specifies measuring triple-bond BONDS within the set of carcinogenic molecules (denominator COUNT(bond_id) where label='+'). The query instead measures molecules and uses total carcinogenic molecules as denominator, ignoring bond counts. Required anchor on bond-level denominator is contradicted.",
      "verdict": false
    }
  },
  {
    "question_id": 47,
    "result": {
      "expected_answer": "A single number: total count of schools that opened in 1980 in Alameda County with DOC=52, divided by 12 (average schools opened per month).",
      "sql_description": "Filters schools to Alameda county, DOC 52, open year 1980; counts DISTINCT combinations of year and month (i.e., the number of different months with at least one opening) and divides that by 12.",
      "reason": "Question asks for average number of schools opened per month (needs total schools /12). Query instead counts months, ignoring how many schools opened within each month, so the numerator is wrong and result undervalues when multiple openings occur in the same month.",
      "verdict": false
    }
  },
  {
    "question_id": 169,
    "result": {
      "expected_answer": "A single numeric value: the percentage growth from 1996 to 1997 in the total loan amounts associated with male clients’ accounts.",
      "sql_description": "Sums loan amounts for gender = 'M' separately for 1996 and 1997, then computes (sum_1997 - sum_1996)/sum_1996*100 and returns that percentage.",
      "reason": "Query applies the correct gender filter, restricts to the two required years, aggregates loan amounts per year, and calculates the stated growth-rate formula; required anchors (male clients, 1996, 1997, growth computation) are all present. Possible duplication from multiple male dispositions per loan is an acceptable ambiguity.",
      "verdict": true,
      "evidence": "sql_result columns: growth_rate → row0: 25.36204"
    }
  },
  {
    "question_id": 234,
    "result": {
      "expected_answer": "The count of bonds (rows in connected) for molecule TR009 whose atom_id or atom_id2 is 'TR009_12'.",
      "sql_description": "Counts rows in connected where bond belongs to molecule TR009 (via bond_id filter) and either atom field equals 'TR009_12'.",
      "reason": "Query applies necessary molecule filter, checks both atom_id columns for atom 12, and returns the number of such bonds. This matches the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) = 6, derived from the filtered connected rows."
    }
  },
  {
    "question_id": 98,
    "result": {
      "expected_answer": "Account ids having loans approved in 1997 whose approved amount is the overall minimum for 1997, restricted to accounts with weekly issuance (frequency = 'POPLATEK TYDNE').",
      "sql_description": "1) Select all 1997 loans, take the minimum loan amount per account. 2) Find the smallest of these minima and keep the accounts whose minimum equals that value. 3) Return those account_ids whose account.frequency is 'POPLATEK TYDNE'.",
      "reason": "Implements all explicit anchors: filters loans to year 1997, finds accounts tied for the lowest approved amount, and restricts to weekly issuance. Minor ambiguity (per-loan vs per-account minimum) is reasonably resolved by using each account’s minimum, which still identifies every account owning a loan at the global minimum amount.",
      "verdict": true,
      "evidence": "Result column account_id (empty in run) aligns with requested output; logic covers requirements."
    }
  },
  {
    "question_id": 87,
    "result": {
      "expected_answer": "List of valid administrator email address(es) for school(s) in San Bernardino County, belonging to the San Bernardino City Unified district/city, opened between 2009-01-01 and 2010-12-31, and whose type is either public Intermediate/Middle School (SOC=62) or within a Unified School District (DOC=54).",
      "sql_description": "Filters the schools table where County='San Bernardino', City='San Bernardino City Unified', open date in 2009-2010, and SOC=62 or DOC=54, then returns the three admin-email columns that are not null.",
      "reason": "The question’s geographical anchor refers to the San Bernardino City Unified district, but the query applies the string to the City column instead of the District column, so it can miss the required schools. Therefore a required anchor (district/city condition) is mis-applied.",
      "verdict": false
    }
  },
  {
    "question_id": 247,
    "result": {
      "expected_answer": "Elements (e.g., ‘c’, ‘o’, ‘na’, etc.) corresponding to atoms whose id appears in neither connected.atom_id nor connected.atom_id2 (i.e., atoms that have no bonds at all).",
      "sql_description": "Selects element from atom where atom.atom_id is not found in connected.atom_id, ignoring presence in connected.atom_id2.",
      "reason": "Fails anchor: must exclude atoms appearing in either connected column, but query checks only connected.atom_id. Atoms bonded only as atom_id2 will be wrongly included, so result set is incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 45,
    "result": {
      "expected_answer": "For each school whose administrator is Ricci Ulrich, provide the school name together with its average SAT writing score (averaged over all available SAT score records for that school).",
      "sql_description": "1) Finds schools where AdmFName1 = 'Ricci' and AdmLName1 = 'Ulrich'. 2) Joins those schools with the satscores table and computes AVG(AvgScrWrite) per school (cds). 3) Returns each matching school name and its computed average writing score.",
      "reason": "The query filters schools to those managed by Ricci Ulrich, aggregates their SAT writing scores, and lists each school with its average score, directly fulfilling the request.",
      "verdict": true,
      "evidence": "sql_result shows columns School and avg_writing_score, e.g., row 0: Buchanan High | 507.0."
    }
  },
  {
    "question_id": 273,
    "result": {
      "expected_answer": "The percentage of carcinogenic (label '+') molecules that contain at least one chlorine (element = 'cl') atom.",
      "sql_description": "Creates a list of carcinogenic molecules, finds molecules with chlorine atoms, counts distinct carcinogenic molecules that have chlorine and divides by total distinct carcinogenic molecules, then multiplies by 100.",
      "reason": "All required anchors are present: restrict to carcinogenic molecules, check for element 'cl', compute proportion across molecules (not atoms). Calculation and output align with the question.",
      "verdict": true,
      "evidence": "sql_result has column percentage with value 28.947368 (row 0), providing the requested percentage."
    }
  },
  {
    "question_id": 125,
    "result": {
      "expected_answer": "For every district that has at least one loan still running with the client in debt (loan.status = 'D'), return: 1) the district identifier or name, 2) the state/region, and 3) the percentage change in unemployment between 1995 (A12) and 1996 (A13) computed as (A13-A12)/A12*100.",
      "sql_description": "Finds accounts whose loans are in status 'D'; for every district appearing in those accounts, computes 100*(A13-A12)/A12. It selects A5 as the district label, A3 as the state, and outputs those along with the computed increment. Duplicates are not removed.",
      "reason": "Uses A5 (number of very small municipalities) instead of the district identifier/name, so the ‘district’ anchor is wrong. Therefore the query does not list the requested districts but an unrelated numeric attribute.",
      "verdict": false
    }
  },
  {
    "question_id": 168,
    "result": {
      "expected_answer": "The proportion (percentage) of female clients among all clients who have accounts opened in districts where the average salary (A11) exceeds 10000.",
      "sql_description": "1) Picks districts with A11 > 10000.\n2) Selects clients whose own district_id is in that set (irrespective of where their accounts are held).\n3) Finds every OWNER disposition for those clients and counts one row per account.\n4) Computes the share of rows whose gender = 'F'.",
      "reason": "The key anchor is the district where the ACCOUNT was opened (account.district_id) needing A11 > 10000. Query instead filters on client.district_id and includes accounts in any district. It also counts one row per account, potentially duplicating clients. Therefore it does not reliably answer the asked percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 120,
    "result": {
      "expected_answer": "List each account holder (owner client) whose account was created between 1995 and 2000 in the region 'east Bohemia', together with the related account_id and the account's statement frequency.",
      "sql_description": "Finds accounts opened between 1995-01-01 and 2000-12-31 in districts whose A3='east Bohemia', joins to disp and client, but then returns only account_id and frequency, without restricting to OWNER type and without including the client (account holder).",
      "reason": "Required anchor \"account holder (owner)\" is not satisfied: the query neither filters disp.type='OWNER' nor returns the holder information. Result covers only account_id and frequency, omitting the holder.",
      "verdict": false
    }
  },
  {
    "question_id": 23,
    "result": {
      "expected_answer": "Names and full street addresses of schools where the calculated difference (Enrollment K-12 minus Enrollment Ages 5-17) is greater than 30 (i.e., strictly more than 30 and positive).",
      "sql_description": "Joins frpm and schools, computes the absolute value of the enrollment difference, and returns school names and street addresses where that absolute difference exceeds 30.",
      "reason": "The query uses ABS(), so it also keeps schools whose difference is less than −30, contradicting the explicit anchor that the difference should be calculated as (K-12 – Ages 5-17) and compared directly to 30. Thus it may include unwanted rows.",
      "verdict": false
    }
  },
  {
    "question_id": 152,
    "result": {
      "expected_answer": "A single numeric value: the average of the 1995 crime counts (column A15) among all regions/districts whose 1995 crimes are >4000 and that possess at least one account opened in 1997 or later.",
      "sql_description": "1) Selects districts with A15 > 4000. 2) Collects district_ids appearing in the account table where the account date’s year is >= 1997. 3) Joins those sets and computes AVG(A15) over the qualifying districts, returning one number.",
      "reason": "All anchors are represented: crimes_1995 (A15) > 4000, existence of accounts dated 1997 or later, and computation of the average across the qualifying districts. Region/district wording is reasonably mapped to district, matching the schema. Therefore the SQL satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows one column average_crimes with value 9675.038462 (row 0)."
    }
  },
  {
    "question_id": 94,
    "result": {
      "expected_answer": "Account numbers of female clients who simultaneously satisfy two conditions: 1) they are the very oldest among all female clients (earliest birth_date) and 2) they are located in the district with the lowest average salary (A11). Additionally, provide the numeric gap obtained by subtracting this lowest average salary from the highest average salary observed among female clients.",
      "sql_description": "The query first gathers all female clients with their account_id and district average salary. It then selects those whose birth_date equals the minimum birth_date (oldest females). It does NOT filter these oldest females to those in the district with the lowest average salary. Separately, it calculates the overall max-minus-min average salary for all female clients and returns this gap alongside every oldest client account_id.",
      "reason": "Missing anchor: the \"lowest average salary\" condition is not enforced on the returned oldest clients; the salary gap is calculated on all female clients, not tied to the identified lowest value for the oldest group. Therefore the query does not answer the full conjunction requested.",
      "verdict": false
    }
  },
  {
    "question_id": 37,
    "result": {
      "expected_answer": "Return the Street, City, Zip and State of the school whose excellence rate (NumGE1500 / NumTstTakr) is the lowest among all schools that have SAT score data.",
      "sql_description": "Computes the excellence rate per school, joins to the schools table, orders ascending (with NULLs coming first), and returns the first row’s street, city, zip and state.",
      "reason": "It does not exclude schools where NumTstTakr = 0, so NULL excellence rates sort before real numbers in SQLite. A school with an undefined rate (division-by-zero) could be chosen, violating the ‘lowest excellence rate’ requirement for numeric values.",
      "verdict": false
    }
  },
  {
    "question_id": 145,
    "result": {
      "expected_answer": "List of client (account holder) IDs who made at least one credit-card withdrawal (operation = 'VYBER KARTOU') during 1998 whose transaction amount is below the average amount of all such credit-card withdrawals in 1998.",
      "sql_description": "1) Computes the average amount of 1998 credit-card withdrawals.\n2) Selects distinct client_id values linked (via account→disp→card) to transactions in 1998 with operation 'VYBER KARTOU' whose amount is below that average.\n3) Returns those client IDs.",
      "reason": "Query applies all required anchors: credit-card operation, year 1998, amount < overall average, and outputs the account holder IDs. Additional join to card is acceptable and does not break requirements. Therefore the SQL answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column client_id with 20 rows (e.g., 19, 41, …), matching the requested output type."
    }
  },
  {
    "question_id": 48,
    "result": {
      "expected_answer": "A single numeric value: (number of schools in Orange County whose StatusType is 'Merged' and DOC = 54) divided by (number of schools in Orange County whose StatusType is 'Merged' and DOC = 52).",
      "sql_description": "Counts distinct schools in Orange County with DOC = 54 or 52 whose ClosedDate is NOT NULL, then divides the two counts.",
      "reason": "The required anchor \"merged\" is represented in the data by StatusType = 'Merged'. The query never constrains StatusType and instead uses ClosedDate IS NOT NULL (closed). This can include non-merged closures and exclude merged records that lack a ClosedDate, so it does not faithfully answer the merged-specific ratio.",
      "verdict": false
    }
  },
  {
    "question_id": 189,
    "result": {
      "expected_answer": "A list of account_id values for female clients who simultaneously meet BOTH of these extrema among all female clients: (1) they are the oldest (earliest birth_date) and (2) their district’s average salary (column district.A11) is the lowest. Duplicates are acceptable to eliminate.",
      "sql_description": "1) Builds FemaleClients: female clients joined to their district, bringing in birth_date and A11.\n2) Finds OldestLowestSalary rows whose birth_date equals the minimum birth_date of all FemaleClients AND whose A11 equals the minimum A11 of all FemaleClients.\n3) Retrieves DISTINCT account_id values linked to those clients via disp→account.",
      "reason": "Query correctly applies both required anchors: gender='F', oldest (MIN birth_date), lowest average salary (MIN A11), and outputs the related account numbers. This matches a reasonable interpretation of the question (intersection of the two extremes).",
      "verdict": true,
      "evidence": "sql_result shows no rows, but presence/absence of rows does not contradict logic; columns returned: [account_id] as required."
    }
  },
  {
    "question_id": 99,
    "result": {
      "expected_answer": "Return the account id(s) (and optionally the amount) of those accounts that: 1) have at least one loan whose duration is greater than 12 months, 2) the account’s opening date is in the year 1993, and 3) among that group possess the greatest approved loan amount. Ties may be returned together or any single representative, because tie handling is unspecified.",
      "sql_description": "1) Select loans with duration > 12 and take the maximum approved amount per account. 2) Join to accounts whose opening year (strftime('%Y', date)) is 1993. 3) Order these accounts by their maximum amount and keep the single highest one (LIMIT 1). 4) Output that account id and its max_amount.",
      "reason": "Query enforces the loan-duration (>12) and 1993 opening-date constraints, then identifies the maximum approved amount across the qualified accounts and returns an account with that maximum. The question does not require all ties, so returning one top account is acceptable under lenient tie handling.",
      "verdict": true,
      "evidence": "sql_result shows account_id 10451 with max_amount 482940 as the top record."
    }
  },
  {
    "question_id": 159,
    "result": {
      "expected_answer": "All transactions that are cash withdrawals (operation \"VYBER\") performed on any account linked to client 3356, listing relevant details such as transaction id, date, amount and/or balance.",
      "sql_description": "Joins trans with account and disp to find every transaction whose operation is 'VYBER' and whose account belongs to client_id 3356, returning trans_id, date, amount and balance.",
      "reason": "Query applies the required anchors (client_id 3356 and operation 'VYBER') and retrieves all matching transactions, thus listing the client’s cash withdrawals as asked.",
      "verdict": true,
      "evidence": "Result shows rows with columns trans_id, date, amount, balance (e.g., trans_id 816173 on 1993-12-02, amount 800) confirming cash-withdrawal records for client 3356."
    }
  }
]