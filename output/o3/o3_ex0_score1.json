[
  {
    "question_id": 637,
    "question": "State all the tags used by Mark Meckes in his posts that doesn't have comments.",
    "evidence": "used by Mark Meckes refers to DisplayName = 'Mark Meckes'; Doen't have comments refers to CommentCount = 0;",
    "gold_sql": "SELECT T3.Tags FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T3.Id = T2.PostId WHERE T1.DisplayName = 'Mark Meckes' AND T3.CommentCount = 0",
    "predicted_sql": "SELECT DISTINCT T2.`TagName`\n  FROM posts AS T1\n  INNER JOIN tags AS T2\n  ON T1.`Tags` LIKE '%<' || T2.`TagName` || '>%'\n  WHERE T1.`OwnerUserId` = (\n    SELECT `Id`\n    FROM users\n    WHERE `DisplayName` = 'Mark Meckes'\n  )\n  AND T1.`CommentCount` = 0",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "All tag names appearing in posts authored by the user whose DisplayName is 'Mark Meckes' where those posts have CommentCount equal to 0.",
      "sql_description": "Find the Id of the user 'Mark Meckes'; from posts with that OwnerUserId and CommentCount = 0, pattern-match each post’s <Tags> field against the tags table, and return distinct matching TagName values.",
      "reason": "The query applies both explicit anchors: owner = Mark Meckes and CommentCount = 0, then extracts every distinct tag attached to such posts. That directly answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column TagName = 'books', demonstrating the query outputs tag names as required."
    },
    "refuter_details": {
      "judgement": "Prediction lists the distinct tag names (e.g., \"books\") for Mark Meckes’s zero-comment posts, matching the question; differences are only formatting/duplication vs. gold.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": true
    }
  },
  {
    "question_id": 937,
    "question": "What's the finish time for the driver who ranked second in 2008's AustChineseralian Grand Prix?",
    "evidence": "finish time refers to time; Chinese Grand Prix refers to races.name = 'Chinese Grand Prix';",
    "gold_sql": "SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T2.year = 2008",
    "predicted_sql": "SELECT `time`\n  FROM results\n  WHERE `raceId` = (\n    SELECT `raceId`\n    FROM races\n    WHERE `year` = 2008 AND `name` = 'Chinese Grand Prix'\n  )\n  AND `position` = 2",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "The finishing time (time field) for the driver who came 2nd in the 2008 Chinese Grand Prix.",
      "sql_description": "Gets raceId for the 2008 race named 'Chinese Grand Prix', then returns the time value from results where that raceId matches and position = 2.",
      "reason": "Question anchors: year 2008, race name 'Chinese Grand Prix', finishing position 2. Query applies all anchors and returns the requested time.",
      "verdict": true,
      "evidence": "sql_result row0 time = '+14.925'"
    },
    "refuter_details": {
      "judgement": "Prediction uses position=2 to get second-place finisher’s time (+14.925), matching normal interpretation of “ranked second”; gold uses rank=2 (fast-lap rank), giving a different driver, so gold is likely wrong.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": false
    }
  },
  {
    "question_id": 1243,
    "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
    "evidence": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; abnormal prothrombin time (PT) refers to PT > = 14; percentage = DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)) * 100; female refers to sex = 'F'; ",
    "gold_sql": "SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN T2.PT >= 14 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday) > 55",
    "predicted_sql": "SELECT \n  (COUNT(CASE WHEN T2.`SEX` = 'F' THEN 1 END) * 100.0 / COUNT(*)) AS percentage\n  FROM Laboratory AS T1\n  INNER JOIN Patient AS T2\n  ON T1.`ID` = T2.`ID`\n  WHERE T2.`Birthday` IS NOT NULL\n  AND (strftime('%Y', 'now') - strftime('%Y', T2.`Birthday`)) > 55\n  AND T1.`PT` >= 14",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "A single numeric value: the percentage of females among patients older than 55 whose prothrombin time (PT) is at least 14.",
      "sql_description": "Joins Laboratory with Patient, filters to records where age (current year − birth year) > 55 and PT ≥ 14, then divides the number of those records with SEX = 'F' by the total number of such records and multiplies by 100 to yield a percentage.",
      "reason": "The query enforces all explicit anchors (age > 55, PT ≥14, SEX='F') and returns the requested female-percentage; counting laboratory rows instead of distinct patients is a reasonable interpretation given the evidence formula that uses plain SUM/COUNT without DISTINCT.",
      "verdict": true,
      "evidence": "sql_result shows column \"percentage\" with value 78.362573 (row 0), matching the requested output format."
    },
    "refuter_details": {
      "judgement": "Pred query restricts denominator to abnormal PT per spec, while gold counts all lab rows, yielding an incorrect tiny percentage; prediction is semantically correct.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": false
    }
  },
  {
    "question_id": 1275,
    "question": "Among the patients who has a normal level of anti-centromere and a normal level of anti-SSB, how many of them are male?",
    "evidence": "normal level of anti-centromere refers to CENTROMEA IN('-', '+-'); normal level of anti-SSB refers to SSB IN('-', '+-'); male refers to Sex = 'M'; Should consider DISTINCT in the final result;",
    "gold_sql": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CENTROMEA IN ('negative', '0') AND T2.SSB IN ('negative', '0') AND T1.SEX = 'M'",
    "predicted_sql": "SELECT COUNT(DISTINCT T1.`ID`)\n  FROM Patient AS T1\n  INNER JOIN Laboratory AS T2\n  ON T1.`ID` = T2.`ID`\n  WHERE T2.`CENTROMEA` IN ('-', '+-')\n  AND T2.`SSB` IN ('-', '+-')\n  AND T1.`SEX` = 'M'",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "A single integer: the number of distinct male patients whose anti-centromere (CENTROMEA) and anti-SSB (SSB) test values are within the normal range ('-' or '+-').",
      "sql_description": "Counts DISTINCT patient IDs after joining Patient and Laboratory where SEX = 'M' and both CENTROMEA and SSB are '-' or '+-'.",
      "reason": "All required anchors are present: male filter (SEX='M'), normal level filters for CENTROMEA and SSB, and DISTINCT on patient IDs. Thus the query directly answers the question.",
      "verdict": true,
      "evidence": "Result set shows column COUNT(DISTINCT T1.ID) with value 0 (row 0), giving the requested count."
    },
    "refuter_details": {
      "judgement": "Predicted query follows the evidence-defined normal markers ('-','+-') and counts distinct male patients, matching the question; gold uses different marker values, so gold appears wrong.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": false
    }
  },
  {
    "question_id": 1505,
    "question": "Among the customers who paid in euro, how many of them have a monthly consumption of over 1000?",
    "evidence": "Pays in euro = Currency = 'EUR'.",
    "gold_sql": "SELECT COUNT(*) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' AND T1.Consumption > 1000.00",
    "predicted_sql": "SELECT COUNT(DISTINCT T1.`CustomerID`)\n  FROM customers AS T1\n  INNER JOIN yearmonth AS T2\n  ON T1.`CustomerID` = T2.`CustomerID`\n  WHERE T1.`Currency` = 'EUR'\n  AND T2.`Consumption` > 1000",
    "ex": 0,
    "score": 1.0,
    "prover_details": {
      "expected_answer": "A single integer: the number of customers whose currency is EUR and whose monthly consumption exceeds 1000.",
      "sql_description": "Joins customers with yearmonth, filters customers with currency='EUR' and at least one month where Consumption > 1000, counts distinct CustomerIDs.",
      "reason": "Satisfies both anchors—EUR customers and monthly consumption >1000—by counting distinct customers meeting those criteria. No conflicting constraints.",
      "verdict": true,
      "evidence": "Result set contains COUNT(DISTINCT T1.CustomerID)=391."
    },
    "refuter_details": {
      "judgement": "Prediction counts distinct euro-paying customers with any month >1000, matching question’s \"how many customers\" wording; gold over-counts monthly rows, so prediction is correct.",
      "verdict": false,
      "ambiguity": "na",
      "gold_correct": false
    }
  }
]