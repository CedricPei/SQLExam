[
  {
    "question_id": 1482,
    "result": {
      "expected_answer": "Identify, among segments SME, LAM, and KAM, (a) the one with the largest percentage increase and (b) the one with the smallest percentage increase in EUR consumption from 2012 to 2013.",
      "sql_description": "For each segment it sums 2012 and 2013 EUR consumption, computes (2013−2012)/2013*100 as PercentageIncrease, orders by that value descending, and returns only the top segment.",
      "reason": "The query supplies only the segment with the biggest percentage increase; it omits the segment with the lowest percentage increase, a required anchor explicitly asked for in the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1479,
    "result": {
      "expected_answer": "The specific year (4-digit) that has the highest total amount of gas consumption where the payment currency is CZK; only that top year is required.",
      "sql_description": "Filters rows to customers whose Currency is 'CZK', extracts the year from Date, sums Consumption per year, orders by the summed amount descending, and returns the single year with the maximum consumption.",
      "reason": "Query applies the required CZK currency filter, aggregates consumption by year, picks the highest total, returning the correct target attribute (year). No mandatory anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows Year column with value 2013 (row 0) and its TotalConsumption, matching the asked ‘Which year’."
    }
  },
  {
    "question_id": 1472,
    "result": {
      "expected_answer": "The customer(s) in the LAM segment whose total consumption in the whole year 2012 was the smallest.",
      "sql_description": "Finds all rows for LAM customers in 2012, orders them by the single-row Consumption value, and returns the CustomerID of the row with the smallest monthly consumption.",
      "reason": "Question asks for the least consumption per customer over 2012, which implies aggregating each customer’s 2012 consumption before comparison. The query compares individual month records instead, so a customer with one very low month but high total could be chosen. Required annual aggregation anchor is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1486,
    "result": {
      "expected_answer": "Determine whether the number of SME customers whose payment currency is CZK exceeds the number whose payment currency is EUR and, if it does, give the numeric difference (CZK SMEs minus EUR SMEs).",
      "sql_description": "Counts distinct customers paying in CZK, subtracts count of customers paying in EUR, ignoring customer segment; returns their difference.",
      "reason": "Query omits the required SME anchor (Segment='SME'), so counts all customers, not SMEs specifically.",
      "verdict": false
    }
  },
  {
    "question_id": 1501,
    "result": {
      "expected_answer": "A list of all unique countries in which gas stations recorded at least one transaction during June 2013.",
      "sql_description": "Gets distinct Country values from gasstations that match transactions whose date string’s first six characters are ‘201306’, i.e., June 2013.",
      "reason": "Query applies correct date filter for June 2013, joins gasstations to transactions_1k by GasStationID, and returns distinct country names—exactly what the question asks.",
      "verdict": true,
      "evidence": "sql_result shows column Country; no rows returned, meaning no qualifying transactions, but structure and logic are correct."
    }
  },
  {
    "question_id": 1498,
    "result": {
      "expected_answer": "A single numeric value: the maximum Consumption recorded for any 2012 month (i.e., the highest monthly consumption value in 2012).",
      "sql_description": "Filters rows whose Date starts with '2012', then returns the maximum Consumption among those rows.",
      "reason": "Assumes each row already represents one month’s consumption; under this reasonable interpretation, taking MAX over the 2012 rows yields the highest monthly consumption for that year, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows column HighestMonthlyConsumption with value 445279.69 (row 0)."
    }
  },
  {
    "question_id": 1476,
    "result": {
      "expected_answer": "A single numeric value: (total 2012 gas consumption of CZK-paying customers) minus (total 2012 gas consumption of EUR-paying customers).",
      "sql_description": "Builds two subqueries with 2012 consumption per customer for CZK and EUR, then left-joins them to every 2012 yearmonth row of the same customer and aggregates SUM(CZ.Consumption)-SUM(EU.Consumption). Because the joins are on CustomerID only, each consumption row is duplicated by the number of 2012 records for that customer, massively inflating both sums.",
      "reason": "The duplicate multiplication means the computed totals are not the actual sums for each currency, so the returned difference is incorrect even though the correct year and currencies are referenced.",
      "verdict": false
    }
  },
  {
    "question_id": 1481,
    "result": {
      "expected_answer": "Return three numbers: (1) SME annual-average consumption minus LAM annual-average consumption, (2) LAM minus KAM, and (3) KAM minus SME, where for each segment we first pick the customer(s) whose total 2013 consumption in CZK is the lowest and compute that customer’s annual average consumption (e.g., yearly total / 12).",
      "sql_description": "Step-1 finds, per segment, the minimum single MONTH consumption value in 2013 and returns an arbitrary customer id from that segment. Step-2 takes that single customer and averages his/her 2013 monthly values. Finally it reports the pairwise differences between those three averages.",
      "reason": "The query chooses the customer whose single MONTH record is minimal, not the customer(s) with the lowest TOTAL 2013 consumption. Because it groups only by Segment (not Customer) when taking MIN, the CustomerID picked may not even correspond to that minimum value. Thus the anchor 'customer(s) with the least amount of 2013 consumption' is not satisfied, so the produced differences answer a different question.",
      "verdict": false
    }
  },
  {
    "question_id": 1528,
    "result": {
      "expected_answer": "The proportion (in percent) of rows whose segment is 'premium' among all segment rows for country 'SVK' – i.e., premium rows / all rows in SVK.",
      "sql_description": "Joins customers to gasstations on CustomerID = GasStationID, keeps only joined rows where gas station country is 'SVK', then counts how many joined customer rows are premium and divides by total joined rows.",
      "reason": "The schema shows no relationship between customers and gasstations, so the join is unfounded and filters the set arbitrarily. The query measures the share of premium customers (after the spurious join), not the share of premium segments in gasstations. It therefore violates the required anchor (segment distribution in SVK) and can return wrong values.",
      "verdict": false
    }
  },
  {
    "question_id": 1505,
    "result": {
      "expected_answer": "A single count indicating how many customers whose currency is EUR have at least one monthly consumption record exceeding 1000.",
      "sql_description": "Joins customers with their monthly consumption records, filters to rows where the customer’s currency is 'EUR' and the consumption value is greater than 1000, then counts distinct CustomerID values.",
      "reason": "Meets all anchors: restricts to EUR-paying customers, enforces consumption > 1000 for a month, and returns the required count of unique customers. Logic aligns precisely with the question.",
      "verdict": true,
      "evidence": "COUNT(DISTINCT ym.CustomerID) = 391"
    }
  },
  {
    "question_id": 1484,
    "result": {
      "expected_answer": "A single number representing (number of discount gas stations in the Czech Republic) minus (number of discount gas stations in Slovakia).",
      "sql_description": "Counts distinct gas stations with Segment = 'discount' for CZE, counts the same for SVK, subtracts the second count from the first, and returns the difference as MoreDiscountStationsCZEThanSVK.",
      "reason": "All required anchors are present: Segment filtered to 'discount', countries correctly mapped to 'CZE' and 'SVK', and the query returns their count difference. This matches the question’s request.",
      "verdict": true,
      "evidence": "Result set has column MoreDiscountStationsCZEThanSVK with value 0 (row 0), providing the requested numeric difference."
    }
  },
  {
    "question_id": 1490,
    "result": {
      "expected_answer": "A single numeric value giving the percentage of customers in the LAM segment whose consumption exceeds 46.73.",
      "sql_description": "Counts distinct LAM customers with any record in yearmonth where Consumption > 46.73, divides by the total distinct LAM customers, multiplies by 100 and rounds to two decimals.",
      "reason": "All required anchors are covered: limits to LAM segment customers, applies the > 46.73 threshold, computes the percentage over the correct denominator of all LAM customers. Distinct is used so each customer is counted once. Therefore the SQL appropriately answers the question.",
      "verdict": true,
      "evidence": "Result set has one column Percentage with value 98.25 (row 0)."
    }
  },
  {
    "question_id": 1500,
    "result": {
      "expected_answer": "All distinct product descriptions that had at least one transaction in September 2013 (i.e., month 09 of year 2013).",
      "sql_description": "Finds transactions whose Date string starts with \"201309\" (September 2013), joins them to products, and returns the distinct product descriptions.",
      "reason": "Query filters the correct month (201309) as per provided evidence, uses join to get descriptions, applies DISTINCT so each product is listed once. All anchors (date month/year and product description) satisfied.",
      "verdict": true,
      "evidence": "Result set column: Description (no rows returned in sample execution, but logic matches requirements)."
    }
  },
  {
    "question_id": 1493,
    "result": {
      "expected_answer": "Percentage of customers in February 2012 whose consumption exceeded 528.3 (i.e., count of such customers divided by total customers for 201202, expressed as a percentage).",
      "sql_description": "Filters rows where Date='201202' and Consumption>528.3, counts distinct CustomerID for these (numerator). Joins to all February-2012 rows per customer and uses TOTAL(DISTINCT CustomerID) as denominator, then multiplies by 100 and rounds.",
      "reason": "Denominator must be the count of customers in Feb-2012, but TOTAL aggregates a SUM, not a COUNT; it adds the customer IDs instead of counting them, producing an incorrect percentage. Therefore required anchor ‘total number of customers in Feb-2012’ is mishandled and the query does not compute the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 1514,
    "result": {
      "expected_answer": "The currency (e.g., USD, EUR, CZK, etc.) used in the transaction(s) that occurred at 16:25:00 on 2012-08-24.",
      "sql_description": "Joins transactions_1k with customers, keeps rows where Date = '2012-08-24' and Time = '16:25:00', and returns the Currency column of the related customers.",
      "reason": "Query applies the exact date and time anchors and outputs the requested currency information; duplicates do not violate the question.",
      "verdict": true,
      "evidence": "sql_result shows Currency column with three identical rows: CZK (rows 0-2)."
    }
  },
  {
    "question_id": 1525,
    "result": {
      "expected_answer": "A single numeric percentage representing how many customers that made transactions on 2012-08-25 used the EUR currency, i.e. (distinct customers with EUR transactions that day) divided by (all distinct customers who had any transaction that day).",
      "sql_description": "Counts distinct EUR-currency customers that had a transaction on 2012-08-25 and divides by the total number of EUR-currency customers in the whole database, then multiplies by 100.",
      "reason": "Denominator should be customers active on 2012-08-25 irrespective of currency, but the query instead uses all EUR customers in the database. Thus the computed percentage does not match the requested metric.",
      "verdict": false
    }
  },
  {
    "question_id": 1506,
    "result": {
      "expected_answer": "All product descriptions for each transaction that occurred at gas stations whose Country value is 'CZE' (Czech Republic).",
      "sql_description": "Retrieves the Description field from products linked to transactions_1k and filters those transactions whose GasStationID belongs to gasstations with Country = 'CZE'.",
      "reason": "Matches the required join between transactions and gas stations, applies the Czech Republic anchor, and outputs the requested product descriptions. Question does not mandate distinctness, so duplicates are permissible.",
      "verdict": true,
      "evidence": "sql_result shows one column Description with multiple rows (e.g., 'Nafta', 'Natural', etc.), satisfying the requested output."
    }
  },
  {
    "question_id": 1529,
    "result": {
      "expected_answer": "Provide two amounts for customer 38508: 1) total spent at any gas stations across all time, 2) amount spent during January 2012 (Date starting with '201201').",
      "sql_description": "Calculates only the sum of Amount for customer 38508 where the transaction date is in January 2012, using a join to gasstations but ignoring all other months.",
      "reason": "Query omits the overall lifetime/total-spent figure that the question explicitly asks for; it answers only the January 2012 part.",
      "verdict": false
    }
  },
  {
    "question_id": 1322,
    "result": {
      "expected_answer": "A single integer: the number of events whose type is 'Meeting' and that were attended by more than 10 distinct members.",
      "sql_description": "First finds all events with attendance by more than 10 distinct members, then counts how many of those events have type = 'Meeting'.",
      "reason": "All required anchors are present: attendance threshold (>10 distinct members) and event type 'Meeting'. The query returns the count of such events, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT e.event_id)=4 (row 0)."
    }
  },
  {
    "question_id": 1531,
    "result": {
      "expected_answer": "Return the customer (by id) who has the highest total spend across all transactions, together with that customer’s average price per single item purchased (total price ÷ total amount) and the currency associated with the customer.",
      "sql_description": "Calculates each customer’s total spend (SUM(price)) and total quantity (SUM(amount)); divides these to get average price per item, orders customers by total spend descending, keeps the first (highest spender), then outputs that customer’s ID, computed average price, and their currency.",
      "reason": "Query includes all required anchors: sums price to find top spender, divides by amount for average price per item per evidence, limits to the highest spender, and retrieves currency from customers table. Logic aligns with the question.",
      "verdict": true,
      "evidence": "Row0: CustomerID=19182, AvgPricePerItem=24.277577, Currency=CZK"
    }
  },
  {
    "question_id": 1390,
    "result": {
      "expected_answer": "Percentage of total expenses that were spent on the event named \"Yearly Kickoff\" (i.e., 100 * cost of Yearly Kickoff / cost of all events).",
      "sql_description": "Joins expense → budget → event, sums expense.cost for all events, separately sums those where event_name = 'Yearly Kickoff', divides the two and multiplies by 100, rounding to two decimals.",
      "reason": "Query implements the specified formula, using all expenses linked to events and isolating those for 'Yearly Kickoff'; this matches the question’s requirement.",
      "verdict": true,
      "evidence": "Result set contains one column percentage_cost_for_yearly_kickoff with value 21.53 (row 0)."
    }
  },
  {
    "question_id": 1334,
    "result": {
      "expected_answer": "A list of each Student_Club member’s full name (first_name + space + last_name) whose recorded home state is Illinois.",
      "sql_description": "Joins member with zip_code on the zip field and returns the concatenated first and last names where the related zip_code.state equals 'Illinois'.",
      "reason": "Query applies the correct join, filters rows to Illinois, and outputs the required full name string, satisfying all anchors (member affiliation, Illinois state, full name).",
      "verdict": true,
      "evidence": "sql_result shows column full_name with 3 rows (e.g., 'Trent Smith', 'Tyler Hewitt', 'Annabella Warren'), consistent with requested output."
    }
  },
  {
    "question_id": 1533,
    "result": {
      "expected_answer": "For every customer who has made at least one purchase of product 5 at a unit price greater than 29.00, return that customer’s consumption value for August-2012 (date = '201208').",
      "sql_description": "Joins transactions_1k (t) with yearmonth (y) on CustomerID, keeps rows where t.ProductID = 5 and (t.Price / t.Amount) > 29, then selects y records where y.Date = '201208', outputting CustomerID, Date and Consumption. Duplicate rows may appear if a customer has several qualifying transactions, but all customers returned satisfy the condition.",
      "reason": "All required anchors are present: product id 5, unit price > 29 computed as Price/Amount per evidence, and consumption for 201208. The query retrieves exactly those customers and their August-2012 consumption; extra columns (CustomerID/Date) are acceptable and duplicates do not violate the question.",
      "verdict": true,
      "evidence": "sql_result shows columns CustomerID, Date, Consumption with 10 rows, all Date = '201208', confirming the query logic."
    }
  },
  {
    "question_id": 1381,
    "result": {
      "expected_answer": "A list of each student’s full name (first_name + last_name) for those whose attendance record shows they have participated in more than 7 events.",
      "sql_description": "Joins attendance with member, groups rows by member_id, counts the number of attendance rows per student, and outputs the concatenated first and last name for students whose count is greater than 7.",
      "reason": "Query uses attendance rows to count events per student (>7), returns full_name, and therefore satisfies both required anchors (full name, attendance >7).",
      "verdict": true,
      "evidence": "sql_result shows one column \"full_name\" with 20 names (e.g., Grant Gilmour, Luisa Guidi ...)."
    }
  },
  {
    "question_id": 1526,
    "result": {
      "expected_answer": "A single numeric value (possibly expressed as a percentage) representing (consumption in 2012 – consumption in 2013) divided by consumption in 2012 for the customer who spent 634.8 on 2012-08-25.",
      "sql_description": "Finds the customer whose transaction total on 2012-08-25 equals 634.8, then joins all of that customer’s 2012 rows in yearmonth with all of their 2013 rows and, for every 2012–2013 row pair, computes 100*(Consumption2012-Consumption2013)/Consumption2012.",
      "reason": "It never aggregates consumption over the whole year; instead it works on individual yearmonth rows and creates a Cartesian product of every 2012 month with every 2013 month, so the numerator and denominator are not the yearly totals required by the question. Therefore it does not compute the requested decrease rate. (The query also produced no rows.)",
      "verdict": false
    }
  },
  {
    "question_id": 1435,
    "result": {
      "expected_answer": "Names of events where type = 'Game', status = 'Closed', and event_date between 2019-03-15 and 2020-03-20 (inclusive).",
      "sql_description": "Selects event_name from the event table filtering for type 'Game', status 'Closed', and event_date within the specified date range.",
      "reason": "All required anchors (type, status, date range) are present and correctly applied; query returns only the matching event names, fulfilling the question.",
      "verdict": true,
      "evidence": "sql_result shows column event_name with 3 rows: ['Women\\'s Soccer', 'Football game', 'Football game']—all correspond to closed game events in the date range."
    }
  },
  {
    "question_id": 1362,
    "result": {
      "expected_answer": "The number of distinct cities located in Orange County within the state of Virginia.",
      "sql_description": "Counts the distinct values in the city column from the zip_code table where county equals 'Orange' and state equals 'Virginia'.",
      "reason": "Query applies both required anchors (county = Orange County, state = Virginia) and counts unique cities, matching the question. The potential naming variation ('Orange' vs 'Orange County') is reasonable ambiguity; using 'Orange' is a plausible match and not contradicted by schema.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT city) with value 0, giving the requested count."
    }
  },
  {
    "question_id": 1375,
    "result": {
      "expected_answer": "All full names of members whose major belongs to the \"School of Applied Sciences, Technology and Education\" department.",
      "sql_description": "Joins member with major on major_id, filters majors whose department equals \"School of Applied Sciences, Technology and Education\", returns concatenated first and last names.",
      "reason": "Query applies correct department filter and outputs requested full names; logic matches the question.",
      "verdict": true,
      "evidence": "sql_result shows column full_name with five rows (e.g., 'Angela Sanders', 'Dean O'Reilly'), consistent with expected member list."
    }
  },
  {
    "question_id": 1338,
    "result": {
      "expected_answer": "For every expense linked to the \"October Meeting\" event held on 2019-10-08, report whether it was approved (True/False). Listing each expense with its approval status or an overall yes/no is acceptable.",
      "sql_description": "Gets all expenses connected to the budget(s) of the event whose name is 'October Meeting' and date '2019-10-08', returning the event id, each expense id, and the approved flag.",
      "reason": "Query applies the exact event filters and returns each related expense together with its approved value, allowing us to determine if every expense was approved. No required anchor is missing.",
      "verdict": true,
      "evidence": "Result columns: event_id, expense_id, approved. (No rows in sample output, but structure matches requirements.)"
    }
  },
  {
    "question_id": 1155,
    "result": {
      "expected_answer": "For every patient whose LDH value is greater than 500 (above the normal range), return the patient’s ID together with their sex and birthday.",
      "sql_description": "Joins Patient and Laboratory tables on patient ID and selects the ID, SEX and Birthday where the laboratory LDH value exceeds 500; returns a row for each qualifying lab record (patients may appear multiple times).",
      "reason": "Query applies the correct LDH > 500 filter and outputs the required fields. Duplicate rows per patient are possible but not disallowed by the question; all anchors (LDH threshold, requested columns) are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows columns ID, SEX, Birthday with values (e.g., row0: 27654, F, 1936-03-25) confirming the query returns patients with high LDH."
    }
  },
  {
    "question_id": 1356,
    "result": {
      "expected_answer": "Name of the department associated with the club member whose position is President.",
      "sql_description": "Gets the major_name (not department) of the major linked to the member whose position is 'President'; returns first row.",
      "reason": "Query retrieves major_name while the question asks for the department field. Required anchor \"department\" is missing/incorrectly mapped.",
      "verdict": false
    }
  },
  {
    "question_id": 1387,
    "result": {
      "expected_answer": "Full name of the student who is responsible for (manages) the budget associated with the event named \"Yearly Kickoff\".",
      "sql_description": "Gets rows where event_name = 'Yearly Kickoff', filters budgets whose event_status = 'Managed', then joins member table by equating budget.budget_id with member.member_id, returning that member's full name.",
      "reason": "Schema shows no relationship between budget_id and member_id; equating them is unjustified. Hence query cannot correctly identify the student entrusted with the budget. Anchor linking student to budget is missing/mis-mapped.",
      "verdict": false
    }
  },
  {
    "question_id": 1411,
    "result": {
      "expected_answer": "A list (possibly distinct) of expense descriptions indicating the kinds of expenses made by the member named Sacha Harrison.",
      "sql_description": "Retrieves distinct values of expense_description from the expense table for rows linked to the member whose first_name = 'Sacha' and last_name = 'Harrison'.",
      "reason": "Query correctly joins expenses to the member table using member_id, filters by the specified first and last name, and returns the requested descriptions with duplicates removed. This satisfies the question’s requirement.",
      "verdict": true,
      "evidence": "sql_result shows one column expense_description (e.g., 'Post Cards, Posters', 'Posters', ..., 'Bakery - Donuts, muffins') indicating the kinds of expenses."
    }
  },
  {
    "question_id": 1150,
    "result": {
      "expected_answer": "Percentage (0-100%) of all female patients whose year of birth is after 1930, i.e., (count of female patients born after 1930) / (count of all female patients) * 100.",
      "sql_description": "Filters Patient table to female rows, counts how many of those have Birthday year > 1930, divides by total female count, multiplies by 100 and rounds to 2 decimals; returns that single percentage value.",
      "reason": "Query applies the female filter, correctly identifies births after 1930, computes ratio over all female patients; aligns with question requirements.",
      "verdict": true,
      "evidence": "Result set has one column Percentage_Female_After_1930 with value 94.04 (row 0), matching expected output format."
    }
  },
  {
    "question_id": 1464,
    "result": {
      "expected_answer": "List the full name (first_name + last_name) of each student who received funds on 9/9/2019 together with the amount they received.",
      "sql_description": "Joins income with member, builds full_name by concatenating first_name and last_name, filters rows where income.date_received = '9/9/2019', and outputs full_name and amount.",
      "reason": "Query correctly applies the date filter, retrieves full names and amounts via join; all required anchors (date_received filter, full name, amount) are present.",
      "verdict": true,
      "evidence": "Returned columns full_name, amount; no rows met criteria (empty result), but logic matches question."
    }
  },
  {
    "question_id": 1376,
    "result": {
      "expected_answer": "The name of the closed event whose spent-to-budget (spent / amount) ratio is the highest, optionally with that ratio value.",
      "sql_description": "Joins event with budget, keeps rows where the event status is 'Closed' and amount ≠ 0, computes spent/amount for each budget row, keeps the maximum ratio per event (MAX()), orders the events by this ratio descending and returns the top one (event name plus ratio).",
      "reason": "All required anchors are met: status='Closed', ratio defined as spent/amount, and highest ratio is chosen via ORDER BY DESC LIMIT 1. The per-event MAX implementation matches the evidence’s \"MAX(DIVIDE(spent, amount))\" guidance, so the SQL fulfils the question.",
      "verdict": true,
      "evidence": "sql_result row0: event_name='September Speaker', spend_to_budget_ratio≈1.154"
    }
  },
  {
    "question_id": 1166,
    "result": {
      "expected_answer": "Return the symptom description (non-NULL) and diagnosis for the youngest patient (latest Birthday) who has at least one medical examination.",
      "sql_description": "Joins Examination and Patient, sorts all their combined rows by Patient.Birthday descending, and takes the first row, returning that examination’s Symptoms and Diagnosis without ensuring the Symptoms column is non-NULL.",
      "reason": "Missing required anchor: it does not filter Symptoms IS NOT NULL, so it may (and in the shown result does) return NULL symptoms, failing to guarantee ‘symptoms observed’.",
      "verdict": false
    }
  },
  {
    "question_id": 1457,
    "result": {
      "expected_answer": "List every member whose every recorded expense cost exceeds the average cost of all expenses, returning their full name (first_name + last_name) and phone number.",
      "sql_description": "For each member, groups their expenses and selects those whose minimum expense cost is greater than the overall average cost, outputting concatenated first and last names as full_name and phone as contact_number.",
      "reason": "Query supplies correct columns (full name via first and last, phone), applies the intended filter MIN(cost) > AVG(cost) which guarantees every expense by that member is above the overall average, satisfying the ‘more than average on each expense’ condition.",
      "verdict": true,
      "evidence": "Result columns: full_name, contact_number; no rows met the condition, so empty set returned."
    }
  },
  {
    "question_id": 1427,
    "result": {
      "expected_answer": "All budget categories (budget.category) for events whose location is 'MU 215', whose type is 'Guest Speaker', and whose budget spent is 0.",
      "sql_description": "Joins budget with event on event ID, filters events where location = 'MU 215' and type = 'Guest Speaker' and where the budget record has spent = 0, then returns distinct category values.",
      "reason": "All required anchors (location MU 215, type Guest Speaker, spent = 0) are present. Query outputs the requested budget categories, meeting the question intent.",
      "verdict": true,
      "evidence": "sql_result shows column category with rows: Speaker Gifts, Food, Parking, Advertisement."
    }
  },
  {
    "question_id": 1171,
    "result": {
      "expected_answer": "A single integer: number of distinct patients whose age was under 18 years at the time of an examination whose Examination Date fell within the three-year window 1990-1993 (inclusive or exclusive of 1993; the key anchor is age < 18 at exam).",
      "sql_description": "Counts DISTINCT patient IDs for exams dated between 1990 and 1993 (inclusive) where the patient’s birth-year is ≤ exam-year−18, i.e. age is at least 18.",
      "reason": "The vital underage anchor is reversed. Birth_year ≤ exam_year−18 selects patients 18 years or older, not <18. Hence the query counts adults, not underage patients.",
      "verdict": false
    }
  },
  {
    "question_id": 1359,
    "result": {
      "expected_answer": "A multiplicative factor: (total Advertisement budget for the \"Yearly Kickoff\" event) divided by (total Advertisement budget for the \"October Meeting\" event). Example answer: 3.5 (meaning the Kickoff budget is 3.5-times the October budget).",
      "sql_description": "For each event_id it separately sums Advertisement amounts tagged as Yearly Kickoff and October Meeting, then counts how many event_ids have kickoff_budget > october_budget. Returns that count (1).",
      "reason": "The question asks for how many times larger the Kickoff budget is than the October budget (a ratio), not for a count of events where one budget exceeds the other. The query computes a count instead of the ratio, so it answers a different question.",
      "verdict": false
    }
  },
  {
    "question_id": 1389,
    "result": {
      "expected_answer": "The name of the event whose cost is the lowest among all events.",
      "sql_description": "Joins events with their budgets, orders by the numeric budget amount in ascending order, and returns the first event_name—i.e., the event with the smallest amount (interpreted as cost).",
      "reason": "Treating budget.amount as the event cost is a reasonable mapping; the query picks the event whose amount is minimal and outputs its name, satisfying the question’s requirement.",
      "verdict": true,
      "evidence": "sql_result shows one column (event_name) row0='January Speaker', matching the query’s intent."
    }
  },
  {
    "question_id": 1198,
    "result": {
      "expected_answer": "A single integer: the number of patients whose SEX is 'F' and whose diagnosis is 'APS'.",
      "sql_description": "Joins Patient and Examination, filters to records where the patient is female (SEX='F') and some examination lists Diagnosis='APS', then counts distinct patient IDs.",
      "reason": "All required anchors are present: female filter on Patient.SEX, APS diagnosis filter on Examination.Diagnosis, distinct patient count. This reasonably interprets where the diagnosis is stored and returns the requested total.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT p.ID) with value 2 (row 0)."
    }
  },
  {
    "question_id": 1399,
    "result": {
      "expected_answer": "A yes/no (true/false) indication of whether a member named Maya Mclean is recorded in attendance for the event named \"Women's Soccer\".",
      "sql_description": "Checks the attendance table joined with event and member to see if any row exists where the event_name is 'Women's Soccer' and the member's first and last names are 'Maya' and 'Mclean'; returns 1 (true) if such a row exists, otherwise 0 (false).",
      "reason": "Query applies all required anchors (event name and member full name) and correctly returns existence, matching the yes/no nature of the question.",
      "verdict": true,
      "evidence": "sql_result shows column attended with value 1, indicating Maya Mclean attended."
    }
  },
  {
    "question_id": 1152,
    "result": {
      "expected_answer": "Numeric ratio = (number of SLE patients with Admission='+') divided by (number of SLE patients with Admission='-'). No scaling factor.",
      "sql_description": "Counts SLE inpatients and divides by SLE outpatients, then multiplies the result by 100, returning a percentage-style value.",
      "reason": "The query adds a *100 multiplier, converting the ratio into a percentage, so the value is off by a factor of 100 compared with the requested ratio.",
      "verdict": false
    }
  },
  {
    "question_id": 1404,
    "result": {
      "expected_answer": "For the event named 'October Meeting', list each expense type and the total (sum of cost) of the expenses that were approved.",
      "sql_description": "Finds all expenses linked (through their budget) to the 'October Meeting' event, keeps only those with approved='Yes', groups them by the budget category (interpreted as expense type), and returns the category together with the sum of their costs.",
      "reason": "Query applies the required event filter, the approved-only condition, sums the cost, and reports it per expense type (category). These satisfy all explicit anchors.",
      "verdict": true,
      "evidence": "Result columns: category, total_value; no rows returned, but structure matches requested answer."
    }
  },
  {
    "question_id": 1220,
    "result": {
      "expected_answer": "List every patient (ID, sex, birthday) who has at least one laboratory record with urea nitrogen value of 29, i.e., exactly at the borderline of passing.",
      "sql_description": "Joins Patient with Laboratory on patient ID and selects the ID, SEX, and Birthday for those records where Laboratory.UN = 29.",
      "reason": "Query applies the required UN = 29 anchor and returns the requested columns. Extra duplicates do not violate the question, which only asks to provide the information, not necessarily distinct rows.",
      "verdict": true,
      "evidence": "sql_result columns: ID, SEX, Birthday with multiple rows (some duplicates) satisfying UN = 29."
    }
  },
  {
    "question_id": 1410,
    "result": {
      "expected_answer": "The member's full name (first + last) whose id is rec4BLdZHS2Blfp4v and the total amount of expenses (sum of cost) that this member incurred.",
      "sql_description": "Joins member with expense on member_id, filters to member id 'rec4BLdZHS2Blfp4v', concatenates first and last name as full_name, sums cost, returns one row grouped by the name.",
      "reason": "Covers the required member id, returns the requested full name and aggregated total cost. No missing or extraneous constraints.",
      "verdict": true,
      "evidence": "Row0: full_name='Sacha Harrison', total_cost=866.25"
    }
  },
  {
    "question_id": 1185,
    "result": {
      "expected_answer": "The numeric rate of decrease in total cholesterol for the 1959-02-18 patient, calculated as (November 1981 total − December 1981 total) divided by the December 1981 total (i.e., relative to December).",
      "sql_description": "Computes 100 * (sum Nov T-CHO − sum Dec T-CHO) / sum Nov T-CHO for the patient born 1959-02-18.",
      "reason": "Formula denominator should be December total per evidence, but query divides by November total, yielding a different rate.",
      "verdict": false
    }
  },
  {
    "question_id": 1460,
    "result": {
      "expected_answer": "Return the first and last name combined for the member whose expense description is exactly 'Water, Veggie tray, supplies', along with the cost of that expense.",
      "sql_description": "Joins member and expense on member_id, selects full name (first + last) and cost for rows where expense_description equals 'Water, Veggie tray, supplies'.",
      "reason": "All required anchors (expense_description filter, full name, cost) are present; query correctly retrieves the targeted member and amount.",
      "verdict": true,
      "evidence": "Result has columns full_name, cost; row0: ('Elijah Allen', 28.15)"
    }
  },
  {
    "question_id": 1243,
    "result": {
      "expected_answer": "A single numeric percentage representing what proportion of abnormal PT test results (PT ≥ 14) among patients older than 55 come from female patients.",
      "sql_description": "Joins Patient and Laboratory tables, keeps records where patient age (current year minus birth year) is greater than 55, counts lab rows with PT ≥ 14 that belong to females and divides by the total number of lab rows with PT ≥ 14 in that age group, then multiplies by 100 and rounds to two decimals.",
      "reason": "Query includes required anchors: age >55, PT ≥14, female indicator and correct percentage formula (female abnormal rows / all abnormal rows). Using row-level counting is a reasonable interpretation consistent with provided evidence. Therefore it answers the question.",
      "verdict": true,
      "evidence": "Percentage_Female_Abnormal_PT = 78.36"
    }
  },
  {
    "question_id": 1149,
    "result": {
      "expected_answer": "Identify whether male in-patients (Admission '+') or male out-patients (Admission '-') are more numerous and give the deviation as a percentage between the two counts (e.g., 100 * inpatients / outpatients or vice-versa).",
      "sql_description": "Counts male patients per Admission value, then returns two percentages: InPatientRatio = 100 * (male in-patients)/(male out-patients) and OutPatientRatio = 100 * (male out-patients)/(male in-patients).",
      "reason": "Query correctly restricts to male patients, separates in-patients and out-patients, and computes the relative percentages needed to determine which group is larger and by how much. Returning both directional ratios still answers the comparison question.",
      "verdict": true,
      "evidence": "Result columns: InPatientRatio ≈ 83.18, OutPatientRatio ≈ 120.22 (row 0) show male out-patients are more numerous and exceed male in-patients by ~20%."
    }
  },
  {
    "question_id": 1168,
    "result": {
      "expected_answer": "Return two values: 1) the date on which the laboratory test was done for the oldest patient whose Diagnosis is 'SJS'; 2) that patient’s age (in years) at their first hospital visit (First Date − Birthday).",
      "sql_description": "For every patient with Diagnosis = 'SJS', it inner-joins to Examination and Laboratory, takes the earliest laboratory date (MIN(L.Date)) and the year difference between First Date and Birthday, then keeps one record per patient, orders the patients by Birthday ascending and returns the first row (oldest according to the birthday ordering).",
      "reason": "The query adds an INNER JOIN to Examination, a condition not required by the question. If the oldest SJS patient lacks an Examination record, this join will exclude that patient, leading to a potentially incorrect result. Therefore it imposes an unjustified constraint and may fail to select the true oldest SJS patient.",
      "verdict": false
    }
  },
  {
    "question_id": 1235,
    "result": {
      "expected_answer": "For every patient whose red blood cell count is below 3.5, list the patient ID, the patient’s age (current year minus birth year), and the patient’s diagnosis.",
      "sql_description": "Selects distinct patient IDs and their calculated age from Examination joined with Patient and Laboratory, filtering rows where Laboratory.RBC < 3.5. It does not retrieve any diagnosis column.",
      "reason": "The query omits the required diagnosis field, an explicit anchor requested in the question (“patient's diagnosis”). Therefore it does not fully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1252,
    "result": {
      "expected_answer": "A single number: the count of patients whose IgG value is in the normal range (900 < IGG < 2000) and for whom the Symptoms field is not NULL.",
      "sql_description": "Joins Examination and Laboratory on patient ID, filters rows where IGG is between 900 and 2000 and Symptoms is not NULL, then counts distinct patient IDs.",
      "reason": "All required anchors—normal IgG range and non-NULL symptoms—are correctly applied, and DISTINCT ensures each patient is counted once even if multiple lab records exist.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT Examination.ID) = 1, giving the requested patient count."
    }
  },
  {
    "question_id": 1265,
    "result": {
      "expected_answer": "Number of distinct patients who were admitted to the hospital (Admission = '+') and whose anti-ribonuclear protein (RNP) test shows a normal value ('-' or '+-').",
      "sql_description": "Counts distinct patient IDs from Patient joined with Laboratory where Patient.Admission is '+' and Laboratory.RNP is either '-' or '+-'.",
      "reason": "Query applies required anchors: Admission '+', RNP in ('-','+-'), and counts DISTINCT patients. Matches question semantics (at least one normal RNP record).",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT p.ID) with value 0, indicating no such patients, which is a valid answer."
    }
  },
  {
    "question_id": 1255,
    "result": {
      "expected_answer": "Return the disease name (Diagnosis) that appears most frequently among patients whose IgM value is abnormal (≤40 or ≥400).",
      "sql_description": "Joins Examination and Laboratory on patient ID, keeps rows where Lab.Igm ≤40 or ≥400, groups by Diagnosis, counts the rows, orders by count descending and returns the top 1 diagnosis.",
      "reason": "Query applies the correct abnormal-IgM threshold, aggregates by diagnosis and selects the most frequent one. Minor ambiguity about counting rows vs distinct patients is acceptable because the question does not explicitly require DISTINCT and the grouping still reflects frequency among qualifying records.",
      "verdict": true,
      "evidence": "sql_result shows single row: Diagnosis='SLE', Count=1 (columns: Diagnosis, Count)."
    }
  },
  {
    "question_id": 1225,
    "result": {
      "expected_answer": "For each sex (M/F), produce a list (concatenated patient IDs) of all patients who have any laboratory record with total bilirubin (T-BIL) ≥ 2.0 (i.e., outside the normal range).",
      "sql_description": "Joins Patient with Laboratory, filters rows where T-BIL ≥ 2.0, groups by patient sex, and concatenates distinct patient IDs per sex.",
      "reason": "All required anchors are present: uses T-BIL ≥ 2.0 to detect abnormal values, selects patient IDs, groups by SEX, and lists IDs with DISTINCT to avoid duplicates. Thus it answers the question.",
      "verdict": true,
      "evidence": "Result columns: SEX (rows 0-1: 'F', 'M') and Patient_IDs (comma-separated IDs), matching expected grouping and listing."
    }
  },
  {
    "question_id": 1205,
    "result": {
      "expected_answer": "Return a single yes/no indicating whether patient 57266’s uric-acid value(s) satisfy the defined normal-range rule (UA>8.0 for males, UA>6.5 for females).",
      "sql_description": "Joins patient 57266 with all of the patient’s laboratory rows and, for each row, outputs “Yes” if that UA value exceeds the threshold for the patient’s sex, otherwise “No”. It produces one yes/no per lab date rather than an overall answer.",
      "reason": "The query emits multiple rows, with both ‘Yes’ and ‘No’, leaving the overall status of the patient unresolved. The question expects a single determination, not conflicting per-test outputs.",
      "verdict": false
    }
  },
  {
    "question_id": 1175,
    "result": {
      "expected_answer": "Return two values: 1) the patient’s age at the examination whose hemoglobin value is the overall highest in the data (age computed as difference between the year of that examination date and the patient’s birth year), and 2) the doctor’s diagnosis for that same examination/patient.",
      "sql_description": "Finds the laboratory row whose HGB equals the overall maximum, joins it to any Examination rows and the Patient row with the same patient ID, then reports (year(Examination Date) – year(Birthday)) as Age together with Examination.Diagnosis, returning one arbitrary row (LIMIT 1).",
      "reason": "It selects the correct patient by MAX(HGB) anchor, and computes age using the examination date as requested. However it does not ensure that the examination used is the one at which the maximum-HGB was measured (no join on dates), so age and diagnosis may come from an unrelated examination of the same patient. Thus the required anchor \"at the time of the examination\" is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1187,
    "result": {
      "expected_answer": "A count of patients examined between 1987-07-06 and 1996-01-31 whose GPT > 30 and ALB < 4, together with the list of those patients’ IDs.",
      "sql_description": "Gets distinct patient IDs from Examination whose examination date is between 1987-07-06 and 1996-01-31 and, for the same ID and date in Laboratory, have GPT > 30 and ALB < 4; orders the resulting IDs.",
      "reason": "All explicit anchors (date range, GPT > 30, ALB < 4, patient IDs) are satisfied. The query outputs the requested ID list; the count can be derived from the number of returned rows, fulfilling the ‘how many’ part. Therefore it adequately answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column ID with 0 rows, indicating currently no such patients."
    }
  },
  {
    "question_id": 1241,
    "result": {
      "expected_answer": "Return the count of patients whose platelet (PLT) level is below 100, and indicate how this number compares to the count of patients whose PLT level is above 400 (e.g., by also returning the high-PLT count or a statement/difference that allows comparison).",
      "sql_description": "Computes COUNT(DISTINCT ID) for PLT<100 and subtracts COUNT(DISTINCT ID) for PLT>400, outputting only that difference as \"Difference\".",
      "reason": "The query omits the requested low-PLT patient count; it only provides the difference, so the reader cannot see the stated number of patients with lower than normal range.",
      "verdict": false
    }
  },
  {
    "question_id": 1232,
    "result": {
      "expected_answer": "List the patient IDs, their sex, and their age (current year minus birth year) for every patient who has at least one laboratory record with GLU ≥ 180 (high blood glucose) and T-CHO < 250 (normal total cholesterol).",
      "sql_description": "Joins Patient with Laboratory, filters rows where GLU is 180 or higher and T-CHO is below 250, computes age from the year parts of today and Birthday, and returns ID, SEX, Age for each matching lab row.",
      "reason": "All required anchors are present: GLU≥180, T-CHO<250, output columns ID/SEX/age. Age is computed as year difference which matches the given age formula. Duplication of patients across multiple lab dates does not violate the question.",
      "verdict": true,
      "evidence": "sql_result shows columns ID, SEX, Age with several rows (e.g., row0 ID=57266 SEX=M Age=102) matching the specified conditions."
    }
  },
  {
    "question_id": 1201,
    "result": {
      "expected_answer": "Percentage (0–100) of patients whose birthday year is 1980 and who have a diagnosis of RA that are women (SEX = 'F'); each patient should be counted once.",
      "sql_description": "Counts all Examination rows where the linked patient was born in 1980 and the examination diagnosis is 'RA', then divides the number of those rows belonging to female patients by the total number of such rows to give a percentage.",
      "reason": "Uses Examination rows as the counting unit, so patients with multiple RA examinations are over-represented. The question explicitly asks for percentage of patients, requiring DISTINCT patients; this anchor is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1153,
    "result": {
      "expected_answer": "Return the disease diagnosis recorded for patient 30609 together with every laboratory-test date for that same patient (one row per lab date).",
      "sql_description": "Selects Diagnosis from Examination and Date from Laboratory, inner-joining on patient ID, and filters where ID = 30609, yielding each lab date alongside the patient’s diagnosis.",
      "reason": "Query applies the required patient anchor, retrieves the requested diagnosis field and all lab dates; no superfluous or missing constraints.",
      "verdict": true,
      "evidence": "Result columns: Diagnosis, Date (0 rows in provided execution but structure matches request)."
    }
  },
  {
    "question_id": 1275,
    "result": {
      "expected_answer": "The number of distinct male patients whose laboratory records show a normal anti-centromere result ('-' or '+-') AND a normal anti-SSB result ('-' or '+-').",
      "sql_description": "Counts DISTINCT patient IDs from Patient joined to Laboratory where SEX='M' and the same lab record has CENTROMEA and SSB within ('-', '+-').",
      "reason": "Meets all explicit anchors: filters males, enforces both antibodies are in the normal set, uses DISTINCT to avoid double-counting patients. Slight ambiguity about needing the two normals possibly on different dates, but requiring them in the same row is a reasonable interpretation and not contradicted; therefore acceptable.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT p.ID) with value 0; this is a valid count answer."
    }
  },
  {
    "question_id": 1256,
    "result": {
      "expected_answer": "The total number of patients whose CRP result is '+' (abnormal) and whose Patient.Description field is NULL (data not recorded).",
      "sql_description": "Joins Patient and Laboratory on patient ID, filters laboratory rows where CRP='+' and patient rows where Description IS NULL, then counts DISTINCT patient IDs.",
      "reason": "All required anchors—abnormal CRP and missing Description—are present, duplicates are removed via DISTINCT, so the query yields the desired count.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT p.ID) column with value 25, indicating 25 such patients."
    }
  },
  {
    "question_id": 1029,
    "result": {
      "expected_answer": "For each of the 4 teams that possess the greatest Build-Up Play Speed in the dataset, report their buildUpPlaySpeed value (optionally with the team name). Each team should appear once, and the speed used should be the team’s maximum buildUpPlaySpeed score.",
      "sql_description": "Selects every Team_Attributes row, joins to Team, orders all rows by buildUpPlaySpeed descending, and returns the first 4 rows’ team_long_name and buildUpPlaySpeed without deduplicating teams or taking a per-team maximum.",
      "reason": "The query ranks individual attribute snapshots, not teams: a single team can occupy multiple top rows, and the speed may come from any snapshot rather than each team’s maximum. Thus it does not reliably return the top 4 teams as required.",
      "verdict": false
    }
  },
  {
    "question_id": 1251,
    "result": {
      "expected_answer": "The number of distinct patients whose IGG value is 2000 or higher (i.e., above the normal upper limit).",
      "sql_description": "Counts distinct patient IDs in the Laboratory table where IGG >= 2000.",
      "reason": "Query applies the correct threshold (>=2000) and uses COUNT(DISTINCT ID) as required to avoid duplicate patient rows, matching the question intent.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT L.ID) with value 136 indicating the computed patient count."
    }
  },
  {
    "question_id": 1209,
    "result": {
      "expected_answer": "List of disease diagnoses for patients whose ALT (GPT) lab value exceeds 60, ordered from the oldest patient (earliest Birthday) to the youngest.",
      "sql_description": "Joins Patient with Laboratory, keeps rows where GPT > 60, returns the patient’s Diagnosis (plus Birthday) and orders the rows by Birthday ascending.",
      "reason": "Query applies correct GPT > 60 filter, selects the required diagnosis field, orders by Birthday ascending, and any extra Birthday column is acceptable for ordering; duplicates per patient do not violate the request.",
      "verdict": true,
      "evidence": "sql_result shows Diagnosis and Birthday columns; birthdays ascend from 1922-12-01 to 1930-02-15, all rows meet GPT>60 filter (implicit from query)."
    }
  },
  {
    "question_id": 1302,
    "result": {
      "expected_answer": "A single integer: the number of patients whose creatinine phosphokinase (CPK) value is below 250 and who have at least one positive coagulation test result (KCT='+' or RVVT='+' or LAC='+' ).",
      "sql_description": "Counts distinct patient IDs that have CPK < 250 in Laboratory and have KCT='+' OR RVVT='+' OR LAC='+' in Examination, by joining the two tables on patient ID.",
      "reason": "Query applies the required CPK < 250 filter and checks any of the three coagulation markers for '+', then counts unique patients, matching the question’s criteria.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT e.ID) = 1, providing the requested integer."
    }
  },
  {
    "question_id": 1247,
    "result": {
      "expected_answer": "The number of distinct male patients (SEX='M') whose white blood cell count is within the normal range (WBC > 3.5 AND WBC < 9.0) and who have an abnormal fibrinogen level (FG <= 150 OR FG >= 450).",
      "sql_description": "Counts distinct patient IDs by joining Patient with Laboratory, filtering for male sex, WBC in the normal range, and FG outside the normal range in the same lab record.",
      "reason": "Query applies correct sex, WBC, and FG thresholds and uses COUNT(DISTINCT) to avoid duplicates, matching the question’s requirements. Using the same lab row for both values is a reasonable interpretation of simultaneous measurements.",
      "verdict": true,
      "evidence": "sql_result has column COUNT(DISTINCT p.ID) with value 6, indicating six qualifying male patients."
    }
  },
  {
    "question_id": 1078,
    "result": {
      "expected_answer": "The name of the older between Aaron Lennon and Abdelaziz Barrada (the one with the earlier birthday).",
      "sql_description": "Finds the minimum birthday between the two specified players, then returns ALL players in the whole table whose birthday equals that date.",
      "reason": "Outer query is not limited to the two players, so it returns extra names unrelated to the question. Required player-name anchor is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1032,
    "result": {
      "expected_answer": "League name that has hosted the most matches in the entire dataset, together with the number of matches played in that league.",
      "sql_description": "Counts matches for each league by joining Match with League, orders the counts descending, and returns the single league with the highest count (name and count).",
      "reason": "Query correctly aggregates matches per league, selects the max via ORDER BY DESC LIMIT 1, and returns required fields. All anchors (league, highest number of matches) satisfied.",
      "verdict": true,
      "evidence": "sql_result shows columns league_name and match_count; first row Spain LIGA BBVA with 3040 matches, matching query goal."
    }
  },
  {
    "question_id": 1037,
    "result": {
      "expected_answer": "A numeric percentage: 100 * (number of distinct players born 1987-1992 whose preferred_foot = 'left') / (total distinct players born 1987-1992).",
      "sql_description": "Filters players with birthdays between 1987 and 1992, counts DISTINCT players for the denominator, but counts every Player_Attributes row with preferred_foot = 'left' for the numerator, then returns percentage rounded to two decimals.",
      "reason": "Numerator should count distinct players, not Attribute rows. Because each player has multiple attribute records, the query over-counts left-foot instances, giving percentages >100% (e.g., 449.75). Required anchor ‘players’ is mis-handled, so result is incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1267,
    "result": {
      "expected_answer": "The number of patients whose anti-SM result is normal ('-' or '+-') and who have no thrombosis (Thrombosis = 0).",
      "sql_description": "Counts distinct patient IDs that appear in both Examination and Laboratory where Laboratory.SM is in ('-', '+-') and Examination.Thrombosis equals 0.",
      "reason": "All anchors are satisfied: normal anti-SM filter, no thrombosis filter, counting unique patients. Join duplication is handled with DISTINCT. Therefore query answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one column COUNT(DISTINCT e.ID) with value 0 indicating no such patients; column label matches expected count."
    }
  },
  {
    "question_id": 1169,
    "result": {
      "expected_answer": "A single numeric value representing male-to-female prevalence among patients whose uric-acid values are abnormal – i.e. (number of male patients with UA ≤ 8.0) divided by (number of female patients with UA ≤ 6.5).",
      "sql_description": "Counts rows where UA ≤ 8.0 and sex='M' and rows where UA ≤ 6.5 and sex='F' in the Laboratory table (joined to Patient for the sex column) and returns 100 × (male count) ÷ (female count).",
      "reason": "All required anchors are present: sex filter, abnormal-UA thresholds per sex, and the requested ratio (male divided by female). The multiplication by 100 merely expresses the ratio as a percentage of female count, which is a reasonable interpretation of “ratio”; therefore the query still answers the question. Schema suggests one laboratory row per patient, so row counts equal patient counts.",
      "verdict": true,
      "evidence": "sql_result shows one column Male_to_Female_Ratio with value ≈20.57, supplying the requested ratio."
    }
  },
  {
    "question_id": 1270,
    "result": {
      "expected_answer": "Number of distinct patients whose anti-scl70 result is normal (SC170 = 'negative' or '0'), who are female (SEX='F') and have no recorded symptoms (Symptoms is NULL).",
      "sql_description": "Counts DISTINCT Patient.ID after joining Laboratory to filter SC170 in ('negative','0'), selecting only female patients, left-joining Examination and requiring Symptoms IS NULL.",
      "reason": "All required anchors (normal anti-scl70, female, no symptoms, distinct patients) are explicitly included. The LEFT JOIN with Symptoms IS NULL correctly treats patients with no Examination rows as symptom-free, a reasonable interpretation. Therefore the query returns the desired count.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT p.ID) column with value 19."
    }
  },
  {
    "question_id": 1068,
    "result": {
      "expected_answer": "A single numeric value: the average overall_rating for all Player_Attributes records dated from 2010 through 2015 (inclusive) where the corresponding Player has height > 170.",
      "sql_description": "Joins Player_Attributes with Player, keeps rows whose player height is greater than 170 and whose attribute date year is between 2010 and 2015, then returns AVG(overall_rating).",
      "reason": "All explicit constraints—date window (2010-2015 inclusive), height >170, and computation of average overall_rating—are present. Averaging over attribute rows is a reasonable interpretation per evidence.",
      "verdict": true,
      "evidence": "sql_result shows one column average_rating with value 68.901357 (row 0), matching the required single numeric answer."
    }
  },
  {
    "question_id": 1135,
    "result": {
      "expected_answer": "IDs of the four right-footed players with the very lowest potential scores (i.e., the smallest potential values among all right-footed records).",
      "sql_description": "Takes all right-footed records, groups by player_api_id, keeps every group whose MIN(potential) is non-zero (almost all), orders the groups by an arbitrary P.potential value rather than the group’s MIN(potential), and returns the first four IDs.",
      "reason": "The query does not enforce the ‘lowest potential’ anchor: HAVING MIN(potential) is just a truthy check and ORDER BY uses a non-aggregated column, so the returned players are not guaranteed to have the minimum potential. Therefore it may return wrong IDs.",
      "verdict": false
    }
  },
  {
    "question_id": 1238,
    "result": {
      "expected_answer": "Return the ID and sex of the SLE-diagnosed patient whose birthday is earliest (oldest) among those whose hemoglobin (HGB) values fall within the normal range 10<HGB<17.",
      "sql_description": "Joins Patient, Examination, and Laboratory; keeps rows where Examination.Diagnosis='SLE' and HGB between 10 and 17; orders by Patient.Birthday ascending (earliest = oldest) and returns the first patient's ID and SEX.",
      "reason": "All required anchors are present: SLE diagnosis, normal hemoglobin (10<HGB<17), oldest determined via earliest birthday, and outputs ID and SEX. Duplicate lab rows per patient do not alter the winner because ordering is on patient birthday; LIMIT 1 suffices.",
      "verdict": true,
      "evidence": "sql_result rows: (ID, SEX) -> (48473, F)"
    }
  },
  {
    "question_id": 1148,
    "result": {
      "expected_answer": "A single numeric percentage: (number of DISTINCT players whose height < 180 cm AND strength > 70) divided by (total DISTINCT players) * 100.",
      "sql_description": "Joins Player with Player_Attributes. Denominator counts DISTINCT players. Numerator sums one per *row* where the same height/strength condition holds, so a player with multiple qualifying attribute records is counted multiple times.",
      "reason": "Question requires counting unique players, but numerator counts attribute rows, potentially counting the same player multiple times. This violates the player-level anchor, so the computed percentage is incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1092,
    "result": {
      "expected_answer": "Name of the league that recorded the greatest number of matches in the 2008/2009 season.",
      "sql_description": "Counts matches for each league where season = '2008/2009', orders leagues by that count descending, and returns the first league name.",
      "reason": "The query applies the required season filter, aggregates matches per league, selects the league with the highest count, and outputs its name, matching the question intent.",
      "verdict": true,
      "evidence": "Result column: name -> row0: Spain LIGA BBVA"
    }
  },
  {
    "question_id": 1048,
    "result": {
      "expected_answer": "The overall rating value (single number) for footballer Gabriel Tamas during the year 2011.",
      "sql_description": "Joins Player_Attributes with Player, filters rows for player_name = 'Gabriel Tamas' whose date year is 2011, then returns the average of overall_rating as average_rating.",
      "reason": "Query satisfies player and year anchors and produces a single overall rating figure; averaging multiple 2011 records is a reasonable interpretation of an overall rating for that year.",
      "verdict": true,
      "evidence": "sql_result shows column average_rating with value 75.0 (row 0)."
    }
  },
  {
    "question_id": 1195,
    "result": {
      "expected_answer": "A single numeric value: the average ALB (blood albumin) among female patients whose platelet count (PLT) exceeds 400 and who are diagnosed with SLE.",
      "sql_description": "Joins Laboratory, Examination and Patient on patient ID; filters to rows where Patient.SEX = 'F', Laboratory.PLT > 400 and Examination.Diagnosis = 'SLE'; returns AVG(Laboratory.ALB).",
      "reason": "Query applies all required anchors (female, PLT > 400, SLE diagnosis) and computes the requested average of ALB. Using Examination.Diagnosis is a reasonable interpretation given diagnosis appears in multiple tables. Potential row duplication does not violate the question’s intent, so the query is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows column Average_ALB with value 4.3, matching the expected single-number answer."
    }
  },
  {
    "question_id": 1058,
    "result": {
      "expected_answer": "The name of the player whose average finishing rating is higher when comparing the tallest player(s) with the shortest player(s).",
      "sql_description": "1) Finds global minimum and maximum heights from Player. 2) Computes the average finishing score for every player across all Player_Attributes rows. 3) Keeps only those players whose height equals the min or max height. 4) Returns the player name with the greatest average finishing among that subset (ties broken by LIMIT 1).",
      "reason": "All required anchors are present: tallest (MAX(height)), shortest (MIN(height)), average finishing per player, and picking the higher average between them. Ties in height are reasonably handled by still choosing the highest finisher among the tied extremes, which satisfies the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows player_name column with value 'Juan Quero', indicating the query returned a single player name as required."
    }
  },
  {
    "question_id": 1254,
    "result": {
      "expected_answer": "The total count of distinct patients whose IgA value is greater than 80 and less than 500 AND whose first hospital visit occurred on or after 1990-01-01.",
      "sql_description": "Joins Patient and Laboratory on ID, filters lab rows where IGA > 80 and < 500, keeps patients whose First Date year is 1990 or later, then counts distinct patient IDs.",
      "reason": "All explicit anchors are satisfied: normal IgA range, hospital visit date (interpreted as any date in 1990 or later), and distinct patient counting. No extraneous constraints are added.",
      "verdict": true,
      "evidence": "COUNT(DISTINCT p.ID) => 140"
    }
  },
  {
    "question_id": 879,
    "result": {
      "expected_answer": "Nationality of the driver who recorded the overall maximum fastestLapSpeed in the results table.",
      "sql_description": "Finds the result row with the highest fastestLapSpeed (CAST to REAL for numeric order), joins to drivers, and returns that driver’s nationality (single row, highest speed).",
      "reason": "Query correctly targets MAX fastestLapSpeed without extra constraints and retrieves the associated driver’s nationality. Required anchor (maximum fastestLapSpeed) is satisfied through ORDER BY DESC LIMIT 1. Output type matches question.",
      "verdict": true,
      "evidence": "sql_result shows one row: nationality = 'Brazilian' (column: nationality, row 0)."
    }
  },
  {
    "question_id": 1080,
    "result": {
      "expected_answer": "A single integer: the number of players whose preferred foot is left and whose attacking work rate is low (i.e., they stay in position when the team attacks).",
      "sql_description": "Selects rows in Player_Attributes where preferred_foot = 'left' and attacking_work_rate = 'low', counts distinct player_api_id to avoid multiple season records, returning that count.",
      "reason": "Query applies both required filters and counts unique players, matching the question precisely.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(DISTINCT p.player_api_id) = 189"
    }
  },
  {
    "question_id": 1115,
    "result": {
      "expected_answer": "Percentage value: ((Landon Donovan overall_rating − Jordan Bowery overall_rating) / Landon Donovan overall_rating) * 100 for ratings recorded on 2013-07-12.",
      "sql_description": "Finds each player’s maximum overall_rating on or before 2013-07-12, then computes 100 * (Landon − Jordan) / Jordan.",
      "reason": "1) Uses Jordan’s rating in the denominator instead of Landon’s, contradicting the percentage definition.\n2) Takes the maximum rating up to and including the date rather than the rating on the date, and allows earlier dates (<=), violating the exact date anchor.\nHence the query does not implement the required calculation.",
      "verdict": false
    }
  },
  {
    "question_id": 1242,
    "result": {
      "expected_answer": "List the patients (at least their ID, optionally other fields) whose laboratory exam was performed in 1984, whose current age is under 50 years, and whose platelet count in that 1984 exam was in the normal range 100–400.",
      "sql_description": "Selects rows from Laboratory whose Date year = 1984 and platelet count between 100 and 400, joins to Patient, keeps those whose current age (computed as strftime('%Y','now') minus birth year) is under 50, and returns each matching row’s patient ID, birthday and platelet value.",
      "reason": "Query applies the 1984 exam year filter, enforces platelet normal-range constraint, and checks age<50 using the provided current-age formula from evidence. Resulting rows correspond to patients satisfying all stated conditions; duplicates per patient do not violate the request.",
      "verdict": true,
      "evidence": "sql_result shows Patient.ID (values 102490, 460574, 1086485), Birthday, PLT all 100–400; each row’s Laboratory exam year is 1984 and patients are <50 by current-year minus birth-year calculation."
    }
  },
  {
    "question_id": 1133,
    "result": {
      "expected_answer": "Number of players whose name starts with 'Aaron' and who were born after 1990-12-31 (i.e., birthday > 1990-12-31).",
      "sql_description": "Counts distinct player IDs in Player where player_name starts with 'Aaron' and birthday is later than 1990-12-31; returns that count.",
      "reason": "Query applies both required anchors (name LIKE 'Aaron%' and birthday > 1990-12-31) and returns a count, matching the question and provided evidence.",
      "verdict": true,
      "evidence": "sql_result shows column player_count = 6 (row 0)."
    }
  },
  {
    "question_id": 1136,
    "result": {
      "expected_answer": "The number of distinct players whose crossing value equals the global maximum crossing value and whose preferred_foot is \"left\".",
      "sql_description": "Finds the maximum crossing value in Player_Attributes, then counts distinct player_api_id rows whose crossing equals that max and whose preferred_foot is 'left'.",
      "reason": "Query applies required anchors: preferred_foot='left' and crossing=MAX(crossing). Uses DISTINCT to avoid multiple records per player, matching the request for how many players. Logic aligns with the question.",
      "verdict": true,
      "evidence": "Result set has one column COUNT(DISTINCT pa.player_api_id) with value 2 (row 0)."
    }
  },
  {
    "question_id": 1141,
    "result": {
      "expected_answer": "The speed class (Slow, Balanced, or Fast) associated with KSV Cercle Brugge’s build-up play speed.",
      "sql_description": "Joins Team with Team_Attributes, filters rows where team_long_name is 'KSV Cercle Brugge', sorts the attributes by most recent date, and returns the latest buildUpPlaySpeedClass.",
      "reason": "Question asks for the team’s speed class; query correctly targets buildUpPlaySpeedClass for KSV Cercle Brugge and sensibly selects the most recent record. Returned value meets requirement.",
      "verdict": true,
      "evidence": "buildUpPlaySpeedClass → Balanced (row 0)"
    }
  },
  {
    "question_id": 1107,
    "result": {
      "expected_answer": "The earliest date on which Kevin Constant achieved his highest recorded crossing score.",
      "sql_description": "Determines Kevin Constant’s maximum crossing value, selects his Player_Attributes rows matching that value, and returns the minimum (earliest) date among them as first_highest_crossing_date.",
      "reason": "Query applies correct player filter, finds MAX(crossing), and returns MIN(date) for those rows, matching the question’s requirement for the first time he reached his highest crossing score.",
      "verdict": true,
      "evidence": "first_highest_crossing_date: 2013-02-15 00:00:00 (row 0)"
    }
  },
  {
    "question_id": 897,
    "result": {
      "expected_answer": "Full name of the driver who has the highest total number of wins, together with his nationality and the maximum points he ever scored in a single driverStandings record.",
      "sql_description": "Computes total wins per driver (SUM(ds.wins)), orders drivers by that total descending, keeps the top driver, and returns his full name, nationality, and the maximum points he scored in any race/season (MAX(ds.points)).",
      "reason": "All required anchors are present: total wins used to identify the top-winning driver; nationality and max points are returned. The produced result therefore answers the question.",
      "verdict": true,
      "evidence": "Row0: fullName=Michael Schumacher, nationality=German, maxPoints=148.0"
    }
  },
  {
    "question_id": 846,
    "result": {
      "expected_answer": "The driverRef names of the 5 slowest drivers in Q1 (highest q1 times) for raceId 20, i.e., the five drivers eliminated after the first qualifying period.",
      "sql_description": "Returns driverRefs in race 20 whose q1 time equals the MIN(q1) (fastest time) across all drivers in that race, limiting to 5 rows.",
      "reason": "Eliminated drivers are those with the worst (largest) q1 times, but the query selects drivers with the best (smallest) q1 time by using MIN(q1). Therefore it targets the wrong set of drivers and does not satisfy the elimination anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1028,
    "result": {
      "expected_answer": "The name of the team that had the highest number of away victories (away_team_goal > home_team_goal) in Scotland Premier League matches during the 2009/2010 season.",
      "sql_description": "Filters matches to Scotland Premier League and season '2009/2010', keeps only rows where the away team won, groups by away team, orders by the count of such wins descending, and returns the long name of the top team (LIMIT 1).",
      "reason": "Query applies all required anchors: correct league, correct season, defines away win correctly, counts wins per away team, and selects the team with the maximum count. Result set therefore answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column team_long_name = 'Celtic', matching the expected single-team answer."
    }
  },
  {
    "question_id": 865,
    "result": {
      "expected_answer": "Driver(s) with the earliest date of birth among those who have a non-NULL finish time (i.e., completed) in raceId 592.",
      "sql_description": "Finds all results for race 592 where time is not NULL, joins to drivers, orders by dob ascending (oldest first), and returns the first row (driverId, forename, surname, dob).",
      "reason": "Correctly filters on raceId 592 and finished drivers (time IS NOT NULL), identifies the oldest by ordering dob ascending, and returns that driver. Limiting to 1 is acceptable since the question asks for ‘who’ (singular) and tie handling is unspecified.",
      "verdict": true,
      "evidence": "Returned row: driverId=306, forename='Jean-Pierre', surname='Beltoise', dob='1937-04-26'."
    }
  },
  {
    "question_id": 868,
    "result": {
      "expected_answer": "The latitude and longitude of the circuit where the Malaysian Grand Prix is held.",
      "sql_description": "Joins races with circuits then selects the lat and lng of circuits whose associated race name is 'Malaysian Grand Prix'.",
      "reason": "Query anchors on races.name = 'Malaysian Grand Prix' and returns the requested coordinate columns from circuits. Duplicates do not violate the question; all returned rows give the same coordinates, which satisfy the requirement.",
      "verdict": true,
      "evidence": "lat, lng columns show 2.76083, 101.738 in all rows (e.g., row 0)."
    }
  },
  {
    "question_id": 1146,
    "result": {
      "expected_answer": "Full name (team_long_name) of the team that, in a single away appearance, achieved the highest value of away_team_goal, i.e. the team involved in the match where away_team_goal reached its overall maximum.",
      "sql_description": "Finds each team’s total (SUM) away goals over all matches, orders teams by that total, and returns the long name of the team with the greatest total.",
      "reason": "Question (and evidence) anchors on the single-match maximum of away_team_goal (MAX), not the cumulative total. Predicted SQL uses SUM, giving a different criterion; thus it may pick a different team and violates the anchor requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 866,
    "result": {
      "expected_answer": "The driver (player) who recorded a lap time of 1:27 in race 161 and his introduction website – i.e., at least the driver’s name (forename/surname) together with the url.",
      "sql_description": "Finds rows in lapTimes where raceId = 161 and time starts with '1:27', joins to drivers table, and returns only the driver’s url (duplicates not removed).",
      "reason": "Core anchors (race 161, lap time 1:27) are respected, but the query outputs only the url. The question also asks \"Who was the player\", requiring the driver’s identity (e.g., name). That element is missing, so the answer is incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 1145,
    "result": {
      "expected_answer": "List of the four leagues with the highest number of matches during the 2015/2016 season, ideally including their game counts.",
      "sql_description": "Counts matches per league where season = '2015/2016', orders by that count descending, and returns the top 4 leagues with their match totals.",
      "reason": "Includes the required season filter, groups by league, orders by game count, and limits to four results, directly answering which four leagues had the most games.",
      "verdict": true,
      "evidence": "league_name, total_games -> (0) England Premier League 380; (1) France Ligue 1 380; (2) Italy Serie A 380; (3) Spain LIGA BBVA 380"
    }
  },
  {
    "question_id": 884,
    "result": {
      "expected_answer": "All race names where the race date falls in the same year AND month as the very earliest race date in the table.",
      "sql_description": "Finds the single minimum date from races, then returns the names of races whose date equals that exact minimum date.",
      "reason": "The query restricts to races on the single earliest DAY, not to all races in the month of that earliest date. It therefore omits races that share the earliest year-month but occur on later days within that month, violating the stated requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 881,
    "result": {
      "expected_answer": "The percentage of drivers in the 16 July 1983 race who finished (i.e., whose time value is present) divided by all drivers who started that race.",
      "sql_description": "Counts all result rows from the race dated 1983-07-16, counts those with a non-NULL time, divides the two counts and multiplies by 100, returning the rounded completion rate.",
      "reason": "Query applies correct date filter, uses time IS NOT NULL to detect finishers, divides by total participants, and outputs the completion percentage; aligns with the stated calculation.",
      "verdict": true,
      "evidence": "Returned one row with column completion_rate = 17.24, matching the requested metric."
    }
  },
  {
    "question_id": 857,
    "result": {
      "expected_answer": "Latitude and longitude of the circuit where the Abu Dhabi Grand Prix is held.",
      "sql_description": "Joins races to circuits and returns the lat and lng of the circuit for all race records whose name is 'Abu Dhabi Grand Prix'.",
      "reason": "Query uses the race name anchor, joins to circuits, and outputs the requested coordinate columns. Duplicate rows do not violate the question.",
      "verdict": true,
      "evidence": "lat,lng row0 = (24.4672, 54.6031) — same for all 9 rows"
    }
  },
  {
    "question_id": 898,
    "result": {
      "expected_answer": "Return the age (computed as current year minus birth year) of the youngest driver whose nationality is Japanese, together with THAT driver’s full name.",
      "sql_description": "Among all Japanese drivers, computes the minimum age but independently chooses the lexicographically smallest full name, because both are aggregated with MIN(). The ORDER BY and LIMIT are ineffective with aggregates.",
      "reason": "Age and name must belong to the same youngest driver. The query correctly derives the minimum age but does not ensure the returned name is the one of that youngest driver, so the association can be wrong (and the sample result is clearly not the youngest Japanese driver). Missing anchor linking name to youngest age.",
      "verdict": false
    }
  },
  {
    "question_id": 902,
    "result": {
      "expected_answer": "Names of all races in which driver Alex Yoong finished with a position (track number) less than 20.",
      "sql_description": "Finds rows in results where driver forename='Alex' and surname='Yoong' and position<20, joins to races, and returns the race names.",
      "reason": "Includes required driver anchor and uses position<20 to capture the track-number condition; returns the set of corresponding race names, matching the question.",
      "verdict": true,
      "evidence": "sql_result shows 5 race_name rows: Brazilian Grand Prix, Canadian Grand Prix, French Grand Prix, Italian Grand Prix, Japanese Grand Prix."
    }
  },
  {
    "question_id": 1094,
    "result": {
      "expected_answer": "A single number: the percentage by which Ariel Borysiuk’s overall rating exceeds Paulin Puel’s, i.e. (Ariel – Paulin) / Paulin * 100.",
      "sql_description": "Joins Player once (alias p) filtered to Ariel Borysiuk, then joins Player_Attributes twice on the SAME player_api_id (that of Ariel) while requiring the second Player_Attributes row to belong to Paulin Puel. Because Paulin Puel has a different player_api_id, the second join fails and the query returns no rows.",
      "reason": "Missing anchor: Paulin Puel’s rating is not actually retrieved—the join ties both attribute tables to Ariel’s id, producing an empty result set. Therefore the query does not compute the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 901,
    "result": {
      "expected_answer": "List each Formula 1 race held in September 2005, showing: 1) the race name, 2) the circuit name, and 3) the circuit location.",
      "sql_description": "Joins races with circuits and filters rows where r.date is in year 2005 and month 09, returning race name, circuit name, and circuit location.",
      "reason": "All required anchors (year 2005, month September) are correctly applied, and the selected columns match the requested information (race, circuit name, location). Returned rows align with known September 2005 events, so the query satisfies the question.",
      "verdict": true,
      "evidence": "Rows: [0] Italian Grand Prix | Autodromo Nazionale di Monza | Monza, [1] Belgian Grand Prix | Circuit de Spa-Francorchamps | Spa, [2] Brazilian Grand Prix | Autódromo José Carlos Pace | São Paulo"
    }
  },
  {
    "question_id": 1113,
    "result": {
      "expected_answer": "The defence aggression class (text value) for team \"Hannover 96\" on 2015-09-10.",
      "sql_description": "Joins Team with Team_Attributes, filters where team_long_name = 'Hannover 96' and date starts with '2015-09-10', returns the defenceAggressionClass column.",
      "reason": "Both required anchors—team name and exact date—are correctly applied, and the selected column matches the asked metric.",
      "verdict": true,
      "evidence": "sql_result shows column defenceAggressionClass with value \"Press\" in row 0."
    }
  },
  {
    "question_id": 894,
    "result": {
      "expected_answer": "The overall fastest lap time (minimum milliseconds) ever recorded, along with the driver’s full name and the race in which that lap occurred.",
      "sql_description": "For every driver-race pair it computes the minimum lap time, then orders these minima ascending and picks the top one; returns that lap time (best_lap_time) plus the corresponding driver and race names.",
      "reason": "By ordering the per-driver-race minima and limiting to one, the query retrieves the absolute minimal lap time and the driver and race where it was set, satisfying all requested anchors (best lap time, driver, race). Ties are handled acceptably by LIMIT 1 since the question does not specify tie handling.",
      "verdict": true,
      "evidence": "Row0: best_lap_time=67411, driver_name=\"Lewis Hamilton\", race_name=\"Austrian Grand Prix\""
    }
  },
  {
    "question_id": 937,
    "result": {
      "expected_answer": "The finish time (results.time value) of the driver who finished 2nd in the 2008 Chinese Grand Prix.",
      "sql_description": "Gets results.time from results joined with races where races.year = 2008, races.name = 'Chinese Grand Prix', and the driver’s positionOrder is 2 (second place).",
      "reason": "All required anchors are present: race name Chinese Grand Prix, year 2008, and second-place driver. The query returns that driver’s finish time, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result shows time column with value '+14.925' for the matching row."
    }
  },
  {
    "question_id": 944,
    "result": {
      "expected_answer": "A single percentage value showing how much faster the 2008 Australian GP winner was than the slowest driver who still finished the race; mathematically (last_finish_time − champion_time) ÷ last_finish_time × 100.",
      "sql_description": "Joins winner (positionOrder = 1) with the row having the largest positionOrder in the same race, then computes (last − champion) ÷ champion × 100.",
      "reason": "Uses champion time in the denominator so expresses the gap as a percentage of the champion’s time, not of the last finisher’s time required by the question. It also fails to ensure the ‘last’ driver actually finished (time/milliseconds not NULL) and returns no row in execution. Required anchor ‘divide by last driver time’ is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 930,
    "result": {
      "expected_answer": "Return the race (at least its name, optionally year) where Lewis Hamilton achieved his best – i.e., lowest – value in the results.rank column (fastest-lap rank).",
      "sql_description": "Selects Lewis Hamilton’s race results, orders them by positionOrder (finishing position) ascending and returns the first race name & year, here Monaco Grand Prix 2008.",
      "reason": "Required anchor is the minimal results.rank value, but the query minimises results.positionOrder instead. Therefore it evaluates a different criterion and may yield a different race.",
      "verdict": false
    }
  },
  {
    "question_id": 928,
    "result": {
      "expected_answer": "Reference name (drivers.driverRef) of the driver who finished 1st in the 2007 Canadian Grand Prix.",
      "sql_description": "Joins drivers, results, and races tables; filters to Canadian Grand Prix in 2007 and the result row where positionOrder = 1; returns the driverRef.",
      "reason": "All required anchors (race name, year 2007, first place) are explicitly applied, and query returns the requested driver reference name, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result shows driverRef column with value 'hamilton' in row 0."
    }
  },
  {
    "question_id": 955,
    "result": {
      "expected_answer": "For every race year earlier than 1975, return the average finishing time of the race winner converted to seconds.",
      "sql_description": "Joins races with results, keeps rows where year < 1975, winner (positionOrder = 1) and non-null time, converts the HH:MM:SS.mmm string in results.time to seconds, then averages those seconds per year and returns year with that average.",
      "reason": "All required anchors are present: champion identified by positionOrder = 1, years filtered with year < 1975, conversion of the winner’s time to seconds, aggregation averaged per year. Output columns match the question. The computation method is consistent with the stated HH:MM:SS.mmm format, so the query adequately answers the question.",
      "verdict": true,
      "evidence": "sql_result shows columns [year, average_seconds] with rows for years 1950-1969, matching the requested format."
    }
  },
  {
    "question_id": 978,
    "result": {
      "expected_answer": "Return the total number of circuits located in Austria and list each Austrian circuit’s location together with its latitude and longitude.",
      "sql_description": "Filters circuits where country = 'Austria'; computes COUNT(*) over those rows but, without GROUP BY, also selects a single arbitrary location, lat, lng.",
      "reason": "The query gives the correct overall count (3) but only provides one circuit’s location/coordinates. Question asks for the locations and coordinates of all Austrian circuits, so required anchor (complete list) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1134,
    "result": {
      "expected_answer": "A single numeric value representing the (signed or absolute) difference between the jumping attribute of the player whose player_api_id = 6 and that of the player whose player_api_id = 23.",
      "sql_description": "For every row of Player_Attributes for player 6 and every row for player 23, computes ABS(jumping6 - jumping23); returns one row per pair (Cartesian product).",
      "reason": "The question implies one difference figure. The SQL produces a cross-join of all seasonal records, yielding many (or potentially zero) rows rather than a single aggregated value, and it lacks any selection of a specific date or aggregation (e.g., latest, average). Required anchor of a single coherent difference is not met; execution even returns no rows.",
      "verdict": false
    }
  },
  {
    "question_id": 962,
    "result": {
      "expected_answer": "A numeric percentage: among all drivers who participated in races from 2000-2005, what share were (a) born before 1985 AND (b) recorded at least one lap whose number was greater than 50.",
      "sql_description": "Builds 3 driver sets: RelevantDrivers = drivers born before 1985; RelevantLaps = drivers that had any lap >50 in 2000-2005; Before1985AndOver50 = intersection of both conditions.  It then divides the size of Before1985AndOver50 by the size of RelevantLaps (both DISTINCT driverId) to yield a percentage.",
      "reason": "Denominator is restricted to drivers who had lap>50, whereas the question’s reasonable reading (and supplied evidence) uses ALL drivers participating 2000-2005.  Missing this anchor inflates the percentage and does not answer the asked ratio.",
      "verdict": false
    }
  },
  {
    "question_id": 1002,
    "result": {
      "expected_answer": "Full name (forename + surname) of the youngest driver in the dataset, together with that driver’s nationality and the name of the very first race he/she entered.",
      "sql_description": "Finds the driver whose date of birth equals the maximum dob (youngest), joins to results and races, orders those races by race date ascending, and returns the driver name, nationality, and the earliest race name (LIMIT 1).",
      "reason": "All required anchors are satisfied: youngest driver via MAX(dob); earliest race participated via ORDER BY race.date ASC LIMIT 1; returns full name and nationality. Logic matches question intent.",
      "verdict": true,
      "evidence": "sql_result columns: FullName, nationality, RaceName – single row (0) with values ('Lance Stroll', 'Canadian', 'Chinese Grand Prix')."
    }
  },
  {
    "question_id": 906,
    "result": {
      "expected_answer": "Name of the race where Lewis Hamilton made his debut (earliest race he participated in) and the number of points he scored in that debut race.",
      "sql_description": "Finds all races driven by Lewis Hamilton, groups each race, tags them with MIN(year) (always 2007 for him), orders only by year, and returns the first row (race name, 2007, points).",
      "reason": "Query restricts by year only; among the 2007 races it arbitrarily picks whichever appears first, not the actual first event of the season. Result shows ‘Malaysian Grand Prix’ (round 2) instead of the debut ‘Australian Grand Prix’ (round 1), so the returned race and points are incorrect. Missing anchor: earliest race event within the first year.",
      "verdict": false
    }
  },
  {
    "question_id": 981,
    "result": {
      "expected_answer": "Identify the youngest driver in the database (largest dob). Report the year when that driver had his first qualifying race (earliest race date in qualifying for that driver) along with the driver’s full name and the date and time of that race.",
      "sql_description": "Computes each driver’s first qualifying race date, then picks the driver with the most recent dob (youngest). Returns that driver’s first-qualifying race year, driver name, race date and time, limiting to one row.",
      "reason": "Query matches the needed logic: youngest driver determined via dob DESC, first qualifying race via MIN(races.date), and required fields (year, name, date, time) are selected. Joining races by date rather than raceId is acceptable because it still points to the same race date and does not violate any explicit anchor. Result therefore answers the question.",
      "verdict": true,
      "evidence": "sql_result shows columns (year, DriverName, date, time) with one row: (2017, 'Lance Stroll', 2017-04-09, 06:00:00)."
    }
  },
  {
    "question_id": 950,
    "result": {
      "expected_answer": "Names of all constructors that scored 0 points in race 291.",
      "sql_description": "Joins constructorResults with constructors, filters rows to raceId = 291 and points = 0, then returns the constructors' names.",
      "reason": "Query applies both required anchors—race 291 and zero points—and outputs the corresponding constructor names. This exactly matches the question intent.",
      "verdict": true,
      "evidence": "sql_result shows the column \"name\" with 11 rows (e.g., Minardi, Dallara, Larrousse …), consistent with a list of constructors scoring 0 points."
    }
  },
  {
    "question_id": 963,
    "result": {
      "expected_answer": "Number of distinct French drivers who recorded any lap time under 2 minutes (i.e., <120 seconds).",
      "sql_description": "Counts distinct driverId values in lapTimes whose milliseconds <120000 and whose nationality in drivers table is 'French'.",
      "reason": "Query applies nationality filter, applies correct time threshold (<120000 ms) and counts unique drivers, matching the question precisely.",
      "verdict": true,
      "evidence": "SQL result shows COUNT(DISTINCT l.driverId) = 9 (row 0)."
    }
  },
  {
    "question_id": 1144,
    "result": {
      "expected_answer": "The finishing rate and curve score of the heaviest player (i.e., the player whose weight equals the maximum weight in the Player table) – one pair of values for that player (or one per tied player if weights tie).",
      "sql_description": "Finds players whose weight equals the overall MAX(weight) in Player, joins to all of their Player_Attributes rows, and returns the finishing and curve columns for every such attributes record.",
      "reason": "While it applies the correct heaviest-weight anchor, it returns every historical attribute row for those players, producing many duplicate and differing value pairs. The question asks for the finishing and curve of the (singular) heaviest player, so the extra rows constitute an over-inclusive answer.",
      "verdict": false
    }
  },
  {
    "question_id": 728,
    "result": {
      "expected_answer": "A list of eye colors among Marvel Comics superheroes, each with the number of Marvel superheroes having that eye color, ordered from the most to the least common.",
      "sql_description": "Counts superheroes whose publisher is 'Marvel Comics' for each eye colour and returns colour and count, ordering by the count descending (popularity) and alphabetically for ties.",
      "reason": "The query filters to Marvel Comics only, groups by eye colour, counts superheroes, and sorts descending by count as requested. All anchors (publisher filter, eye colour grouping, descending popularity order) are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows columns EyeColor and PopularityCount (e.g., Blue 126, Brown 89, ...), sorted by count descending."
    }
  },
  {
    "question_id": 854,
    "result": {
      "expected_answer": "Latitude and longitude coordinates of any circuit(s) that hosted the race named \"Australian Grand Prix\".",
      "sql_description": "Joins races with circuits and outputs the lat and lng of circuits whose associated race name equals 'Australian Grand Prix'.",
      "reason": "Query applies the required race-name anchor and returns the requested coordinate fields; duplicates do not alter correctness.",
      "verdict": true,
      "evidence": "sql_result shows columns lat, lng with values (-34.9272, 138.617) for all rows, indicating the coordinates of the relevant circuit."
    }
  },
  {
    "question_id": 954,
    "result": {
      "expected_answer": "Percentage of Japanese driver race participations (rows in results) between 2007 and 2009 that have a non-NULL time value, i.e. completed the race.",
      "sql_description": "Counts DISTINCT driverId values with non-NULL time as numerator and DISTINCT driverId values overall as denominator, yielding the share of Japanese drivers who ever finished at least one race in 2007-2009.",
      "reason": "Uses DISTINCT, so measures drivers not participations. Violates anchor that numerator and denominator must count every DriverID row (each race start). Therefore computes a different statistic than asked.",
      "verdict": false
    }
  },
  {
    "question_id": 861,
    "result": {
      "expected_answer": "The car/driver number of the driver whose Q3 lap time was 1:54 (one minute, fifty-four seconds) in qualifying for race 903.",
      "sql_description": "Looks in qualifying for raceId 903 and selects the driver number from drivers where q3 begins with the text \"0:01:54\".",
      "reason": "Filter anchor is wrong: the question’s time is the minute-second string \"1:54\" (format M:SS…), whereas the query requires the extra leading \"0:\" (\"0:01:54…\"). This makes the selection condition mismatched and can exclude the correct record; returned set is therefore unreliable.",
      "verdict": false
    }
  },
  {
    "question_id": 988,
    "result": {
      "expected_answer": "Full names of the three German drivers born in 1980-1985 (inclusive) who have the smallest average pit-stop duration, ordered from shortest to longer average.",
      "sql_description": "Finds German drivers born between 1980 and 1985, computes each driver’s average pit-stop duration in milliseconds, orders these averages ascending, and returns the first three full names.",
      "reason": "Query applies all required filters (nationality, birth-year window), correctly computes average duration, orders by this metric, and limits to 3, yielding the requested drivers.",
      "verdict": true,
      "evidence": "sql_result rows: (0) fullName=Timo Glock, (1) Adrian Sutil, (2) Nico Rosberg."
    }
  },
  {
    "question_id": 877,
    "result": {
      "expected_answer": "The identity (e.g., forename, surname, DOB) of the youngest driver among those who finished race 872.",
      "sql_description": "Joins drivers with results, keeps rows where raceId = 872 and finish time is not null (driver finished), orders by DOB descending (latest birthdate = youngest) and returns the top record.",
      "reason": "All anchors satisfied: race 872, finished filter via time IS NOT NULL, selection of youngest through DOB DESC LIMIT 1. Output columns give the driver's name and birth date, fulfilling the question.",
      "verdict": true,
      "evidence": "sql_result shows single row: forename='Sergio', surname='Pérez', dob='1990-01-26'."
    }
  },
  {
    "question_id": 972,
    "result": {
      "expected_answer": "List every driver (driverId and code) whose date of birth is in 1971 and who appears in results with a non-NULL fastestLapTime.",
      "sql_description": "Builds a table of each driver’s best (minimum) fastestLapTime, then joins to drivers born in 1971, orders those by that time, and returns ONLY the first row (LIMIT 1).",
      "reason": "It correctly filters born-in-1971 drivers that have non-NULL fastestLapTime, but LIMIT 1 keeps just one driver. If several 1971-born drivers satisfy the condition the others are wrongly omitted, so the query can return an incomplete answer.",
      "verdict": false
    }
  },
  {
    "question_id": 743,
    "result": {
      "expected_answer": "Two numbers: (1) the percentage of all superheroes whose alignment is 'Bad' (self-interest / own moral code) among the whole superhero table, and (2) the count of those Bad superheroes whose publisher is Marvel Comics.",
      "sql_description": "Returns only the number of distinct superheroes that have alignment 'Bad' and are published by Marvel Comics.",
      "reason": "Does not compute or return the overall percentage of Bad superheroes; only supplies the Marvel count, so the answer is incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 758,
    "result": {
      "expected_answer": "Hair colour(s) of superhero(s) whose race is human and height is exactly 185 cm.",
      "sql_description": "Gets rows from superhero where height_cm = 185 and race name is 'human', then returns the associated hair colour from colour table.",
      "reason": "Query includes both required anchors (height 185, race human) and returns the requested attribute (hair colour). No missing or contradictory constraints.",
      "verdict": true,
      "evidence": "Returned column: colour (none in sample run, but structure correct)."
    }
  },
  {
    "question_id": 994,
    "result": {
      "expected_answer": "The constructor (team) that accumulated the highest total points across all Monaco Grand Prix races held from 1980 through 2010 inclusive, together with that total points figure and the team’s name and nationality.",
      "sql_description": "For every constructor, the query looks at Monaco-circuit races between 1980 and 2010, takes the single highest points value it ever scored in any one such race (MAX(c.points)), then orders these per-race maxima descending and returns the constructor with the largest single-race score along with that score, name and nationality.",
      "reason": "The task requires the constructor’s total points over the specified period, but the query uses MAX(points) instead of SUM(points), thus measuring only the best single-race score, not the cumulative total. This violates the core aggregation anchor and can change the winner and the score.",
      "verdict": false
    }
  },
  {
    "question_id": 896,
    "result": {
      "expected_answer": "Percentage of races from 2010 onward in which driver Lewis Hamilton did not finish in 1st place (position > 1).",
      "sql_description": "Finds all race results for Hamilton from 2010 onward, counts distinct races where his finishing position was greater than 1, divides by total distinct races for Hamilton in that span, and multiplies by 100 to get the percentage.",
      "reason": "Query applies surname = 'Hamilton', year >= 2010, uses position > 1 for the numerator, total races for the denominator, and returns the percentage, exactly matching the required calculation.",
      "verdict": true,
      "evidence": "sql_result shows column not_first_percentage with value ≈54.23 (row 0)."
    }
  },
  {
    "question_id": 892,
    "result": {
      "expected_answer": "Full name of the driver who achieved the highest single-race points (max value in results.points) and that points value.",
      "sql_description": "For each driver, take his maximum single-race points, then order these maxima descending and return the full name (forename + surname) and the points for the top driver (LIMIT 1).",
      "reason": "Evidence defines \"most points scored\" as MAX(points); query follows that definition, joins drivers to results, computes each driver's per-race max, picks the highest one and outputs name and points. Required anchors (max points, full name) are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows row 0: full_name='Lewis Hamilton', points=50.0"
    }
  },
  {
    "question_id": 1011,
    "result": {
      "expected_answer": "Full names (forename + surname) of the 20 drivers who have recorded the 20 shortest lap-times ever in Formula-1 races (one row per driver, ordered from quickest upward).",
      "sql_description": "Finds all lap records, orders them by the textual time value ascending and returns the full name of the first 20 rows, without removing duplicates or using the numeric milliseconds column.",
      "reason": "1) Returns 20 lap records, not 20 distinct drivers – duplicates appear so fewer than 20 unique drivers are supplied.\n2) Orders by the TEXT time column, which may mis-sort values like ‘1:01.000’ vs ‘0:59.000’; milliseconds column should be used.\nThus the list may miss some qualifying drivers and ordering/selection may be wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 989,
    "result": {
      "expected_answer": "Name of the winning driver of the 2008 Canadian Grand Prix and his race finish time in h:mm:ss.s format.",
      "sql_description": "Finds the result row with position 1 for races in 2008 whose circuit is in Canada, then returns the driver's full name and the recorded time.",
      "reason": "Filters correct year (2008), correct location (Canada, uniquely matching the Canadian GP), and winner position=1. Returns exactly driver name and finish time; aligns with question requirements.",
      "verdict": true,
      "evidence": "champion column row0=Robert Kubica; finish_time row0=1:36:24.227"
    }
  },
  {
    "question_id": 766,
    "result": {
      "expected_answer": "The full name of the superhero whose strength attribute value is the highest among all heroes.",
      "sql_description": "Joins superhero with hero_attribute and attribute, keeps rows where attribute_name = 'strength', orders those rows by attribute_value descending, and returns the first full_name (highest strength).",
      "reason": "All required anchors are present (filter on strength, selection of full_name, highest value via ORDER BY … DESC LIMIT 1). Ordering with LIMIT 1 is an acceptable way to get the maximum; thus the query satisfies the question.",
      "verdict": true,
      "evidence": "Query returns column full_name; execution produced 0 rows in test data but logic matches requirements."
    }
  },
  {
    "question_id": 801,
    "result": {
      "expected_answer": "A single numeric value: the count of male superheroes divided by the count of female superheroes (male/female, i.e., SUM(gender_id = 1) / SUM(gender_id = 2) per evidence).",
      "sql_description": "Counts superheroes with gender_id = 2 and divides by the count with gender_id = 1, returning gender_id 2 over gender_id 1.",
      "reason": "Evidence explicitly anchors the ratio as male/female (gender_id = 1 over gender_id = 2). The SQL reverses this, computing female/male instead, violating the anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 769,
    "result": {
      "expected_answer": "The name of the superhero (superhero_name) with the highest durability attribute among those whose publisher is \"Dark Horse Comics\".",
      "sql_description": "Joins superheroes with their attributes and publisher, filters to records where attribute_name = 'durability' and publisher_name = 'Dark Horse Comics', orders by attribute_value descending, and returns the single top superhero_name.",
      "reason": "All required anchors are present: durability attribute, Dark Horse Comics publisher, selection of the maximum via ORDER BY DESC LIMIT 1. This directly answers which superhero has the most durability for that publisher.",
      "verdict": true,
      "evidence": "sql_result has column superhero_name (no rows), confirming the query structure is correct though dataset lacks a result."
    }
  },
  {
    "question_id": 1014,
    "result": {
      "expected_answer": "For each circuit located in Italy, return its lap record – i.e. the fastest single-lap time ever set there (use fastestLapTime or equivalent). Output should pair circuit name with that shortest lap time.",
      "sql_description": "Finds circuits whose country is Italy, looks at every result of races held there, and returns the minimum value of the column results.milliseconds (total race finishing time) per circuit.",
      "reason": "The query uses total race finishing time (milliseconds) instead of the fastest lap time. Lap record anchor (fastest single-lap time) is therefore not met, so the answer content is incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 791,
    "result": {
      "expected_answer": "The numeric average (mean) of the height_cm values for every superhero record in the table.",
      "sql_description": "Computes AVG(height_cm) over all rows in superhero, ignoring NULLs, and returns it as average_height.",
      "reason": "The query directly implements the requested aggregation (overall average height). No anchors are missing or contradicted.",
      "verdict": true,
      "evidence": "sql_result shows one row with column average_height = 267.751445."
    }
  },
  {
    "question_id": 598,
    "result": {
      "expected_answer": "A single numeric value: ( (count of Student badges in 2010 ÷ total Student badges) * 100 ) minus ( (count of Student badges in 2011 ÷ total Student badges) * 100 ). That percentage difference between the two years.",
      "sql_description": "Counts Student badges in 2010 and 2011, then computes 100 * (count2010 - count2011) / count2010, i.e., the relative change with 2010 as the denominator.",
      "reason": "The question/evidence defines percentage difference as the difference between each year’s share of the total badges. The query instead divides by the 2010 count, not by the overall total, so the denominator is wrong and the resulting percentage is off. Required anchor: division by total Student badges is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 798,
    "result": {
      "expected_answer": "The publisher name(s) that publish the superheroes Hawkman, Karate Kid, and Speedy.",
      "sql_description": "Joins superhero with publisher, filters for the three specified superhero names, and returns the distinct publisher_name values.",
      "reason": "All required anchors are present: the three superheroes are filtered explicitly and the query returns their publisher name(s). Mapping hero→publisher individually is not required by the wording; listing the distinct publisher(s) satisfies the question. Result supplies one publisher, consistent with the likely single shared publisher scenario.",
      "verdict": true,
      "evidence": "sql_result shows publisher_name column with single value 'DC Comics' (row 0)."
    }
  },
  {
    "question_id": 951,
    "result": {
      "expected_answer": "A single integer: the number of constructors whose nationality is Japanese and who recorded 0 points in exactly two races.",
      "sql_description": "For each Japanese constructor-result row with 0 points, it groups by constructorId, keeps only those with 2 zero-point races, and outputs COUNT(DISTINCT constructorId). Because the query is grouped by constructorId, the SELECT returns one row per qualifying constructor, each containing the value 1.",
      "reason": "Grouping by constructorId followed by COUNT(DISTINCT constructorId) yields a separate row with ‘1’ for every qualifying constructor, not a single total. Therefore if more than one constructor meets the criteria the query would return multiple rows of 1 instead of the correct aggregate count, failing to answer the ‘how many’ question.",
      "verdict": false
    }
  },
  {
    "question_id": 959,
    "result": {
      "expected_answer": "The lap number (integer) on which the 2009 season’s world-champion driver set his single fastest lap of that season.",
      "sql_description": "1) Picks one driver who has the highest points/wins in any 2009 driverStandings row (assumed champion).\n2) Collects ALL of that driver’s lapTimes for 2009.\n3) Orders those rows by the text field lt.time and keeps only the first row, then returns MIN(lap) over the (full) scan.",
      "reason": "Two critical problems:\n• Fastest-lap comparison is done on the string column time instead of the numeric milliseconds column, so ordering may not reflect true speed.\n• MIN(lap) is aggregated over the whole lapTimes set, not over the chosen fastest-lap row, meaning the query usually returns 1 (the smallest lap number present) regardless of which lap was actually fastest. Thus the answer it yields is not guaranteed to be the champion’s fastest-lap number.",
      "verdict": false
    }
  },
  {
    "question_id": 571,
    "result": {
      "expected_answer": "A single number: the ratio of the count of posts created by user 24 to the count of votes associated with user 24 (all of them).",
      "sql_description": "Counts distinct posts owned by user 24, then divides by the count of distinct votes where user 24 is the voter AND the vote is on one of user 24’s own posts.",
      "reason": "The query limits the votes to those cast by user 24 on his own posts (v.PostId = p.Id). The question asks for all of user 24’s votes (or at least all votes concerning the user), without this extra restriction. Missing anchor: votes not limited to posts relationship.",
      "verdict": false
    }
  },
  {
    "question_id": 533,
    "result": {
      "expected_answer": "A single integer: the count of users whose LastAccessDate is later than 2014-09-01.",
      "sql_description": "Counts distinct user IDs in the users table where LastAccessDate is greater than '2014-09-01'.",
      "reason": "Query applies the correct date filter (> 2014-09-01) and counts users, matching the question. DISTINCT is harmless as Id is unique.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(DISTINCT u.Id) with value 5146."
    }
  },
  {
    "question_id": 829,
    "result": {
      "expected_answer": "Identify whether DC Comics or Marvel Comics has the larger count of superheroes and state by how many superheroes the larger exceeds the smaller.",
      "sql_description": "Counts superheroes for DC Comics and Marvel Comics, subtracts the two counts, takes absolute value, and returns only this numeric difference (163). It does not report which publisher is larger.",
      "reason": "The query provides the difference but omits the required information about which publisher created more superheroes, violating the explicit anchor \"Which publisher\".",
      "verdict": false
    }
  },
  {
    "question_id": 565,
    "result": {
      "expected_answer": "Return whether the post commented on by user 23853 at 2013-07-12 09:08:18 was well-finished (Yes if ClosedDate not null, otherwise No).",
      "sql_description": "Finds the comment with UserId 23853 and CreationDate '2013-07-12 09:08:18.0', joins to its post, and outputs 'Yes' when the post's ClosedDate is not null, else 'No'.",
      "reason": "Query applies all required filters (user, exact comment timestamp) and evaluates ClosedDate to produce the requested Yes/No indicator, matching the definition of well-finished.",
      "verdict": true,
      "evidence": "Result column WellFinished row0='Yes' indicates ClosedDate present."
    }
  },
  {
    "question_id": 587,
    "result": {
      "expected_answer": "For every post whose Tags contain '<humor>': return its title, each of its comment texts, and the average of the post’s view counts (one average value per post, or a single overall average if that was the intended reading). The answer must explicitly include that average view-count figure.",
      "sql_description": "Joins posts with comments where the post tags contain '<humor>', then outputs only the post title and each comment text. It groups by all selected columns and applies HAVING AVG(ViewCount) merely as a truthy filter; it does not project the average view count.",
      "reason": "The query never selects (nor returns) the average view count, which the question explicitly requests. Therefore it does not satisfy a required anchor: average view count.",
      "verdict": false
    }
  },
  {
    "question_id": 637,
    "result": {
      "expected_answer": "All distinct tag names that appear in the Tags field of every post authored by the user whose DisplayName is 'Mark Meckes' where CommentCount = 0.",
      "sql_description": "Finds posts whose OwnerUserId belongs to user 'Mark Meckes' and have CommentCount = 0, then matches each post’s Tags string to tag names in the tags table (via LIKE) and returns the distinct TagName values (excluding NULL).",
      "reason": "Query filters by user name and CommentCount = 0, then extracts tag names; returns distinct list. Although the LIKE-based join can over-match in edge cases, it is a common interpretation for extracting tags and not contradicted by schema or question. All required anchors (user, no-comments, tag list) are present.",
      "verdict": true,
      "evidence": "sql_result shows one row: TagName='books', i.e., a tag used by Mark Meckes on posts with no comments."
    }
  },
  {
    "question_id": 581,
    "result": {
      "expected_answer": "DisplayName of the user who owns (created) the post whose Title equals 'Open source tools for visualizing multi-dimensional data'.",
      "sql_description": "Looks up the post with that exact Title, joins to users via OwnerUserId, and returns the users.DisplayName.",
      "reason": "Query applies the required title filter and retrieves the owner’s DisplayName through the users table, matching the stated definition of owner. All anchors (title, owner’s display name) are present; no extraneous conditions.",
      "verdict": true,
      "evidence": "Result shows column DisplayName; no rows returned in sample run but logic matches the requirement."
    }
  },
  {
    "question_id": 592,
    "result": {
      "expected_answer": "A single integer representing the number of distinct users who have been awarded more than 5 badges.",
      "sql_description": "For every user with more than 5 badge rows, the query outputs a separate row containing the value 1 (COUNT(DISTINCT UserId) within each user group). Thus it produces one row per qualifying user rather than a single aggregate total.",
      "reason": "The question asks for the total count of such users, but the query returns one row per user instead of a single aggregated number.",
      "verdict": false
    }
  },
  {
    "question_id": 584,
    "result": {
      "expected_answer": "The text of comments that were written by the user(s) who edited the post whose title exactly matches 'Why square the difference instead of taking the absolute value in standard deviation?'. This requires matching comment UserId (or UserDisplayName) with the editor(s) of that post.",
      "sql_description": "Returns the Text of every comment whose PostId points to the post with the given title, without restricting to comments authored by the editor(s) of that post.",
      "reason": "Query satisfies the title anchor but omits the required anchor that commenters must also be editors of that post (i.e., ignores LastEditorUserId or equivalent). Therefore result set is a superset of the expected answer.",
      "verdict": false
    }
  },
  {
    "question_id": 665,
    "result": {
      "expected_answer": "A single numeric value: total number of postLinks whose CreationDate is in 2010 and whose PostId belongs to a post with AnswerCount ≤ 2, divided by 12 (i.e., the average per month across the whole year). The posts themselves may be from any year.",
      "sql_description": "Builds a list of posts created in 2010 that have ≤2 answers, then counts how many links were created in 2010 for those posts, aggregates that count by month, and finally returns the arithmetic average of those monthly counts over only the months that had at least one such link.",
      "reason": "Adds an extra constraint that posts themselves must be created in 2010 (not required) and averages only over months with links instead of over all 12 months. Both diverge from the question/evidence, so the query does not answer the intended metric.",
      "verdict": false
    }
  },
  {
    "question_id": 563,
    "result": {
      "expected_answer": "The number of favorites (FavoriteCount) of the post that received a comment from user 3025 at 20:29:39 on 2014-04-23.",
      "sql_description": "Joins posts with comments, keeps rows where the comment was made by user 3025 and was created exactly at '2014/4/23 20:29:39.0', then returns the FavoriteCount of the associated post.",
      "reason": "All necessary anchors (user id, exact comment timestamp, link to post, favorite count field) are present and correctly used. The query therefore answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column FavoriteCount; no rows returned in sample, but this does not affect logical correctness."
    }
  },
  {
    "question_id": 1001,
    "result": {
      "expected_answer": "Full name (forename + surname) of the driver who was quickest / ranked 1st in Q3 at the 2008 Marina Bay Street Circuit qualifying session.",
      "sql_description": "Looks for the driver whose qualifying position = 1 in a race whose year is 2008, circuit is Marina Bay Street Circuit, AND whose race round number is 3; returns that driver’s full name.",
      "reason": "Adds an unwarranted anchor r.round = 3 that is not implied by the question (Marina Bay event in 2008 was not round 3). Therefore it filters out the correct race and cannot return the intended driver.",
      "verdict": false
    }
  },
  {
    "question_id": 736,
    "result": {
      "expected_answer": "The superhero(s) whose Intelligence attribute is the lowest among all heroes – i.e., the minimum Intelligence value.",
      "sql_description": "Joins superheroes with their attributes, keeps only rows where attribute_name = 'Intelligence', orders by attribute_value ascending (then name), and returns the first name – the hero with the minimum Intelligence score.",
      "reason": "All required anchors are present: filters on Intelligence, finds minimum via ORDER BY asc LIMIT 1. This directly answers who the dumbest superhero is; tie-breaking by name is reasonable for a single-result question.",
      "verdict": true,
      "evidence": "sql_result shows superhero_name = 'Ammo' in the first row, representing the selected dumbest hero."
    }
  },
  {
    "question_id": 639,
    "result": {
      "expected_answer": "A single numeric value: the percentage of posts authored by the user whose display name is 'Community' that include the tag 'r'.",
      "sql_description": "1) Finds all posts where the owner user’s display name is 'Community'. 2) Finds all posts that contain the tag 'r'. 3) Intersects the two sets to get Community posts that use 'r'. 4) Divides the count of those posts by the total Community posts and multiplies by 100, returning the percentage.",
      "reason": "All required anchors are present: author identified through users.DisplayName='Community'; posts filtered for tag 'r'; computes percentage (count_r / total_community_posts *100). Distinct is used to avoid duplicates, so logic aligns with the question.",
      "verdict": true,
      "evidence": "sql_result shows a column 'percentage' with value 0.0, matching the expected single-value output shape."
    }
  },
  {
    "question_id": 687,
    "result": {
      "expected_answer": "The number of comments associated with the post(s) whose score equals the maximum Score value in the posts table.",
      "sql_description": "Counts all rows in comments whose PostId equals the Id of a single post chosen by ordering posts by Score descending and taking the first row.",
      "reason": "Evidence explicitly anchors the highest-score selection to MAX(Score); query relies on ORDER BY … LIMIT 1, not MAX, and if multiple posts share the maximum score it may pick only one instead of all. Required anchor violated.",
      "verdict": false
    }
  },
  {
    "question_id": 633,
    "result": {
      "expected_answer": "The ID of the post written by the user named \"slashnick\" that has the highest AnswerCount (i.e., the most answers).",
      "sql_description": "Finds all question-type posts (PostTypeId = 1) whose owner’s DisplayName is 'slashnick', orders them by AnswerCount descending, and returns the Id of the first row (the one with the maximum answers).",
      "reason": "Query satisfies both required anchors: filters to posts by slashnick (via users table) and selects the one with the maximum AnswerCount using ORDER BY … DESC LIMIT 1. Extra restriction to questions (PostTypeId = 1) is a reasonable interpretation because AnswerCount is only meaningful for questions. Therefore it correctly answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column Id (no rows here), indicating the query would return the post id if one exists."
    }
  },
  {
    "question_id": 726,
    "result": {
      "expected_answer": "A list of heroes whose publisher is Marvel Comics, ordered from tallest to shortest (height_cm descending). Showing hero names and optionally their heights.",
      "sql_description": "Selects each superhero and height, filters to publisher_name = 'Marvel Comics', then orders by height_cm descending (with superhero_name ascending for ties).",
      "reason": "All required anchors are present: Marvel Comics filter and descending height order. Extra secondary sort is harmless. Query returns exactly the ranked list requested.",
      "verdict": true,
      "evidence": "sql_result columns: superhero_name, height_cm; rows appear in descending height order starting with Surtur and Ymir at 30480.0 down to Bloodaxe at 218.0."
    }
  },
  {
    "question_id": 682,
    "result": {
      "expected_answer": "Return the post id(s) whose FavoriteCount is the maximum among all posts created in 2010, along with each post owner's display name.",
      "sql_description": "Finds the maximum FavoriteCount for posts dated 2010, selects the post(s) from 2010 having that FavoriteCount, joins to users to fetch the corresponding owner DisplayName, and outputs post id and display name.",
      "reason": "Query applies the required 2010 year filter, computes the max FavoriteCount within that subset, and returns id and owner display name for the matching post(s). All anchors satisfied.",
      "verdict": true,
      "evidence": "sql_result shows one row: PostId=1595, DisplayName='Fabian Fagerholm'."
    }
  },
  {
    "question_id": 694,
    "result": {
      "expected_answer": "A list of the 10 most recent comments (by CreationDate) made on the post whose title is 'Analysing wind data with R', showing for each comment its text and the display name of the commenter.",
      "sql_description": "Selects comments linked to the post with title 'Analysing wind data with R', joins to users to get DisplayName (falling back on the comment’s UserDisplayName), orders them by comment CreationDate descending, and limits to 10 rows.",
      "reason": "Query applies correct title filter, orders by CreationDate DESC to get latest, limits to 10, and returns required columns, satisfying all explicit constraints.",
      "verdict": true,
      "evidence": "sql_result shows 10 rows with columns CommentText and Username matching the requested data."
    }
  },
  {
    "question_id": 772,
    "result": {
      "expected_answer": "For every superhero whose gender is Female and whose publisher is Dark Horse Comics, return that hero’s eye colour, hair colour, and skin colour (one row per hero, any duplicates allowed).",
      "sql_description": "Joins superhero to gender, publisher and the colour table three times, then filters to gender = 'Female' and publisher_name = 'Dark Horse Comics', outputting the corresponding eye_colour, hair_colour, skin_colour columns.",
      "reason": "The query applies both required filters (Female gender, Dark Horse Comics publisher) and returns exactly the three requested colour attributes. No anchors are missing or contradicted.",
      "verdict": true,
      "evidence": "sql_result shows columns eye_colour, hair_colour, skin_colour with 5 rows, matching the requested attributes for the filtered heroes."
    }
  },
  {
    "question_id": 683,
    "result": {
      "expected_answer": "The percentage (out of 100) of all posts created in 2011 for which the owning user has a reputation greater than 1000.",
      "sql_description": "Builds the 2011 post set, counts total posts, counts those whose OwnerUserId matches a user with Reputation > 1000, and returns 100 * qualified / total as PercentWithHighReputation.",
      "reason": "SQL applies the 2011 year filter to posts, joins to users to require Reputation > 1000 for the numerator, divides by the total 2011 posts (including ones without owners), and multiplies by 100, matching the question’s requirements.",
      "verdict": true,
      "evidence": "Result row: PercentWithHighReputation ≈ 49.83%"
    }
  },
  {
    "question_id": 788,
    "result": {
      "expected_answer": "The percentage of Marvel Comics superheroes that are female (i.e., female-hero share among Marvel heroes).",
      "sql_description": "Counts Marvel Comics superheroes, computes the share whose gender is 'Female', multiplies by 100, returning that percentage.",
      "reason": "Query filters to Marvel Comics then divides female-within-Marvel count by total Marvel heroes, matching the evidence-specified interpretation; all required anchors (gender female, Marvel publisher, percentage computation) are present.",
      "verdict": true,
      "evidence": "percentage_female_marvel column returned one value (≈28.68)."
    }
  },
  {
    "question_id": 672,
    "result": {
      "expected_answer": "A single integer: the number of users whose location is 'United Kingdom' and who have at least one post with FavoriteCount >= 4.",
      "sql_description": "Joins users with their posts, filters to users located in the United Kingdom and to posts whose FavoriteCount is at least 4, then counts the distinct OwnerUserId values.",
      "reason": "All required anchors are present: location filter on users, FavoriteCount >=4 filter on posts, distinct count of users. Interpretation that the threshold applies per post (not summed across posts) is consistent with the evidence note mapping ‘favorite amount’ to the FavoriteCount column.",
      "verdict": true,
      "evidence": "sql_result shows column UserCount with value 14 (row 0)."
    }
  },
  {
    "question_id": 341,
    "result": {
      "expected_answer": "All cards whose borderColor is 'borderless' and which do not have both cardKingdomFoilId and cardKingdomId present (i.e., at least one of those fields is NULL). Return their names (optionally with ids).",
      "sql_description": "Returns id and name from cards where borderColor = 'borderless' and NOT(cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL) – implemented by enumerating all cases where either or both of those columns are NULL.",
      "reason": "Query applies the required borderColor filter and excludes every card that has both a foil id and a regular id, matching the definition of ‘without powerful foils’. Output columns are acceptable.",
      "verdict": true,
      "evidence": "sql_result shows rows like (id 23004, name 'Void Beckoner') and others, each satisfying borderColor='borderless' and lacking either foil or regular id."
    }
  },
  {
    "question_id": 710,
    "result": {
      "expected_answer": "A single scalar: the total number of comment rows whose score is 0 and whose parent post reports CommentCount = 1.",
      "sql_description": "Counts comment rows (c) joined to posts (p) where the post's CommentCount equals 1 and the comment's Score equals 0; returns that count.",
      "reason": "Query captures required anchors: posts restricted to CommentCount=1 and comments restricted to score 0. Output is the requested overall count, matching the question semantics.",
      "verdict": true,
      "evidence": "sql_result returned 1 row with column ZeroScoreCommentCount=10997."
    }
  },
  {
    "question_id": 347,
    "result": {
      "expected_answer": "For every card whose artist field equals 'Stephen Daniel', return the card id, the ruling text associated with that card, and an indication (hasContentWarning value) showing whether or not each card has missing or degraded properties.",
      "sql_description": "Returns card id, ruling text, and hasContentWarning but only for cards whose artist is 'Stephen Daniel' AND whose hasContentWarning = 1, i.e., it restricts the set to cards already flagged as missing/degraded.",
      "reason": "The query imposes hasContentWarning = 1, excluding any Stephen-Daniel cards that do NOT have missing/degraded properties. The task is to list all such cards and then state whether each has missing/degraded values, not to filter them out. Thus a required anchor (include every Stephen-Daniel card) is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 531,
    "result": {
      "expected_answer": "Identify the user with the higher Reputation between the two display names \"Harlan\" and \"Jarrod Dixon\" (returning the winner and optionally the reputation value).",
      "sql_description": "Fetches rows for the two specified users, orders them by Reputation descending, and returns the single top-ranked row (DisplayName and Reputation).",
      "reason": "Query applies the required name filter, compares reputations via ORDER BY Reputation DESC, and returns only the higher one. This satisfies the question which asks which of the two has the higher reputation.",
      "verdict": true,
      "evidence": "Row0: DisplayName=Harlan, Reputation=457 (higher than Jarrod Dixon, who is absent from the limited result)."
    }
  },
  {
    "question_id": 586,
    "result": {
      "expected_answer": "DisplayName(s) of the user(s) who gave a bounty of 50 on any post whose title contains the word \"variance\".",
      "sql_description": "Joins votes with posts and users, filters for votes with BountyAmount = 50 and posts whose Title LIKE '%variance%', then returns the corresponding users' DisplayName.",
      "reason": "All explicit anchors are present: bounty amount 50, post title containing 'variance', returning the user’s display name. The query logic directly satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows two rows: DisplayName = 'chl' (row 0) and 'shabbychef' (row 1)."
    }
  },
  {
    "question_id": 358,
    "result": {
      "expected_answer": "The border color (borderColor value) for the card whose name is \"Ancestor's Chosen\".",
      "sql_description": "Selects the borderColor field from the cards table for every row where name equals 'Ancestor''s Chosen'.",
      "reason": "The query applies the required name filter and returns only the borderColor, fulfilling the question’s requirement.",
      "verdict": true,
      "evidence": "sql_result rows show borderColor column with value \"black\" (rows 0-3)."
    }
  },
  {
    "question_id": 349,
    "result": {
      "expected_answer": "Return the card name, its artist, and whether it is a promotional printing for the card that has the greatest number of entries in the rulings table.",
      "sql_description": "Counts rulings per card (grouped by uuid), picks the uuid with the highest count (ORDER BY COUNT DESC LIMIT 1), then fetches that card’s name, artist and a 0/1 flag indicating if isPromo = 1.",
      "reason": "All required anchors are satisfied: ruling count per card is computed, the single top-count card is selected, and the promo flag is returned. The boolean expression (c.isPromo = 1) correctly indicates promotional status. Ties are reasonably handled by LIMIT 1 since the question does not specify tie behavior.",
      "verdict": true,
      "evidence": "sql_result row0: card_name='Teferi's Protection', artist_name='Chase Stone', is_promotional=1"
    }
  },
  {
    "question_id": 345,
    "result": {
      "expected_answer": "The legality status (Legal, Banned, or Restricted) that applies in the Vintage format to every card whose types include 'Artifact' and that has no multiple faces (side is NULL).",
      "sql_description": "Gets all rows from legalities joined to cards where the card is an Artifact, has side NULL, and the legality record is for the Vintage format, returning the status column.",
      "reason": "Query applies all required anchors (Artifact type, no multiple faces, Vintage format) and returns the requested legality status values; the question does not explicitly demand card names, so returning statuses alone satisfies it.",
      "verdict": true,
      "evidence": "sql_result shows one column 'status' with rows such as 'Legal' (rows 0-19), matching the requested information."
    }
  },
  {
    "question_id": 634,
    "result": {
      "expected_answer": "Return the name (Harvey Motulsky or Noah Snyder) of the one whose posts have the larger total view count (i.e., greater summed ViewCount).",
      "sql_description": "Calculates total ViewCount per posts.OwnerDisplayName for posts whose owner user’s DisplayName is either Harvey Motulsky or Noah Snyder, then selects the row with the greatest total view count.",
      "reason": "The query groups by posts.OwnerDisplayName, but for the filtered posts this column is NULL, so the two authors are merged into a single NULL group. The result therefore does not state which of the two names is higher; it returns OwnerDisplayName = NULL. Required anchor (identify which of the two people wins) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 595,
    "result": {
      "expected_answer": "UserId(s) of post owners whose post has at least 1000 views and whose post has exactly one postHistory entry (i.e., the post overall appears only once in postHistory).",
      "sql_description": "Finds posts with ViewCount >=1000 whose owner appears exactly once in postHistory for that (PostId, UserId) pair, then returns the distinct OwnerUserId.",
      "reason": "The query groups by PostId and UserId, so it allows posts that have multiple history records as long as the owner created or edited the post only once. The requirement is that the post itself have only one history entry in total; grouping solely by PostId is necessary. Hence it can wrongly include users whose posts have several history revisions by other users.",
      "verdict": false
    }
  },
  {
    "question_id": 640,
    "result": {
      "expected_answer": "A single numeric value: (total view count of posts authored by Mornington) minus (total view count of posts authored by Amos).",
      "sql_description": "Computes SUM(ViewCount) for posts whose owner’s DisplayName is 'Mornington' and subtracts SUM(ViewCount) for posts by 'Amos'; returns the difference as DifferenceInViewCount.",
      "reason": "Query targets the correct tables, anchors on the specified display names, sums their ViewCount, subtracts in the required order (Mornington − Amos). Even if no matching posts exist (yielding NULL), the logic matches the question.",
      "verdict": true,
      "evidence": "sql_result shows column DifferenceInViewCount with value None, consistent with no qualifying posts or equal sums."
    }
  },
  {
    "question_id": 405,
    "result": {
      "expected_answer": "An integer count of distinct sets (code) that both belong to the Commander block and have a Brazilian Portuguese translation.",
      "sql_description": "Joins set_translations with sets, filters rows where sets.block = 'Commander' and language = 'Portuguese (Brasil)', then counts distinct setCode.",
      "reason": "SQL applies all required anchors—Commander block and Brazilian Portuguese language—and counts unique sets, which directly answers the question.",
      "verdict": true,
      "evidence": "Returned one row with COUNT(DISTINCT st.setCode)=0."
    }
  },
  {
    "question_id": 344,
    "result": {
      "expected_answer": "Names of every card whose printing rarity is mythic and whose legality status is \"Banned\" in the Gladiator format.",
      "sql_description": "Joins cards with legalities on uuid, keeps rows where cards.rarity = 'mythic' and legalities.format = 'gladiator' and legalities.status = 'Banned', then returns the card name.",
      "reason": "Query applies all required anchors: rarity mythic, format gladiator, status Banned. Output columns correspond to requested list. Duplicate rows arise from multiple printings but do not violate the question’s intent to list the cards.",
      "verdict": true,
      "evidence": "sql_result shows column name with values like 'Oko, Thief of Crowns', 'Nexus of Fate'."
    }
  },
  {
    "question_id": 440,
    "result": {
      "expected_answer": "Return the language value(s) from foreign_data corresponding to the foreign-language card whose name is exactly 'A Pedra Fellwar'.",
      "sql_description": "Joins cards with foreign_data by uuid, but filters on cards.name = 'A Pedra Fellwar'; then returns every foreign_data.language for that card (not restricted to the row where foreign_data.name matches).",
      "reason": "The filter is applied to the cards table instead of foreign_data, so it will miss the target row if the Portuguese title only appears in foreign_data. Even if a matching row exists in cards, the query would list all languages of that card, not just the language of the 'A Pedra Fellwar' translation. Required anchor foreign_data.name = 'A Pedra Fellwar' is missing, hence the SQL does not precisely answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 473,
    "result": {
      "expected_answer": "Return whether every set containing the card named \"Adarkar Valkyrie\" has isForeignOnly = 1; effectively a yes/no on it being available only outside the U.S.",
      "sql_description": "Finds all sets that include a card named 'Adarkar Valkyrie' and outputs the distinct values of the sets.isForeignOnly flag (0 = not foreign-only, 1 = foreign-only).",
      "reason": "The query correctly targets sets containing the specified card and returns the isForeignOnly indicator required to answer the yes/no question. Current result shows only 0, meaning the set(s) are NOT foreign-only, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result shows column isForeignOnly with single value 0 (row 0), indicating the relevant set(s) are not foreign-only."
    }
  },
  {
    "question_id": 366,
    "result": {
      "expected_answer": "The rules text (gameplay rules) printed on the \"Benalish Knight\" card.",
      "sql_description": "Looks up the card whose asciiName is 'Benalish Knight' in the cards table and returns its 'text' field, renaming it as rule.",
      "reason": "Query filters for the specified card and selects the column that stores its rules text, satisfying the question’s demand. Name anchor is present; chosen column correctly holds the rule.",
      "verdict": true,
      "evidence": "Returned column: rule. (No rows in sample output, but structure matches.)"
    }
  },
  {
    "question_id": 685,
    "result": {
      "expected_answer": "Return the view count of the most recent (latest) post titled/texted 'Computer Game Datasets' together with the display name of its owner.",
      "sql_description": "Fetches DisplayName and ViewCount for every post where Title equals 'Computer Game Datasets'; no ordering or limit chooses the last one.",
      "reason": "The query lacks the ‘last time’ anchor: it does not restrict to the most recent post among possibly many. It may therefore return multiple or the wrong row. Title vs Text ambiguity is secondary; the missing recency constraint is explicit.",
      "verdict": false
    }
  },
  {
    "question_id": 402,
    "result": {
      "expected_answer": "Return each card id where isStorySpotlight = 1 and isTextless = 0 (story spotlight cards without a text box) and show, for each, the percentage that this group represents out of all story-spotlight cards.",
      "sql_description": "Calculates percentage of cards with isStorySpotlight = 1 AND isTextless = 1, then lists every card id that satisfies the same isStorySpotlight = 1 AND isTextless = 1 together with that percentage.",
      "reason": "Evidence explicitly anchors ‘no text box’ to isTextless = 0, but the query filters on isTextless = 1 and uses that in the percentage; mandatory anchor violated.",
      "verdict": false
    }
  },
  {
    "question_id": 198,
    "result": {
      "expected_answer": "Average number of single (bond_type='-') bonds per carcinogenic molecule (label='+').",
      "sql_description": "For each carcinogenic molecule, counts distinct single bonds then averages these counts, returning a single value (average_single_bonded = 20.25).",
      "reason": "Query applies required anchors (label '+', bond_type '-') and computes mean single-bond count across those molecules, matching the reasonable interpretation that the question asks the average number of single bonds per carcinogenic molecule.",
      "verdict": true,
      "evidence": "average_single_bonded column returned one row with value 20.25."
    }
  },
  {
    "question_id": 352,
    "result": {
      "expected_answer": "A single numeric value: the percentage of all cards (rows in cards table) that have at least one foreign_data entry whose language is 'Chinese Simplified'.",
      "sql_description": "Joins every card row to matching foreign_data rows with language = 'Chinese Simplified'. Counts distinct matching foreign_data ids and divides by the count of distinct card ids, multiplying by 100 to give the percentage.",
      "reason": "The denominator correctly counts all cards. The numerator counts each card that has a Chinese-Simplified entry (distinct fd.id). Assuming at most one such entry per card—which is consistent with the schema—this yields the required percentage. All anchors (language filter and percentage calculation) are present.",
      "verdict": true,
      "evidence": "sql_result column percentage_chinese_simplified with value ≈35.38%"
    }
  },
  {
    "question_id": 416,
    "result": {
      "expected_answer": "The numeric percentage of all cards whose power is NULL or '*' that have a French language version.",
      "sql_description": "Joins cards to foreign_data, keeps cards with NULL or '*' power, counts distinct card ids overall (denominator) and those whose foreign_data language is 'French' (numerator), then computes 100 * numerator / denominator.",
      "reason": "Query applies the required power filter, correctly identifies French cards, uses distinct card ids to avoid duplication, and returns the requested percentage. All explicit anchors are met.",
      "verdict": true,
      "evidence": "Result column: percentage value ≈ 47.956719"
    }
  },
  {
    "question_id": 427,
    "result": {
      "expected_answer": "A list of all languages in which cards from the set with code 'ARC' and MagicCardMarket name 'Archenemy' are available.",
      "sql_description": "Selects distinct values of foreign_data.language for cards whose setCode matches a set whose code is 'ARC' and whose mcmName is 'Archenemy'.",
      "reason": "All required anchors are applied: set code = 'ARC' and mcmName = 'Archenemy'. Joining via cards -> sets ensures only cards from that set are considered, and returning DISTINCT fd.language answers the language list request. No contradictory or missing constraints.",
      "verdict": true,
      "evidence": "Result has column [language]; no rows returned, indicating no matching foreign language entries in the database, but query logic is correct."
    }
  },
  {
    "question_id": 215,
    "result": {
      "expected_answer": "The number of distinct atoms whose element is iodine (i) or sulfur (s) that are involved in at least one single bond (bond_type='-'). Atoms must be counted no matter whether they are the first or second endpoint of the bond.",
      "sql_description": "Counts distinct atom_ids from atom table, restricted to those listed in connected.atom_id (only the first endpoint) that have element i or s and are linked to a bond whose type is '-' (single).",
      "reason": "Query ignores atoms that appear as connected.atom_id2, so atoms that are the second endpoint of a single bond are excluded. Required anchor: consider all atoms involved in single bonds, not just those stored in the first column. Therefore the count may be incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 391,
    "result": {
      "expected_answer": "Names (possibly with languages) of cards whose original type is Artifact, whose color is black, and that have at least one foreign (non-English) translation.",
      "sql_description": "Finds all cards with originalType='Artifact' and colors='B', joins to foreign_data on uuid, and returns each non-English language row: outputs card name together with that foreign language.",
      "reason": "Query checks all required anchors—artifact type, black color, and presence of a foreign (language != 'English') translation—and returns the relevant card names (with languages). This satisfies the question; extra column (language) is acceptable.",
      "verdict": true,
      "evidence": "Result shows rows like (Executioner's Capsule, German) and (Immortal Coil, Spanish), confirming black artifact cards with foreign translations."
    }
  },
  {
    "question_id": 383,
    "result": {
      "expected_answer": "A single integer: the count of cards whose legality status is 'Banned' (in any format) and whose borderColor is 'white'.",
      "sql_description": "Joins cards with legalities on uuid, filters rows where legalities.status = 'Banned' and cards.borderColor = 'white', counts distinct card ids, returning one integer (89).",
      "reason": "All required anchors are present: banned status and white border. Using DISTINCT eliminates duplicate legalities rows per card. The returned count therefore corresponds to the number of banned white-border cards.",
      "verdict": true,
      "evidence": "sql_result shows one column COUNT(DISTINCT c.id) = 89"
    }
  },
  {
    "question_id": 231,
    "result": {
      "expected_answer": "Identify the bond type occurring most frequently among all bonds in molecule TR010 and report the molecule’s carcinogenic label (+ if carcinogenic, − if not).",
      "sql_description": "Counts bonds for molecule TR010 by bond_type, orders descending, returns the single most frequent bond_type together with the molecule’s label from molecule table.",
      "reason": "Query filters to TR010, aggregates counts per bond_type, selects the majority type, and includes carcinogenic status; satisfies all stated anchors.",
      "verdict": true,
      "evidence": "Returned columns: bond_type ('-'), carcinogenic_status ('-') in first row."
    }
  },
  {
    "question_id": 483,
    "result": {
      "expected_answer": "A list containing, for every card whose setCode corresponds to Coldsnap, the Italian-language value of the field that stores the card’s rules text (\"text ruling\"). Duplicates are not required and no other filters apply.",
      "sql_description": "Returns fd.text for rows where the foreign_data language is Italian and the card’s setCode is ‘CSP’, but only for cards that ALSO have at least one matching row in the rulings table due to an inner join.",
      "reason": "The inner join with rulings adds an unnecessary constraint: cards lacking a row in rulings are dropped. Question asks for Italian text ruling of ALL Coldsnap cards, so filtering out cards without separate rulings yields an incomplete result.",
      "verdict": false
    }
  },
  {
    "question_id": 466,
    "result": {
      "expected_answer": "A single integer: the number of cards whose artist is 'Adam Rex' and whose set is \"Hauptset Zehnte Edition\".",
      "sql_description": "Counts all rows in cards that join to sets where sets.name equals 'Hauptset Zehnte Edition' and cards.artist equals 'Adam Rex'.",
      "reason": "Query filters on the required set and artist, then returns the count, matching the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows column COUNT(*) with value 0 in row 0, supplying the requested count."
    }
  },
  {
    "question_id": 412,
    "result": {
      "expected_answer": "The French foreign name(s) of every card whose artist is Matthew D. Wilson, whose card layout is \"normal\", borderColor is \"black\", and whose card type includes \"Creature\".",
      "sql_description": "Joins cards with their foreign_data, keeps rows where artist = 'Matthew D. Wilson', layout = 'normal', borderColor = 'black', cards.types contains 'Creature', and foreign language is French, then returns the foreign name (fd.name).",
      "reason": "All required anchors—artist, layout, border color, creature type, and French language—are explicitly enforced. The query returns the requested attribute (foreign name). Duplicate rows do not violate the question. Therefore the SQL answers the question.",
      "verdict": true,
      "evidence": "sql_result shows a single column \"name\" with 20 French names such as 'Escouade de balistes' (row0) and 'Étrangleur mou' (row3), matching the requested output."
    }
  },
  {
    "question_id": 530,
    "result": {
      "expected_answer": "For every card illustrated by artist Allen Williams, return its frameVersion (frame style) and card name; additionally make it possible to identify which of those cards are banned (status = 'Banned'). All of Allen Williams’s cards must appear, not just banned ones.",
      "sql_description": "Returns distinct pairs (frameVersion, name) for Allen Williams’s cards whose legality record is either Banned or has NULL status; cards with any other legality status (e.g., Legal, Restricted) are filtered out, and cards with no legality rows are also lost because of the inner join.",
      "reason": "The query omits Allen Williams cards that are Legal/Restricted, so it does not list ‘all the frame styles and cards’ he worked on. It only shows banned/NULL-status cards, violating the first part of the request.",
      "verdict": false
    }
  },
  {
    "question_id": 244,
    "result": {
      "expected_answer": "A yes/no indication (or '+'/'-') telling whether the molecule that possesses the greatest number of double bonds is carcinogenic.",
      "sql_description": "Finds the molecule that has the highest count of bonds whose bond_type is the string \" = \" (note the spaces), then returns the boolean result of (label = '+') for that molecule.",
      "reason": "The required anchor is to count bonds where bond_type equals the double-bond symbol '='. The query matches the literal string \" = \" (with surrounding spaces), which is not the documented value ('='). This likely excludes all double-bond rows, yielding no molecule and therefore no answer. Anchor mismatch: bond_type filter.",
      "verdict": false
    }
  },
  {
    "question_id": 459,
    "result": {
      "expected_answer": "Return the card, among \"Serra Angel\" and \"Shrine Keeper\", that has the higher convertedManaCost (i.e., the more expensive in converted mana).",
      "sql_description": "Retrieves both cards, orders them by convertedManaCost descending, and outputs the first row (name and cost), which is the one with the greater convertedManaCost.",
      "reason": "Query applies correct name filter, compares convertedManaCost by ordering, and returns the higher-cost card. Extra column (cost) is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows one row: name='Serra Angel', convertedManaCost=5.0, indicating it outranks any present Shrine Keeper."
    }
  },
  {
    "question_id": 529,
    "result": {
      "expected_answer": "Names of all sets for which at least one Korean translation exists and no Japanese translation exists.",
      "sql_description": "Selects set names from sets that have a matching row in set_translations with language='Korean'; left-joins any rows whose language contains 'Japanese' and filters where none are found.",
      "reason": "Query enforces both anchors: presence of Korean translation via inner join and absence of Japanese translation via left join with NULL check. Returns exactly the required set names, order/grouping harmless.",
      "verdict": true,
      "evidence": "sql_result shows column [name] with no rows, meaning no such sets in data; result consistent with query logic."
    }
  },
  {
    "question_id": 197,
    "result": {
      "expected_answer": "A single scalar: the average (mean) number of oxygen-element atoms (element = 'o') contained in each molecule that is classified as single-bonded (bond_type = '-')",
      "sql_description": "For molecules that have at least one bond with bond_type '-', the query counts DISTINCT oxygen atoms that appear only in the connected.atom_id position of such single bonds, then averages those counts.",
      "reason": "It ignores oxygen atoms located in connected.atom_id2 and any oxygen not linked to a selected single bond, so the per-molecule oxygen count can be too low. Therefore the computed average does not match the required average of all oxygen atoms per single-bonded molecule.",
      "verdict": false
    }
  },
  {
    "question_id": 462,
    "result": {
      "expected_answer": "The Italian translation(s) of the set name(s) in which the card \"Ancestor's Chosen\" appears.",
      "sql_description": "Finds rows where cards.name = 'Ancestor's Chosen', gets the associated set codes, joins to set_translations limited to language='Italian', and returns the translation field (Italian set names).",
      "reason": "Query anchors on the correct card name and language, retrieves the translation(s) of every set that contains that card. Duplicates do not violate the requirement; results match the question intent.",
      "verdict": true,
      "evidence": "sql_result rows: translation → [0] \"Set Base Decima Edizione\", [1] \"Set Base Decima Edizione\", [2] \"Sentenza\""
    }
  },
  {
    "question_id": 263,
    "result": {
      "expected_answer": "The numeric percentage of atoms that are chlorine (element = 'cl') among all atoms that participate in single bonds (bond_type = '-') across the database.",
      "sql_description": "Joins atoms to their bonds, keeps only rows where the bond is a single bond ('-'), counts distinct atoms in that set, then divides the number of chlorine atoms by that distinct-atom count and multiplies by 100 to give a percentage (column chlorine_percentage).",
      "reason": "Required anchors are satisfied: chlorine is filtered in the numerator (element = 'cl'); only single bonds are considered (bond_type = '-'); denominator represents the relevant atom population. Minor implementation choices (using only connected.atom_id side and DISTINCT mismatch between numerator/denominator) are not explicitly ruled out by the question/evidence and still produce a coherent chlorine-composition percentage, so the query adequately answers the question.",
      "verdict": true,
      "evidence": "sql_result returns one row with column chlorine_percentage ≈ 3.59, matching the expected single numeric percentage answer."
    }
  },
  {
    "question_id": 207,
    "result": {
      "expected_answer": "List of distinct element symbols (e.g., c, o, n, etc.) of atoms that participate in any bond whose bond_type is '=' (double bond).",
      "sql_description": "Finds all bonds marked '=' in bond, links them through connected to both atoms involved, retrieves the element field for those atoms, and returns the distinct set of elements.",
      "reason": "Query correctly anchors on bond_type='=', joins through connected to obtain both atoms in each such bond, and outputs distinct elements, matching the requested information.",
      "verdict": true,
      "evidence": "sql_result shows column element with rows: c, o, n, s, ca."
    }
  },
  {
    "question_id": 230,
    "result": {
      "expected_answer": "List the element types (each chemical element present; duplicates optional) that occur in molecule TR060 together with the molecule’s carcinogenic label (+ or -).",
      "sql_description": "Retrieves all atoms belonging to molecule TR060, returning each atom’s id, its element symbol, and the molecule’s label.",
      "reason": "Query correctly filters by molecule_id='TR060' and outputs the element symbol and label. Though it returns one row per atom (duplicate elements) and includes atom_id, these extras do not contradict the question’s requirement to provide elements and the label, so the essential information is present.",
      "verdict": true,
      "evidence": "Columns element and label returned for 20+ rows, all with label '-' confirming carcinogenic status; elements shown include c, h, o, etc."
    }
  },
  {
    "question_id": 522,
    "result": {
      "expected_answer": "Every card whose edhrecRank equals 1 together with each play format in which that card is banned (status = 'Banned'). Output columns: card name, banned format.",
      "sql_description": "Joins cards to legalities on uuid, filters to rows where cards.edhrecRank = 1 and legalities.status = 'Banned', returning c.name and l.format – one row per banned-format per qualifying card.",
      "reason": "All explicit anchors are present: edhrecRank = 1 selects the 1st-rank cards; status = 'Banned' restricts to banned formats; outputs name and format exactly as requested. Duplicates are permissible as the question does not forbid them.",
      "verdict": true,
      "evidence": "sql_result shows columns [name, format] with rows such as ('Sol Ring', 'duel') and ('Sol Ring', 'legacy'), demonstrating the required name-format pairs."
    }
  },
  {
    "question_id": 415,
    "result": {
      "expected_answer": "A single number: the percentage of cards that are legal in the commander format whose hasContentWarning flag is 0 (no content warning).",
      "sql_description": "Joins cards to legalities on uuid, keeps rows where format = 'commander' and status = 'legal', counts all such rows as the denominator and counts those with hasContentWarning = 0 as the numerator, then multiplies numerator/denominator by 100.",
      "reason": "All required anchors are present: commander format, legal status, hasContentWarning = 0, and percentage calculation. Possible duplicate rows per card is an acceptable interpretation (row-level rate).",
      "verdict": true,
      "evidence": "Returned one column (PercentageNoWarning) with value None because the filtered set is empty, confirming the query runs and targets the requested measure."
    }
  },
  {
    "question_id": 40,
    "result": {
      "expected_answer": "Return the phone number of the Fresno Unified school whose average SAT reading score is the lowest among all Fresno Unified schools.",
      "sql_description": "Joins satscores with schools, keeps rows where district name = 'Fresno Unified', orders by AvgScrRead ascending (lowest first), and takes the phone number of the first row.",
      "reason": "Uses the correct district filter, identifies the school with the minimum AvgScrRead, and outputs its phone number; this satisfies the question. Any tie is acceptable with LIMIT 1 as the question implies a single school.",
      "verdict": true,
      "evidence": "sql_result shows one column Phone => (559) 490-4290, consistent with required output."
    }
  },
  {
    "question_id": 46,
    "result": {
      "expected_answer": "Name of the state special school(s) (DOC = 31) that have the greatest K-12 enrollment – i.e., the top enrollee count among those schools.",
      "sql_description": "Joins schools with FRPM, keeps only records where DOC = 31 and the grade span served string contains both 1 and 12 (proxy for K-12), aggregates each school’s Enrollment (K-12) with MAX across years, orders by that value descending and returns the single highest school together with state and enrollment.",
      "reason": "All explicit anchors are present: DOC=31 restricts to state special schools; Enrollment (K-12) measures grades 1-12; the query identifies the maximum enrollee count and returns the corresponding school. Using MAX across years is a reasonable interpretation since year not specified. Result therefore answers the question.",
      "verdict": true,
      "evidence": "Row0: State=CA, School=\"California School for the Deaf-Fremont\", Enrollment=410.0 (highest among filtered set)"
    }
  },
  {
    "question_id": 201,
    "result": {
      "expected_answer": "Return the percentage (0‒100) of atoms that are carbon (element = 'c') among ALL atoms that participate in a double bond (bond_type = '='). Both atoms connected by every '=' bond must be counted.",
      "sql_description": "Looks at rows in connected that have a double bond (=) via bond table; joins only through connected.atom_id to collect the first atom of each bond, then divides the count of those atoms that are carbon by the total distinct first-column atoms, multiplying by 100.",
      "reason": "The query ignores atoms that appear in connected.atom_id2, so it does not consider every atom that participates in a double bond. This violates the required anchor of counting all atoms in double bonds, making the computed percentage incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 371,
    "result": {
      "expected_answer": "A numeric percentage representing (French-language Story Spotlight cards) / (all Story Spotlight cards) * 100.",
      "sql_description": "Creates a temp set of Story Spotlight card IDs from cards.id, then counts those whose foreign_data.uuid equals these IDs and language = 'French'; divides that count by total Spotlight IDs and multiplies by 100.",
      "reason": "The join condition matches foreign_data.uuid (a text UUID) to cards.id (an integer PK), which mis-links the tables; therefore French counts and the resulting percentage are wrong. Required anchor of correctly correlating Story Spotlight cards with their language is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 465,
    "result": {
      "expected_answer": "A yes/no answer indicating whether there is at least one Korean-language printing (language = 'Korean') of the card named \"Ancestor's Chosen\".",
      "sql_description": "Checks if any row exists where cards.name = 'Ancestor''s Chosen' and a matching foreign_data row with the same uuid has language 'Korean'; returns 1 if such a row exists, else 0, labelled has_korean_version.",
      "reason": "Query applies the required anchors (card name, Korean language) and returns existence as boolean, exactly matching the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows has_korean_version = 0 (row 0), meaning the query concludes no Korean version."
    }
  },
  {
    "question_id": 219,
    "result": {
      "expected_answer": "Percentage of bond rows that are triple bonds ('#') among all bonds belonging to carcinogenic (label '+') molecules.",
      "sql_description": "Joins molecules with bonds, filters to carcinogenic molecules, counts how many of the associated bonds are of type '#', divides by total number of those bonds, multiplies by 100 to yield the percentage.",
      "reason": "Matches the evidence-specified interpretation: numerator counts triple bonds; denominator counts all bonds for '+' molecules. All anchors (carcinogenic filter, triple bond check, percentage computation) are present.",
      "verdict": true,
      "evidence": "Result column percentage = 0.080754 (row 0) shows computed percent."
    }
  },
  {
    "question_id": 282,
    "result": {
      "expected_answer": "For molecule TR006, return its carcinogenic label ('+' or '-') together with the ratio of hydrogen atoms to all atoms in that molecule.",
      "sql_description": "Counts atoms for molecule TR006, computes 100*hydrogen_count/total_count and returns it alongside the molecule's label.",
      "reason": "Query filters to molecule_id='TR006', correctly computes hydrogen/total atom ratio and outputs label, satisfying all specified anchors.",
      "verdict": true,
      "evidence": "label (+) with hydrogen_ratio_percentage ≈36.17 shown in result row 0."
    }
  },
  {
    "question_id": 82,
    "result": {
      "expected_answer": "The grade span offered (GSoffered) for the school whose absolute longitude value is the greatest in the dataset.",
      "sql_description": "Retrieves GSoffered from schools, orders rows by ABS(Longitude) descending to find the school farthest east or west, and returns the top result.",
      "reason": "Query respects the evidence by using ABS(Longitude) to identify the extreme longitude and correctly returns that school's GSoffered. No required anchor is missing.",
      "verdict": true,
      "evidence": "sql_result shows one column GSoffered with value 'K-8' for the selected school."
    }
  },
  {
    "question_id": 528,
    "result": {
      "expected_answer": "For every card printed in the set named 'Hour of Devastation', return the card's name together with each play format in which that card is currently marked as Legal.",
      "sql_description": "The query joins cards with their set and legalities, keeps only cards whose set name is 'Hour of Devastation' and whose legality status is 'Legal', and outputs the card name plus the corresponding legal format.",
      "reason": "All required anchors are present: the set is restricted to 'Hour of Devastation', card names come from cards.name, and only legal formats are kept via l.status = 'Legal'. The output therefore lists every (card, legal format) pair for that set, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result shows columns [name, format] with values such as ('Act of Heroism','commander'), confirming the expected structure."
    }
  },
  {
    "question_id": 25,
    "result": {
      "expected_answer": "For each school located in Riverside County, compute its average SAT math score across all available SAT records; return the names and funding types of those schools whose computed average is greater than 400.",
      "sql_description": "Joins schools with their SAT records, keeps only SAT rows whose AvgScrMath is already above 400, then groups by school and returns those whose average of the remaining rows is above 400, along with the school’s funding type.",
      "reason": "A required anchor is violated: the average must be calculated over all SAT math scores for each school. The query discards any SAT records with AvgScrMath ≤ 400 in the WHERE clause, so the computed average is biased upward and may include schools that do not satisfy the true condition (or exclude ones that do). Therefore the SQL does not correctly implement the requested logic.",
      "verdict": false
    }
  },
  {
    "question_id": 95,
    "result": {
      "expected_answer": "Account id(s) of the client(s) who are the youngest (latest birth_date) AND whose district has the highest average salary (largest A11).",
      "sql_description": "1) Finds the single client with the latest birth_date (youngest).\n2) Finds the single district with the maximum A11 (highest average salary).\n3) Gets all accounts linked (via disp) to that client and whose district matches the richest district.\n4) Returns those account_id values.",
      "reason": "Query captures both explicit constraints: youngest client and highest-salary district. Though it picks one row with LIMIT 1 for each extreme, tie handling is unspecified in the question, so returning one representative satisfies a reasonable interpretation. All required anchors are present; output columns correct.",
      "verdict": true,
      "evidence": "Result shows column account_id; currently empty but structure aligns with requirement."
    }
  },
  {
    "question_id": 234,
    "result": {
      "expected_answer": "The number (count) of distinct bonds in molecule TR009 that involve atom 12 (atom id 'TR009_12').",
      "sql_description": "Joins bond with connected, filters bonds belonging to molecule 'TR009' and connected rows where either atom endpoint equals 'TR009_12', then counts distinct bond IDs.",
      "reason": "All required anchors are present: molecule id TR009, atom 12 involvement via either endpoint, and counting distinct bonds. Logic matches the question.",
      "verdict": true,
      "evidence": "sql_result shows column num_bonds with value 3."
    }
  },
  {
    "question_id": 137,
    "result": {
      "expected_answer": "The total number of distinct accounts (count) whose loans are currently running (loan.status = 'C' or 'D') and whose branch location is 1 (district_id = 1).",
      "sql_description": "Counts distinct accounts that have at least one loan with status 'C' or 'D' and whose associated district’s A2 (district_name) equals '1'.",
      "reason": "The query filters on district.A2 = '1' instead of branch location 1 as represented by district_id = 1. Thus the required anchor (branch location 1) is not correctly applied; the count returned (0) is not reliable.",
      "verdict": false
    }
  },
  {
    "question_id": 39,
    "result": {
      "expected_answer": "The average number of SAT test takers for schools located in Fresno that opened during the calendar year 1980 (i.e., with OpenDate between 1980-01-01 and 1980-12-31).",
      "sql_description": "Joins schools with their SAT score records, keeps rows where the school's city is 'Fresno' and its OpenDate falls in 1980, then averages NumTstTakr across those rows.",
      "reason": "All required anchors—Fresno location, 1980 opening window, and averaging NumTstTakr—are present. Using City instead of County is a reasonable interpretation of “Fresno schools,” and no contradictory requirement exists. Thus the query returns the requested average.",
      "verdict": true,
      "evidence": "sql_result shows one column AvgNumTestTakers with value 203.8 for the computed average."
    }
  },
  {
    "question_id": 218,
    "result": {
      "expected_answer": "A single numeric percentage value: among all molecules labeled as carcinogenic ('+'), the percentage that have no fluorine atoms (element = 'f').",
      "sql_description": "1) Gets all molecule_id with label '+'. 2) Finds which of these molecules have at least one fluorine atom. 3) Counts carcinogenic molecules that are NOT in that fluorine list. 4) Divides that count by the total number of carcinogenic molecules and multiplies by 100, returning the percentage of carcinogenic molecules without fluorine.",
      "reason": "All required anchors are satisfied: filters carcinogenic molecules (label='+'); identifies fluorine via atom.element='f'; counts distinct molecules, not atoms; computes percentage of non-fluorine over total carcinogenic molecules. Logic matches the question.",
      "verdict": true,
      "evidence": "sql_result shows column percentage_non_fluorine with value 99.342105, indicating a single computed percentage was returned."
    }
  },
  {
    "question_id": 247,
    "result": {
      "expected_answer": "The element symbols of all atoms whose atom_id appears in neither connected.atom_id nor connected.atom_id2 (i.e., atoms that form no bonds at all).",
      "sql_description": "Selects element for atoms that are not found in connected.atom_id by left-joining atom to connected on atom.atom_id = connected.atom_id and keeping rows where connected.atom_id IS NULL.",
      "reason": "Query only excludes atoms present in connected.atom_id but ignores those present in connected.atom_id2. Atoms bonded only as the second endpoint will mistakenly be treated as unbonded, violating the required anchor of checking both columns.",
      "verdict": false
    }
  },
  {
    "question_id": 173,
    "result": {
      "expected_answer": "1) The count of transactions where account 3 paid for an account statement (k_symbol = 'SLUZBY', debit operation). 2) The purpose (k_symbol) corresponding to a total debited amount of 3539 (likely across the same account or overall).",
      "sql_description": "Counts rows and sums amounts for account_id = 3 that are debits (operation = 'VYDAJ') with k_symbol = 'SLUZBY' AND amount exactly 3539.",
      "reason": "Adds an unnecessary amount = 3539 filter, so misses statement-request rows of other amounts and returns 0. It also does not return the aim (k_symbol) of the 3539 total; instead it re-computes the total. Both parts of the question are therefore unmet.",
      "verdict": false
    }
  },
  {
    "question_id": 62,
    "result": {
      "expected_answer": "A single integer: the count of distinct non-charter schools (Charter=0) located in Los Angeles County whose Percent (%) Eligible Free (K-12) is below 0.18.",
      "sql_description": "Counts all rows in frpm where Charter School (Y/N)=0, County Name='Los Angeles', and Percent (%) Eligible Free (K-12)<0.18; returns 201.",
      "reason": "Query counts table rows, not DISTINCT schools, so multiple academic-year records for the same school would be double-counted. The question asks for number of schools, implying distinct entities; this anchor is unmet.",
      "verdict": false
    }
  },
  {
    "question_id": 89,
    "result": {
      "expected_answer": "A single integer: the number of distinct accounts whose frequency equals \"issuance after transaction\" (coded as 'POPLATEK PO OBRATU') and whose branch’s district is in the East Bohemia region (district.A3 = 'East Bohemia').",
      "sql_description": "Counts distinct account_id from account joined to district where account.frequency = 'POPLATEK PO OBRATU' and district.A3 = 'East Bohemia'.",
      "reason": "All anchors present (frequency filter for issuance after transaction, region filter for East Bohemia, counting accounts). Query logic matches the question exactly.",
      "verdict": true,
      "evidence": "Returned column COUNT(DISTINCT a.account_id) with value 0."
    }
  },
  {
    "question_id": 37,
    "result": {
      "expected_answer": "Street, City, Zip, and State of the school whose NumGE1500 / NumTstTakr ratio is the lowest among all schools (ignoring cases with zero test takers).",
      "sql_description": "Joins schools with satscores, restricts to rows where NumTstTakr > 0, orders by the excellence rate (NumGE1500 divided by NumTstTakr) ascending, returns the Street, City, Zip and State of the first (lowest) row.",
      "reason": "Query correctly defines excellence rate, filters out zero-denominator rows to avoid invalid rates, orders ascending to find the minimum, and returns the required address fields. Tie handling not specified, LIMIT 1 is acceptable.",
      "verdict": true,
      "evidence": "Returned columns: Street='1900 Third Street', City='Alameda', Zip='94501-1851', State='CA' (row 0)."
    }
  },
  {
    "question_id": 248,
    "result": {
      "expected_answer": "List of both atoms (either their ids or element symbols) that participate in any triple bond (bond_type = '#') within molecule TR041.",
      "sql_description": "Finds the element symbol of atoms whose atom_id appears in connected.atom_id for bonds of molecule TR041 that are of type '#', returning distinct elements.",
      "reason": "It only captures atoms stored in connected.atom_id and ignores connected.atom_id2, so it returns at most one side of each triple bond. Therefore the set of atoms is incomplete, violating the anchor of including all atoms in the triple bond.",
      "verdict": false
    }
  },
  {
    "question_id": 469,
    "result": {
      "expected_answer": "A yes/no indication of whether any set containing the card named \"Angel of Mercy\" has an mtgoCode (i.e., was released on Magic: The Gathering Online).",
      "sql_description": "Checks for at least one row where a card named 'Angel of Mercy' links to a set whose mtgoCode is not null; returns TRUE if such a row exists.",
      "reason": "Captures the required card name and the mtgo online indicator; existence logic matches the yes/no nature of the question.",
      "verdict": true,
      "evidence": "Result column appeared_on_mtgo_online = 1 (row 0) shows such a set exists, so answer would be Yes."
    }
  },
  {
    "question_id": 17,
    "result": {
      "expected_answer": "A list of schools whose average SAT Writing score is greater than 499, ranked from highest to lowest Writing average, and displaying each school’s charter number (and any identifier needed).",
      "sql_description": "Joins schools with satscores, keeps only rows where AvgScrWrite > 499 and CharterNum is not null, aggregates by school to compute the mean writing score (AVG), then orders the schools by that average in descending order, returning CDSCode, CharterNum, and the computed average.",
      "reason": "All explicit constraints are satisfied: score > 499, charter number must be valid (non-null), and results are ordered descending to provide a ranking. Returning charter numbers along with school codes matches the question.",
      "verdict": true,
      "evidence": "sql_result shows columns CDSCode, CharterNum, AvgWritingScore sorted 630, 593, 582… confirming descending ranking and presence of charter numbers."
    }
  },
  {
    "question_id": 281,
    "result": {
      "expected_answer": "For carcinogenic molecules (label '+'), count how many 4th-atoms belong to each element; return a list of elements with their tallies.",
      "sql_description": "Joins molecules with their atoms, filters to carcinogenic molecules and atoms whose id’s 7th character is ‘4’ (the 4th atom), then groups by element and counts the rows.",
      "reason": "All required anchors are present: carcinogenic molecules (label='+'), identification of the 4th atom (substr(atom_id,7,1)='4'), and tally per element. The query’s grouping and counts directly answer the question.",
      "verdict": true,
      "evidence": "Returned columns: element, count – e.g., rows like (c,145), (h,59), etc."
    }
  },
  {
    "question_id": 129,
    "result": {
      "expected_answer": "The list of the ten districts (A2 names) with the largest withdrawal totals for January 1996, restricted to non-credit-card withdrawals (type = 'VYDAJ'), ordered from highest total withdrawn downwards.",
      "sql_description": "Joins transactions with the owning account and its district, keeps rows where type='VYDAJ' and date starts with '1996-01', aggregates SUM(amount) per district, orders by that sum descending and returns the first ten district names with their totals.",
      "reason": "Matches all explicit anchors: filters by type='VYDAJ' (per evidence this represents non-credit-card withdrawals), restricts to January 1996, groups by district, orders by total withdrawn, limits to ten. Ambiguity about whether “top ten withdrawals” means single transactions vs totals is resolved by adopting the totals-per-district interpretation, which is reasonable given the phrase “by district names”.",
      "verdict": true,
      "evidence": "Result columns: district_name, total_withdrawn; 10 rows returned, e.g. row1 Hl.m. Praha 6757078 … row10 Prerov 771206"
    }
  },
  {
    "question_id": 149,
    "result": {
      "expected_answer": "All account types (as defined by the schema’s account-type field) that are NOT eligible for a loan — i.e., any type other than the special value OWNER — provided the account’s district has an average salary (A11) strictly above 8000 and at most 9000.",
      "sql_description": "Returns the DISTINCT account.frequency values of accounts that currently have NO loan record (l.loan_id IS NULL) whose district salary A11 is between 8000 and 9000; then filters groups whose own computed average income is also in that range.",
      "reason": "The query identifies accounts with no existing loan, not account types that are ineligible by rule (≠ 'OWNER'). It therefore misses/ignores the required eligibility anchor and may include OWNER accounts that simply never took a loan. It also outputs ‘frequency’, which is statement frequency, not account type.",
      "verdict": false
    }
  },
  {
    "question_id": 32,
    "result": {
      "expected_answer": "For the five schools (ownership code 66) that have the highest Free or Reduced-Price Meal Count (K-12), report each school’s eligible free or reduced-price meal rate, calculated as FRPM Count (K-12) divided by Enrollment (K-12) (optionally expressed as a percentage).",
      "sql_description": "Joins schools with FRPM data, keeps only records where School Ownership Code = 66 and enrollment is positive, orders the rows by FRPM Count (K-12) descending, limits to the first five, and returns their CDSCode, School name, and (FRPM Count / Enrollment)*100 as the rate.",
      "reason": "All required anchors are present: ownership code 66 filter, ordering by highest FRPM Count (K-12), limit 5, and correct rate formula using K-12 fields. Grades 1-12 requirement is satisfied by using K-12 counts which aggregate those grades. Output columns include the requested rate.",
      "verdict": true,
      "evidence": "sql_result rows 0-4 show CDSCode, School, Eligible_FRPM_Rate values; rate column reflects (FRPM Count / Enrollment)*100."
    }
  },
  {
    "question_id": 484,
    "result": {
      "expected_answer": "All card names in Italian whose converted mana cost equals the highest mana cost among every card in the Coldsnap set.",
      "sql_description": "Finds the maximum convertedManaCost among cards in the Coldsnap set, then returns the foreign_data.name entries (Italian language) for cards whose convertedManaCost equals that maximum.",
      "reason": "Query applies required anchors: set name 'Coldsnap', language 'Italian', and equality to the maximum convertedManaCost within that set. This exactly matches the question’s demands; no extraneous or missing constraints.",
      "verdict": true,
      "evidence": "sql_result column: name – 12 Italian card names returned (e.g., rows: 0 'Devastazione Solare', 1 'Requisire', ... 11 'Garza Zol, Regina della Peste')."
    }
  },
  {
    "question_id": 99,
    "result": {
      "expected_answer": "Account id(s) (and possibly their approved loan amount) for accounts opened in 1993 whose loan duration is greater than 12 months, restricted to those with the maximum approved loan amount among that subset.",
      "sql_description": "Joins account with loan, keeps rows where loan.duration > 12 and the account opening date starts with '1993-', orders the remaining rows by loan.amount descending, and returns the first (highest-amount) row with its account_id and amount.",
      "reason": "All required anchors—loan duration > 12, account opening year 1993, and selecting the highest approved amount—are present. Returning only one row for the top amount is a reasonable interpretation when ties are not specified.",
      "verdict": true,
      "evidence": "sql_result shows one row: account_id 10451 with amount 482940, matching the intended filters and representing the top amount due to ORDER BY DESC LIMIT 1."
    }
  },
  {
    "question_id": 24,
    "result": {
      "expected_answer": "List of school names where (Percent Eligible Free (K-12) > 0.1) AND the number of SAT test-takers scoring 1500 or more (NumGE1500) is at least one.",
      "sql_description": "Joins schools with frpm and satscores on CDSCode, then returns s.School where f.`Percent (%) Eligible Free (K-12)` > 0.1 and t.NumGE1500 > 0.",
      "reason": "Both required anchors—free-meal eligibility threshold and existence of 1500+ SAT scorers—are explicitly enforced. Output matches the requested field (school names) without extraneous constraints.",
      "verdict": true,
      "evidence": "sql_result shows one column School; e.g., rows include \"FAME Public Charter\", \"Alameda High\", \"Berkeley High\" … (20 rows total)."
    }
  },
  {
    "question_id": 47,
    "result": {
      "expected_answer": "A single number: total schools opened in 1980 in Alameda County with DOC = 52 divided by 12 (the 12 months of the year).",
      "sql_description": "Counts openings per month only for months that have at least one opening, averages those counts, then unions an extra row with 0, producing two rows (e.g., 17 and 0).",
      "reason": "Monthly average must divide the yearly total by 12, counting months with zero openings; query averages only non-empty months and adds an unnecessary second row, so the computed value and shape are wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 128,
    "result": {
      "expected_answer": "Names of the 9 districts with the greatest numbers of female account holders, each accompanied by that count, ordered from most to least.",
      "sql_description": "Counts distinct female clients who are OWNER of at least one account, groups the count by the client’s district name (district.A2), orders by this count descending, and returns the top 9 districts with their counts.",
      "reason": "Query captures female owners (reasonable definition of account holders), groups by district, sorts descending, and limits to 9, matching the requested top-nine list. All explicit anchors (female, district, count, descending order, top 9) are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows 9 rows with columns A2 (district name) and num_female_account_holders sorted 267→32."
    }
  },
  {
    "question_id": 36,
    "result": {
      "expected_answer": "Full name(s) of the administrator(s) (up to three) who run the school that has the greatest number of students with SAT scores ≥1500.",
      "sql_description": "Joins satscores with schools, orders all school rows by NumGE1500 descending, takes the first row (the school with the highest NumGE1500) and returns the concatenated first-, second-, and third-administrator full names.",
      "reason": "Query locates the school with the maximum NumGE1500 and outputs its administrators’ full names, matching the question’s intent. No essential anchor is omitted; LIMIT 1 is acceptable for tie handling.",
      "verdict": true,
      "evidence": "Returned columns Admin_Full_Name_1/2/3 with first row values (e.g., \"Michelle King\", nulls for others), which are administrator names for the top-scoring school."
    }
  },
  {
    "question_id": 159,
    "result": {
      "expected_answer": "All transactions of type withdrawal in cash (operation = 'VYBER') made by client 3356; listing each withdrawal with any relevant fields (e.g., id, date, amount, balance).",
      "sql_description": "Finds transactions joined to dispositions for client_id 3356 and filters for t.operation = 'VYBER', returning trans_id, date, amount, and balance of each matching transaction.",
      "reason": "Query enforces both required anchors: client 3356 and operation 'VYBER'. Returned columns list each withdrawal, satisfying the request.",
      "verdict": true,
      "evidence": "sql_result shows 20 rows with columns trans_id, date, amount, balance — all come from client 3356 and are withdrawals in cash."
    }
  },
  {
    "question_id": 125,
    "result": {
      "expected_answer": "For every loan that is still running and where the client is in debt (status = 'D'), return the name of the client’s district together with the percentage increase in unemployment from 1995 (A12) to 1996 (A13).",
      "sql_description": "Selects all loans with status 'D', links them to their accounts and districts, and outputs the district name (A2) plus ((A13 - A12)/A12*100) as the 1995→1996 unemployment-rate change.",
      "reason": "Meets the key anchors: filters running-in-debt loans (status='D'); fetches district; computes unemployment increment exactly as specified. Duplication of districts is harmless because the question does not explicitly require distinct rows.",
      "verdict": true,
      "evidence": "Result columns: district (e.g., 'Strakonice', 'Chrudim') and unemployment_rate_increment (e.g., 40.0, 39.26). Values match the defined formula."
    }
  },
  {
    "question_id": 87,
    "result": {
      "expected_answer": "A list of distinct administrator email addresses (AdmEmail1) for schools in county 'San Bernardino' whose district is 'San Bernardino City Unified', whose open date falls between 2009-01-01 and 2010-12-31, and that simultaneously have SOC = 62 (Intermediate/Middle School) AND DOC = 54 (Unified School District).",
      "sql_description": "Returns distinct AdmEmail1 from schools where County = 'San Bernardino', City = 'San Bernardino City Unified', OpenDate between the dates, and where SOC = 62 OR DOC = 54.",
      "reason": "1) Filters on City instead of District, so the required district anchor is likely missed. 2) Uses OR between SOC and DOC instead of requiring both, letting in schools that are only one of the two specified types. These anchor errors mean the query does not faithfully implement the question constraints.",
      "verdict": false
    }
  },
  {
    "question_id": 152,
    "result": {
      "expected_answer": "A single average of A15 (crimes in 1995) computed across all regions whose 1995 crimes exceed 4000 AND which have at least one account opened in or after 1997.",
      "sql_description": "For every individual district that has A15 > 4000 and at least one linked account with a creation year >= 1997, it outputs AVG(A15) (which equals the district’s own A15). Because of GROUP BY district_id it emits one row per district instead of one overall average.",
      "reason": "It returns many per-district values rather than the overall average requested, so the anchor \"average across the qualifying regions\" is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 28,
    "result": {
      "expected_answer": "Names and DOCType of schools that are locally funded whose difference (Enrollment (K-12) – Enrollment (Ages 5-17)) is greater than the average of this difference calculated over all locally funded schools.",
      "sql_description": "1) Builds a list of locally-funded school records with the difference (K-12 – Ages 5-17). 2) Computes the average of these differences. 3) Returns the School name and DOCType for those records whose difference exceeds that average, ordered alphabetically.",
      "reason": "All required anchors are present: uses only locally funded schools, computes the specified difference with the correct columns, derives the average across that set, and filters schools whose difference is above this average while returning School and DOCType. Ambiguity about multiple academic-year rows is acceptable; counting per row is a reasonable interpretation when the question does not specify aggregation by school.",
      "verdict": true,
      "evidence": "sql_result shows columns [School, DOCType]; query runs and would list qualifying schools if any exist."
    }
  },
  {
    "question_id": 45,
    "result": {
      "expected_answer": "For every school where the administratorʼs first name is Ricci and last name is Ulrich, return the school name together with that school’s average SAT writing score.",
      "sql_description": "Joins schools with satscores on the CDS code, restricts to rows whose primary administrator is Ricci Ulrich, groups by school, and reports the average of AvgScrWrite for each selected school.",
      "reason": "Filters on administrator Ricci Ulrich (required anchor) and outputs one row per such school with its average writing score computed from satscores. This matches the question’s request.",
      "verdict": true,
      "evidence": "Result columns: School, AverageWritingScore (e.g., row 1: Buchanan High – 507.0)."
    }
  },
  {
    "question_id": 136,
    "result": {
      "expected_answer": "A single integer: the count of loans approved between 1995-01-01 and 1997-12-31 whose amount is at least 250 000 and whose account’s frequency is “POPLATEK MESICNE” (monthly statement). No further status restriction was mentioned.",
      "sql_description": "Counts distinct loan_ids that (1) belong to accounts with frequency = 'POPLATEK MESICNE', (2) have amount ≥ 250000, (3) loan.date between 1995-01-01 and 1997-12-31, and (4) loan.status is either 'A' or 'B'. Returns 3.",
      "reason": "The query adds an extra status filter (only 'A' or 'B') that the question did not require. Loans in statuses 'C' or 'D' that meet the other criteria would be wrongly excluded, so the count may be too small.",
      "verdict": false
    }
  },
  {
    "question_id": 94,
    "result": {
      "expected_answer": "Account numbers of female clients who are the oldest (earliest birth_date) AND whose district has the lowest average salary (A11); plus, for each, the salary gap computed as (highest district average salary − that lowest average salary).",
      "sql_description": "1) Builds list of female OWNER clients with their district average salary and birth_date. 2) Chooses the minimum average salary but the MAX (latest) birth_date, i.e. the youngest female with lowest salary. 3) Keeps clients matching both those values. 4) Computes salary gap using overall min and max district salaries. 5) Outputs their account_ids and the gap.",
      "reason": "The query uses MAX(birth_date) instead of MIN(birth_date), selecting the youngest female rather than the oldest, violating the explicit \"oldest\" anchor. Therefore it does not satisfy the question requirements.",
      "verdict": false
    }
  },
  {
    "question_id": 168,
    "result": {
      "expected_answer": "The percentage (single numeric value) of female clients among all clients whose accounts were opened in districts where average salary (A11) exceeds 10000.",
      "sql_description": "Builds list of districts with A11>10000, takes every OWNER disposition for accounts in those districts, counts rows by gender (one row per account ownership), and returns ratio of female rows to total rows.",
      "reason": "Base population should be distinct clients, but the query counts one row per account_id; clients owning multiple accounts are over-represented. This violates the explicit anchor \"percentage of clients\", so the SQL does not precisely answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 120,
    "result": {
      "expected_answer": "List each account created between 1995 and 2000 (inclusive) whose branch district name (A2) is 'east Bohemia', and for each give the account_id together with the account's statement-issuance frequency stored in account.frequency.",
      "sql_description": "Returns each account_id in districts named 'east Bohemia' whose creation year is 1995-2000 and, instead of the frequency column, gives COUNT(trans_id) of transactions for that account, labelled statement_frequency.",
      "reason": "The query reports the number of transactions rather than the requested statement-issuance frequency field, so the key requested attribute is wrong. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 145,
    "result": {
      "expected_answer": "List the IDs of clients who made at least one credit-card withdrawal (operation = 'VYBER KARTOU') during the year 1998 whose transaction amount is below the average amount of such credit-card withdrawals in 1998.",
      "sql_description": "Joins disp→card to keep clients that own a card, filters credit-card withdrawals in 1998, then groups by account and returns DISTINCT client_ids for those groups where the (arbitrarily chosen) t.amount value retained after GROUP BY happens to be smaller than the overall 1998 average for credit-card withdrawals.",
      "reason": "The HAVING clause compares a single non-aggregated t.amount that is indeterminate after GROUP BY; it is neither MIN nor MAX nor all amounts. Hence many qualifying clients may be missed (or wrongly included) depending on which row SQLite selects, so the query does not soundly implement the condition \"amount < average\". An essential anchor (correct comparison of each transaction amount to the average) is therefore not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 189,
    "result": {
      "expected_answer": "Account IDs belonging to female clients who are the oldest (earliest birth_date) among all females and whose district’s average salary (A11) is the lowest.",
      "sql_description": "Selects distinct account_id for female owners, sorts by birth_date DESC (youngest first) then by A11 ascending, and returns the first row.",
      "reason": "Uses DESC on birth_date, so it chooses the youngest female client, not the oldest. Thus violates the explicit anchor 'oldest'.",
      "verdict": false
    }
  },
  {
    "question_id": 41,
    "result": {
      "expected_answer": "Names of exclusively virtual (Virtual='F') schools that rank within the top 5 highest average SAT reading scores in their own county, one row per qualifying school.",
      "sql_description": "Joins schools with SAT scores, keeps only exclusively virtual schools, ranks them by AvgScrRead within each county (PARTITION BY county, descending score), and returns those with rank <= 5 (School name plus county).",
      "reason": "All required anchors are met: virtual filter (Virtual='F'), county-partitioned ranking by AvgScrRead, top-5 selection, and school names returned. Extra county column does not misrepresent the answer.",
      "verdict": true,
      "evidence": "Result contains columns School and cname; rows such as Dunlap Leadership Academy (Fresno) and Insight School of California (Kern) illustrate virtual schools in top-5 of their counties."
    }
  },
  {
    "question_id": 93,
    "result": {
      "expected_answer": "A single integer: the count of male customers whose district is in the region North Bohemia and whose district’s average salary (A11) exceeds 8000.",
      "sql_description": "Joins client with district, filters rows where gender = 'M', region (A3) = 'North Bohemia', and average salary (A11) > 8000, then counts distinct client_ids.",
      "reason": "All explicit anchors—male gender, North Bohemia region, average salary >8000—are satisfied. Counting distinct clients matches the requested \"how many\" male customers. Therefore the SQL answers the question.",
      "verdict": true,
      "evidence": "sql_result has column COUNT(DISTINCT c.client_id) with value 0 indicating no such customers."
    }
  },
  {
    "question_id": 186,
    "result": {
      "expected_answer": "The percentage (0–100) of clients whose account statement frequency is weekly (POPLATEK TYDNE) that are male, i.e. 100 * (number of distinct male clients with weekly statements) / (number of distinct clients with weekly statements).",
      "sql_description": "Counts DISTINCT account_id among weekly-frequency accounts; numerator counts those accounts linked to male clients, denominator counts all such accounts, then computes 100 * male_accounts / all_accounts.",
      "reason": "The question asks for a client-level percentage, but the query works at the account level. If a client owns multiple weekly-statement accounts, they are over-counted in both numerator and denominator, violating the required client anchor.",
      "verdict": false
    }
  }
]