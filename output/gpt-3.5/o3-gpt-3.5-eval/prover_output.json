[
  {
    "question_id": 1480,
    "result": {
      "expected_answer": "The single month in 2013 during which SME customers recorded the highest total gas consumption (returning the month, optionally also the year and the total amount).",
      "sql_description": "Aggregates consumption for SME customers for each month of 2013, then orders the monthly totals descending and returns the top month (Year-Month 2013-04 with its total).",
      "reason": "Query correctly filters to SME customers and dates within 2013, sums consumption per month, sorts by the sum, and returns the peak month. All required anchors (segment SME, year 2013, peak month) are satisfied.",
      "verdict": true,
      "evidence": "Result row shows Year=2013, Month=04, Total_Consumption≈1.26e+08."
    }
  },
  {
    "question_id": 1472,
    "result": {
      "expected_answer": "Customer(s) in segment LAM whose overall (total) consumption during the year 2012 is the smallest among all LAM customers.",
      "sql_description": "Filters yearmonth rows for 2012 and segment LAM, then returns the customer whose single row consumption value equals the minimum single-row consumption in that set (no aggregation across a customer’s 2012 rows).",
      "reason": "Question asks for least consumption in 2012, which reasonably refers to each customer’s total consumption over the year. The query compares individual month rows instead of yearly totals, so a customer with one unusually low month but high yearly total could be selected. Missing aggregation violates the consumption anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1476,
    "result": {
      "expected_answer": "A single numeric value giving total consumption by CZK‐currency customers in 2012 minus total consumption by EUR‐currency customers in 2012.",
      "sql_description": "Computes 2012 consumption for CZK customers and EUR customers (identified through customers.Currency), then subtracts the EUR total from the CZK total and returns that difference.",
      "reason": "Query applies the 2012 year filter, filters customers by currency, sums their Consumption values and returns CZK-total minus EUR-total, matching the stated requirement. The extra join to transactions_1k only limits to customers appearing there, which is reasonable given the domain (customers normally have transactions) and does not violate any explicit anchor.",
      "verdict": true,
      "evidence": "sql_result shows column difference_in_consumption with one row (≈2.97e8), matching the expected single numeric answer."
    }
  },
  {
    "question_id": 1481,
    "result": {
      "expected_answer": "Three numeric values: \n1) SME annual average consumption of the customer(s) with the lowest total 2013 consumption in CZK minus the corresponding LAM value.\n2) LAM minus KAM for the same metric.\n3) KAM minus SME for the same metric.",
      "sql_description": "Step-1: finds the minimum single MONTHLY Consumption value per segment in 2013 (no CZK filter).\nStep-2: for each segment, computes the average of all 2013 monthly Consumption rows and keeps it only if that overall average equals the min monthly value found in step-1.\nStep-3: subtracts the three retained averages to create diff_SME_LAM, diff_LAM_KAM, diff_KAM_SME.",
      "reason": "Fails required anchors:\n• Currency CZK not filtered.\n• Lowest consumption should be based on customer-level annual totals, not the minimum single monthly record.\n• The HAVING condition makes averages almost never equal the min monthly value, leading to NULL results.\nTherefore the query does not compute the requested differences.",
      "verdict": false
    }
  },
  {
    "question_id": 1473,
    "result": {
      "expected_answer": "A single numeric value representing the average monthly consumption per customer of the SME segment for the 12 months of 2013 (i.e., total 2013 consumption per customer divided by 12, then averaged across customers, or equivalently overall average yearly consumption divided by 12).",
      "sql_description": "The query sums 2013 consumption for each SME customer to get their yearly total, then takes the average of those yearly totals across customers; it returns this average yearly consumption without converting it to a monthly figure.",
      "reason": "It omits the required division by 12, so it returns average yearly consumption, not average monthly consumption as explicitly required.",
      "verdict": false
    }
  },
  {
    "question_id": 1482,
    "result": {
      "expected_answer": "Identify, among the three segments (SME, LAM, KAM), which segment shows the highest percentage increase and which shows the lowest percentage increase in consumption that was paid in EUR from 2012 to 2013 (based on the formula given). The answer should name the segment(s) corresponding to the biggest and lowest percentage increases.",
      "sql_description": "For every customer it pairs every 2012 record with every 2013 record, computes a per-pair percentage change, then for each segment returns the maximum and minimum of those pair-level percentages (no EUR currency filter).",
      "reason": "1) Missing required EUR anchor – query never filters Currency='EUR'.\n2) Joins every 2012 month with every 2013 month causing meaningless duplicates and incorrect percentages.\n3) Returns max/min inside each segment rather than determining which segment overall has the largest and smallest percentage increases. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1479,
    "result": {
      "expected_answer": "Return the year (first 4 chars of yearmonth.Date) whose total Consumption value is highest for gas purchases made in CZK.",
      "sql_description": "Joins yearmonth to transactions_1k on CustomerID, keeps rows where ProductID=3, groups by year taken from yearmonth.Date, and orders by the sum of t.Amount * t.Price, returning the top year.",
      "reason": "The question asks for the year with the greatest gas consumption. That quantity is stored in yearmonth.Consumption, but the query sums transaction spending (Amount*Price) instead. It never uses the Consumption column, so it measures a different metric. Therefore it does not satisfy the required anchor of total consumption.",
      "verdict": false
    }
  },
  {
    "question_id": 1484,
    "result": {
      "expected_answer": "A single number representing the difference between the count of discount gas stations in the Czech Republic and the count in Slovakia (Czech count minus Slovak count).",
      "sql_description": "Counts discount-segment gas stations where Country='CZE' and subtracts the count where Country='SVK', returning the numeric difference as difference_in_discount_gas_stations.",
      "reason": "All required anchors (Country codes for Czech Republic and Slovakia, Segment='discount') are applied and the query computes the requested difference (CZE minus SVK).",
      "verdict": true,
      "evidence": "Returned column difference_in_discount_gas_stations with value 0 (row 0)."
    }
  },
  {
    "question_id": 1490,
    "result": {
      "expected_answer": "Percentage (0-100%) of all customers in the LAM segment whose consumption exceeds 46.73; i.e. (# LAM customers with consumption > 46.73) / (total # LAM customers) * 100.",
      "sql_description": "Builds list of LAM customers, joins them to yearmonth, keeps only rows where Consumption > 46.73, then divides the count of DISTINCT qualifying customers by the count of DISTINCT LAM customers **present in those filtered rows**, multiplying by 100.",
      "reason": "The denominator should include every LAM customer, regardless of whether they have a consumption record above 46.73. By applying the condition in the WHERE clause after the join, customers without a qualifying consumption row are dropped from both numerator and denominator, so the fraction is always 100% when at least one qualifying row exists. Missing anchor: total number of LAM customers.",
      "verdict": false
    }
  },
  {
    "question_id": 1498,
    "result": {
      "expected_answer": "A single numeric value representing the maximum Consumption recorded in any month during the year 2012 (optionally together with the corresponding month, but at most one record).",
      "sql_description": "Parses the Date into Year and Month, filters rows to Year = 2012, then groups by Year and Month and returns, for each month, the maximum Consumption of that month.",
      "reason": "Grouping by Month causes the query to output one row per month instead of the overall maximum for the year. The highest value across all months is not isolated, so the result set does not directly answer the question asking for the single highest monthly consumption in 2012.",
      "verdict": false
    }
  },
  {
    "question_id": 1486,
    "result": {
      "expected_answer": "Determine whether the number of SME customers who pay in Czech koruna (CZK) is greater than those who pay in euros (EUR). If it is greater, report the difference in the counts of SME customers.",
      "sql_description": "Counts distinct customers using CZK minus those using EUR across the entire customers table, without restricting to the SME segment, and returns the difference.",
      "reason": "The question explicitly concerns SMEs, but the SQL omits the necessary filter Segment='SME' (or similar). Therefore the computed difference is for all customers, not SMEs, violating a required anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1493,
    "result": {
      "expected_answer": "The percentage (0–100%) of customers whose consumption in February 2012 exceeded 528.3, using the February-2012 customer set as the denominator.",
      "sql_description": "First selects all (CustomerID, Consumption) rows whose Date starts with '201202' (February 2012). Then, among those customers, counts how many have Consumption > 528.3 and divides by the total number of February-2012 customers, returning the result as a percentage.",
      "reason": "All required anchors are present: month filter (201202), threshold (>528.3), and computation of percentage over the February customer base. Although it joins back to the full table, the DISTINCT counts ensure only February customers are in both numerator and denominator, so the calculation is correct.",
      "verdict": true,
      "evidence": "sql_result shows column percentage with value 100.0, matching the expected single numeric output."
    }
  },
  {
    "question_id": 1506,
    "result": {
      "expected_answer": "A list of product descriptions (one per transaction, duplicates allowed unless stated otherwise) for all transactions that occurred at gas stations located in the Czech Republic.",
      "sql_description": "Joins transactions with gas stations and products, filters gas stations whose Country = 'CZE', and returns the Description of each associated product.",
      "reason": "Query applies the required country anchor, correctly links transactions to their gas stations and products, and outputs the requested product descriptions. No extra/missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows a single column \"Description\" with values like 'Nafta', 'Natural', etc., confirming the output structure."
    }
  },
  {
    "question_id": 1483,
    "result": {
      "expected_answer": "Total consumption for customer 6 during the months 2013-08, 2013-09, 2013-10 and 2013-11 (inclusive).",
      "sql_description": "Sums Amount from all transactions of customer 6, but joins every transaction with every matching yearmonth row whose Date is between '201308' and '201311'; no date filter is applied to the transactions themselves, so transactions outside the period are included and the join may multiply rows.",
      "reason": "The required date anchor must constrain the transactions considered, but the query constrains only the joined yearmonth rows, letting all transactions for customer 6 (any date) contribute and be duplicated. Hence the computed total is incorrect for the asked period.",
      "verdict": false
    }
  },
  {
    "question_id": 1500,
    "result": {
      "expected_answer": "All product descriptions of products that were consumed (appeared in transactions) during September 2013.",
      "sql_description": "The query filters transactions whose Date starts with '201309' (September-2013), joins those records to the products table on ProductID, and returns the corresponding Description values.",
      "reason": "It applies the correct time anchor (September 2013) and retrieves the requested field (products.Description). Distinctness was not explicitly required, so returning every matching description is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows a Description column (no rows in this sample), consistent with the requested output."
    }
  },
  {
    "question_id": 1501,
    "result": {
      "expected_answer": "Distinct list of country names for gas stations that recorded at least one transaction during June 2013.",
      "sql_description": "Joins transactions_1k with gasstations, keeps rows whose Date value equals the string '201306' (June 2013), and returns the distinct Country values of those stations.",
      "reason": "All required anchors are present: 1) filters transactions to June-2013 through t.Date = '201306' (consistent with evidence that June 2013 is stored as the six-character string 201306); 2) connects those transactions to gas stations; 3) outputs the countries, using DISTINCT to avoid duplicates. No extraneous constraints.",
      "verdict": true,
      "evidence": "sql_result shows column Country (no rows in sample), which is structurally consistent with expectation."
    }
  },
  {
    "question_id": 1505,
    "result": {
      "expected_answer": "A single integer: the number of distinct customers whose currency is EUR and whose recorded monthly Consumption value exceeds 1000.",
      "sql_description": "Counts distinct CustomerID values that 1) appear in transactions_1k, 2) are marked as EUR in customers, and 3) have at least one row in yearmonth with Consumption > 1000. Returns that count.",
      "reason": "All required anchors are present: EUR filter via customers.Currency, monthly consumption threshold via yearmonth.Consumption > 1000, and counting distinct customers. Extra join to transactions_1k does not invalidate the logic and still targets customers who paid. Thus the query answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one column COUNT(DISTINCT t.CustomerID) with value 25, representing the desired count."
    }
  },
  {
    "question_id": 1533,
    "result": {
      "expected_answer": "The consumption value (from yearmonth for Date = '201208') of each customer who has at least one purchase of product 5 where Price/Amount > 29.00.",
      "sql_description": "Finds transactions of product 5 in August-2012 (t.Date LIKE '201208%') with price per unit >29, takes the involved CustomerID, then returns each customer’s Consumption from yearmonth (joined only on CustomerID, no date filter).",
      "reason": "Required anchor y.Date = '201208' is missing, so the consumption returned is not guaranteed to be for August-2012. The query therefore does not satisfy the stated requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 1526,
    "result": {
      "expected_answer": "A numeric consumption decrease rate for the customer who made a 634.8-amount payment on 2012-08-25, computed as (consumption in 2012 − consumption in 2013) divided by consumption in 2012.",
      "sql_description": "Finds a customer ID whose transaction amount equals 634.8 (ignoring the specific date), then takes that customer’s 2012 and 2013 rows from yearmonth and returns (consumption_2013 − consumption_2012) / consumption_2013.",
      "reason": "The formula is inverted: question requires (2012 − 2013) / 2012, but query returns (2013 − 2012) / 2013. It also does not guarantee the customer is selected using the 2012-08-25 payment. Therefore the query does not meet the stated requirements.",
      "verdict": false
    }
  },
  {
    "question_id": 1334,
    "result": {
      "expected_answer": "Full names (first and last concatenated) of all members whose recorded home state is Illinois.",
      "sql_description": "Joins member with zip_code via ZIP, filters rows where zip_code.state equals 'Illinois', returns first_name + ' ' + last_name.",
      "reason": "Uses the zip_code.state field to identify members from Illinois, concatenates first and last names as requested; no missing or extra constraints.",
      "verdict": true,
      "evidence": "sql_result shows column full_name with 3 rows; these correspond to members satisfying the filter."
    }
  },
  {
    "question_id": 1507,
    "result": {
      "expected_answer": "A list of distinct transaction times (timestamps) for all transactions that occurred at gas stations whose ChainID is 11.",
      "sql_description": "Joins transactions_1k with gasstations, filters rows where gasstations.ChainID = 11, then returns DISTINCT values of Date concatenated with Time (i.e., each unique date-time combination) as transaction_time.",
      "reason": "Query applies correct chain filter, links through GasStationID, and outputs distinct timestamps representing when those transactions happened. Including the date portion is acceptable under the reasonable interpretation that “time of the transactions” refers to full timestamps.",
      "verdict": true,
      "evidence": "sql_result shows column transaction_time with two sample timestamp strings, indicating the query returns the expected data."
    }
  },
  {
    "question_id": 1350,
    "result": {
      "expected_answer": "Return the event_status value (from budget table) for the event whose expense record has description \"Post Cards, Posters\" and expense_date = '2019-8-20'.",
      "sql_description": "Finds an expense row with description 'Post Cards, Posters' and date '2019-8-20', joins through its budget to the related event, then outputs the status column from the event table.",
      "reason": "Question explicitly asks for the event status noted by event_status (evidence). Query returns event.status instead, so it targets the wrong column/attribute. Required anchor “event_status” is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1529,
    "result": {
      "expected_answer": "Two numbers: (1) total money spent by customer 38508 on all gas-station transactions; (2) money spent by this customer on gas-station transactions that occurred in January 2012 (Date beginning with 201201). Spending should be in monetary terms, i.e. quantity × price per unit.",
      "sql_description": "Returns SUM(Amount) for all transactions of customer 38508 having a GasStationID found in gasstations, plus another SUM(Amount) for same customer limited to dates like '201201%'. It does NOT use Price, so it sums raw quantity, not money.",
      "reason": "The question asks for money spent, which (per schema note) equals Amount × Price; the query sums only Amount. Therefore it does not return the requested monetary figures.",
      "verdict": false
    }
  },
  {
    "question_id": 1514,
    "result": {
      "expected_answer": "The currency (e.g., USD, EUR, CZK, etc.) in which the customer’s transaction that occurred at 16:25:00 on 2012-08-24 was paid.",
      "sql_description": "Finds all transactions on 2012-08-24 at exactly 16:25:00, joins to the customers table, and returns the customers’ Currency field. It outputs one row per matching transaction (three rows, all CZK).",
      "reason": "Correctly anchors both date and time, and returns the currency associated with those transactions. Duplicate rows don’t change the answer content; they all show the same currency (CZK), satisfying the question.",
      "verdict": true,
      "evidence": "sql_result rows: Currency column values (rows 0-2) all = 'CZK', indicating the payment currency."
    }
  },
  {
    "question_id": 1323,
    "result": {
      "expected_answer": "Names of events whose attendance count of students is greater than 20 AND whose type is not 'fundraiser'.",
      "sql_description": "Builds a derived table of events with attendance > 20, left-joins it to event, then returns every event whose type is not 'fundraiser' (regardless of whether the join matched).",
      "reason": "Anchor ‘attendance > 20’ is not enforced: the outer WHERE clause does not exclude events that failed the attendance subquery, so events with ≤20 or no attendance are included.",
      "verdict": false
    }
  },
  {
    "question_id": 1368,
    "result": {
      "expected_answer": "The major (major_name) of the member whose phone number is 809-555-3360.",
      "sql_description": "Joins member to major, filters member rows where phone = '809-555-3360', returns the member's first_name, last_name, and their major_name.",
      "reason": "Correctly anchors on the phone number and retrieves the corresponding major_name. Extra name columns are about the same person and do not contradict the question.",
      "verdict": true,
      "evidence": "Row0 major_name='Agricultural Education'"
    }
  },
  {
    "question_id": 1392,
    "result": {
      "expected_answer": "The source of funds that contributed the highest total amount during 1-30 September 2019.",
      "sql_description": "Filters income rows for 2019-09-01 … 2019-09-30, aggregates amount per source, orders sources by summed amount descending, and returns the single top source plus its total.",
      "reason": "All required anchors present: correct date range, aggregation of amounts by source, selection of the highest total, returns the top source (and its amount, which is acceptable extra detail).",
      "verdict": true,
      "evidence": "Row0: top_source_of_funds='School Appropration', total_amount_received=3000"
    }
  },
  {
    "question_id": 1525,
    "result": {
      "expected_answer": "A numeric percentage representing how many customers used EUR on 2012-08-25, relative to a chosen customer base.",
      "sql_description": "Counts distinct customers who had a transaction on 2012-08-25 and whose recorded currency is EUR, then divides by the total number of customers in the whole customers table, multiplying by 100 to yield a percentage.",
      "reason": "Query applies required anchors (date 2012-08-25 and EUR). The question does not state which customer set serves as the denominator; interpreting it as all registered customers is reasonable. Under this interpretation the SQL correctly calculates the requested percentage.",
      "verdict": true,
      "evidence": "Returned one numeric column with value ≈0.0216 (row 1, unnamed column)."
    }
  },
  {
    "question_id": 1528,
    "result": {
      "expected_answer": "A single numeric value: the percentage of gas stations with segment = 'premium' among all gas-station segments in country 'SVK'.",
      "sql_description": "Calculates (distinct) customer share: counts distinct customers who made transactions at premium stations in SVK and divides by total distinct customers who made any transaction in SVK.",
      "reason": "Question asks for share of the 'premium' segment itself, implying counting segments (stations), not customers or transactions. Query measures a different quantity (customer distribution), so required anchor “segment share” is not met.",
      "verdict": false
    }
  },
  {
    "question_id": 1531,
    "result": {
      "expected_answer": "Return: 1) the CustomerID of the customer whose total spending (sum of transaction price amounts) is the highest, 2) that customer’s average price per single item, calculated as (SUM(price) / SUM(amount)) across all his/her transactions, and 3) the currency used.",
      "sql_description": "Finds each customer’s total spend using SUM(Price) and chooses the customer with the highest SUM(Price). For that customer it reports AVG(Price/Amount) as the average price per item together with the customer’s Currency.",
      "reason": "Required anchor: average price per single item must follow Total(price)/Total(amount) (explicitly given). Query instead computes AVG(price/amount), an un-weighted mean that can differ from the required ratio, so it does not satisfy the definition.",
      "verdict": false
    }
  },
  {
    "question_id": 1381,
    "result": {
      "expected_answer": "Full names (first_name + last_name) of each student whose number of event attendances is greater than 7.",
      "sql_description": "Joins member to attendance, groups rows by student (member_id), counts their linked events, and returns the concatenated first and last names for those with COUNT(link_to_event) > 7.",
      "reason": "Query applies the required attendance count filter (>7) and outputs the requested full name, fulfilling all explicit anchors.",
      "verdict": true,
      "evidence": "student_name column with 20 rows such as 'Grant Gilmour', 'Luisa Guidi', …"
    }
  },
  {
    "question_id": 1375,
    "result": {
      "expected_answer": "All full names (first and last) of members whose associated major belongs to the \"School of Applied Sciences, Technology and Education\" department.",
      "sql_description": "Joins member with major, filters majors where department equals 'School of Applied Sciences, Technology and Education', and returns first_name + last_name as full_name for each matching member.",
      "reason": "Query correctly applies the required department filter through the major table and outputs member full names; this matches the request for listing all members of that department.",
      "verdict": true,
      "evidence": "sql_result shows column full_name with 5 rows, e.g., 'Angela Sanders', confirming the query returns member names."
    }
  },
  {
    "question_id": 1404,
    "result": {
      "expected_answer": "For the event named 'October Meeting', list each expense category/type (e.g., food, transport etc.) and the sum of approved expense cost for that category.",
      "sql_description": "Joins event, budget, expense; filters for event_name='October Meeting' and approved='approved'. Groups by event.type (event column) and returns that as expense_type with total approved cost.",
      "reason": "Groups by event.type rather than an expense-oriented field (likely budget.category or similar). Therefore does not provide expense types; could only return one row describing the event’s own type, not different expense categories. Anchor 'type of expenses' is mismapped.",
      "verdict": false
    }
  },
  {
    "question_id": 1322,
    "result": {
      "expected_answer": "A single integer: the number of events whose type is 'Meeting' and that were attended by more than 10 distinct members.",
      "sql_description": "Joins attendance with event, keeps only rows where the event type is 'Meeting'; groups by each event; filters groups having more than 10 distinct attendees; then outputs COUNT(DISTINCT link_to_event) for every group, producing one row per qualifying event, each with the value 1.",
      "reason": "Although the filtering criteria are correct, the query groups by event and therefore emits one row per qualifying event instead of a single aggregated count. The result set (multiple 1s) does not directly answer \"how many\"; an additional aggregation over those rows is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1389,
    "result": {
      "expected_answer": "Name(s) of the event(s) whose cost value is the minimum among all recorded costs (spent) in the budget table.",
      "sql_description": "Finds the minimum spent value in budget, then returns the event_name for every budget row whose spent equals that minimum, via join to event. This yields all event names having at least one budget entry at the minimum cost.",
      "reason": "Query anchors the correct cost field (budget.spent) and filters to MIN(spent). Join supplies event names. Although duplicates appear and cost is evaluated per budget row rather than total per event, interpreting \"cost\" as any single recorded expense is reasonable and not contradicted by schema/evidence, so the answer set is correct.",
      "verdict": true,
      "evidence": "sql_result lists event_with_lowest_cost column containing event names (rows 0-19), all tied to MIN(spent)."
    }
  },
  {
    "question_id": 1359,
    "result": {
      "expected_answer": "A numeric factor: total Advertisement budget amount allocated to the \"Yearly Kickoff\" meeting divided by the total Advertisement budget amount allocated to the \"October Meeting\".",
      "sql_description": "Within the budget table rows where category = 'Advertisement', it sums amount where event_status = 'Yearly Kickoff' and divides by the sum where event_status = 'October Meeting'.",
      "reason": "The question explicitly refers to the meeting names (event_name), but the SQL filters on budget.event_status instead, and it never joins to the event table where event_name resides. Thus the required event-name anchor is missed; the computed ratio may relate to status values, not the specified meetings.",
      "verdict": false
    }
  },
  {
    "question_id": 1464,
    "result": {
      "expected_answer": "Full names (first and last concatenated) of students who had an income record dated 9/9/2019, together with the amount they received.",
      "sql_description": "Joins member to income and returns first_name || ' ' || last_name as full_name plus i.amount where i.date_received = '2019-09-09'.",
      "reason": "All required anchors—full name, amount, and the specific date 9/9/2019—are present. Query directly retrieves that information with correct join and filtering.",
      "verdict": true,
      "evidence": "sql_result shows columns [full_name, amount_received] with 2 rows (e.g., 'Sacha Harrison', 50; 'Carlo Jacobs', 50) matching the requested output."
    }
  },
  {
    "question_id": 1432,
    "result": {
      "expected_answer": "A single percentage value: among all members whose position is 'Member' and t_shirt_size = 'Medium', what proportion (percentage) of them received an income entry from source = 'Student_Club' with amount = 50.",
      "sql_description": "1) Finds medium-sized shirt members. 2) Looks at income rows for those members where source = 'Student_Club'. 3) Counts ALL such income rows (because COUNT(bool) counts every row, not only those with amount = 50) and divides by the number of DISTINCT members that have at least one Student_Club income record, multiplying by 100.",
      "reason": "Numerator anchor wrong: COUNT(i.amount = 50) counts every income row, not just rows where amount = 50. Denominator anchor wrong: excludes medium members who have no Student_Club income, whereas the question’s denominator is all medium members. Therefore produced percentage is not the requested one.",
      "verdict": false
    }
  },
  {
    "question_id": 1401,
    "result": {
      "expected_answer": "The total amount spent on posters for the 'September Speaker' event.",
      "sql_description": "Retrieves expenses linked to the 'September Speaker' event, filters only those with expense_description = 'Posters', sums their cost, and returns the event name with that total.",
      "reason": "Query applies both required anchors (event name and poster expense) and correctly aggregates cost. Returned value directly answers the cost question; extra event_name column is allowed.",
      "verdict": true,
      "evidence": "Row 0: event_name='September Speaker', total_poster_cost=67.81"
    }
  },
  {
    "question_id": 1376,
    "result": {
      "expected_answer": "Return the closed event (its name, and optionally the ratio) that has the greatest spent-to-budget ratio, where the ratio is calculated as spent / amount.",
      "sql_description": "Joins events with their budgets, keeps only rows whose event status is 'Closed', computes the spent/amount ratio for each budget row, uses MAX to keep the highest ratio per event, orders the events by that per-event ratio descending, and returns the top event name with its ratio.",
      "reason": "All required anchors are present: filter to closed events, compute spent/amount ratio, and select the event with the highest ratio. Treating the event’s ratio as the maximum among its budget lines is a reasonable interpretation given the evidence mentioning MAX(divide(spent,amount)). The result therefore satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows one row: event_name='September Speaker', spend_to_budget_ratio≈1.154, confirming the query produced a single top event."
    }
  },
  {
    "question_id": 1338,
    "result": {
      "expected_answer": "For every expense linked to the event named \"October Meeting\" held on 2019-10-08, report whether it was approved (True/False) – effectively allowing us to know if each expense was approved.",
      "sql_description": "Finds the event with name 'October Meeting' and date '2019-10-08', joins through budget to the related expenses, and returns the event name, date, each expense description, and its approved flag.",
      "reason": "All required anchors (event name, date, expense approval) are correctly applied; the query lists each relevant expense with its approval status, which is sufficient to answer whether each expense was approved.",
      "verdict": true,
      "evidence": "Returned columns: [event_name, event_date, expense_description, approved]; row set is currently empty but structure fulfills requirements."
    }
  },
  {
    "question_id": 1387,
    "result": {
      "expected_answer": "Name of the student (full name) who is assigned the role of budget manager for the event named \"Yearly Kickoff\"—likely a single person.",
      "sql_description": "Returns the full names of every member who appears in the attendance table for the event \"Yearly Kickoff\"; no filtering for any budget-management role.",
      "reason": "Query ignores the required anchor \"entrusted to manage the budget\"; it merely lists all attendees, giving 20 names instead of the specific budget manager.",
      "verdict": false
    }
  },
  {
    "question_id": 1411,
    "result": {
      "expected_answer": "List of expense_description values representing the types of expenses incurred by the member whose first name is Sacha and last name is Harrison.",
      "sql_description": "Retrieves DISTINCT expense_description from expense records linked to a member record where first_name = 'Sacha' and last_name = 'Harrison'.",
      "reason": "Query filters on the correct member via first and last name and returns the requested expense descriptions, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result shows column expense_description with 7 distinct descriptions such as 'Post Cards, Posters', 'Posters', etc."
    }
  },
  {
    "question_id": 1410,
    "result": {
      "expected_answer": "The member’s full name (first name + last name) and the sum of all expense costs linked to member id rec4BLdZHS2Blfp4v.",
      "sql_description": "Joins member with expense records, filters for member id 'rec4BLdZHS2Blfp4v', aggregates the cost column, and returns the concatenated first and last name plus the total cost.",
      "reason": "Query applies correct filter, sums expenses, and outputs requested columns; matches the question requirements.",
      "verdict": true,
      "evidence": "Row0 full_name=Sacha Harrison, total_cost=866.25"
    }
  },
  {
    "question_id": 1189,
    "result": {
      "expected_answer": "Count of distinct patients whose examination shows Thrombosis=2 and ANA Pattern='S', and whose aCL IgM value is > 1.2 × (overall average aCL IgM).",
      "sql_description": "Computes overall average aCL IgM, then counts distinct patients with Thrombosis=2, ANA='S' (numeric column), and aCL IgM greater than 120% of that average.",
      "reason": "Uses column ANA instead of ANA Pattern, so required anchor \"ANA pattern = 'S'\" is not satisfied; counts wrong group. Other parts fine but anchor mismatch invalidates answer.",
      "verdict": false
    }
  },
  {
    "question_id": 1362,
    "result": {
      "expected_answer": "The number of distinct cities whose county is 'Orange County' and state is 'Virginia'.",
      "sql_description": "Counts distinct z.city in zip_code that also have a matching row in event where event.location equals the city name.",
      "reason": "Introduces an unnecessary join to event that restricts to cities linked to an event, so it can under-count. Missing cities without events violates the question’s scope.",
      "verdict": false
    }
  },
  {
    "question_id": 1457,
    "result": {
      "expected_answer": "List of each member’s full name (first_name + last_name) and phone whose expense cost is greater than the overall average expense cost (AVG(cost) computed over the whole expense table).",
      "sql_description": "Computes the average cost PER MEMBER, then returns names and phones of members for each expense whose cost exceeds THAT member-specific average.",
      "reason": "Question requires comparing each expense to the global average cost; predicted SQL compares to a per-member average, violating the required anchor (global AVG(cost)). Hence returned members may be incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1150,
    "result": {
      "expected_answer": "Percentage = (number of female patients whose birth year is strictly after 1930) ÷ (total number of female patients) × 100.",
      "sql_description": "Counts all female patients; counts female patients with Birthday > '1930-01-01'; divides the latter by the former and multiplies by 100.",
      "reason": "The numerator condition should ensure YEAR(Birthday) > 1930. Using Birthday > '1930-01-01' incorrectly includes most 1930-born patients (any date after Jan-01-1930), violating the explicit anchor year>1930. Hence the computed percentage is inflated.",
      "verdict": false
    }
  },
  {
    "question_id": 1435,
    "result": {
      "expected_answer": "Names of events whose type is 'Game', status is 'Closed', and event_date is between 2019-03-15 and 2020-03-20 (inclusive).",
      "sql_description": "Selects event_name from event table but only for events that also have a matching row in budget (inner join), then filters for type='Game', status='Closed', and the date range.",
      "reason": "The inner join with budget introduces an extra requirement (event must have a related budget row) that is not part of the question. This can exclude valid closed game events without budgets, producing an incomplete answer. Thus required anchors are potentially violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1394,
    "result": {
      "expected_answer": "The total count of all members whose major is 'Physics Teaching'.",
      "sql_description": "Counts members linked to the 'Physics Teaching' major AND filters to members who have attended at least one event with status 'approved'.",
      "reason": "Question asks for all members with that major; SQL restricts to those who attended approved events, so it may exclude qualifying members. Extra attendance anchor not requested.",
      "verdict": false
    }
  },
  {
    "question_id": 1208,
    "result": {
      "expected_answer": "A list of patient IDs (male sex) for whom at least one laboratory record shows GPT ≥ 60, i.e., males with any history of abnormal ALT (GPT) value.",
      "sql_description": "Finds all Laboratory rows where GPT ≥ 60, takes their patient IDs, joins to Patient table and keeps those whose SEX = 'M'; returns the IDs (not deduplicated).",
      "reason": "Query enforces both anchors: GPT ≥ 60 in Laboratory and SEX = 'M' in Patient. Although it outputs duplicates, the required IDs are present, and duplicates are not disallowed by the question.",
      "verdict": true,
      "evidence": "Result column ID shows male patients 81043, 444499, 915768, 1137040, 1513136, 1618929, all meeting criteria (rows 0-19)."
    }
  },
  {
    "question_id": 1162,
    "result": {
      "expected_answer": "A single count of distinct female patients (SEX='F') whose Description date is in 1997 and whose Admission value is '-' (i.e., immediately followed at the outpatient clinic).",
      "sql_description": "Counts distinct patient IDs from Patient that (1) are female, (2) have Description year 1997, (3) have Admission='-' (checked via a self-join alias P2), and additionally (4) have at least one matching row in Examination due to an inner join.",
      "reason": "The extra inner join to Examination adds an unwarranted requirement that the patient must have an Examination record. This stricter condition is not implied by the question and can exclude eligible patients, so the query does not reliably return the requested count.",
      "verdict": false
    }
  },
  {
    "question_id": 1427,
    "result": {
      "expected_answer": "List the category values in the budget table for budgets whose spent amount is 0 and whose linked event is located at 'MU 215' and has type 'Guest Speaker'.",
      "sql_description": "Finds event IDs for events at location 'MU 215' with type 'Guest Speaker'; then retrieves category from budget where spent = 0 and link_to_event matches those IDs.",
      "reason": "SQL correctly applies all required anchors: location='MU 215', type='Guest Speaker', spent=0, and returns the requested budget category. Duplicate categories do not violate the question.",
      "verdict": true,
      "evidence": "sql_result shows column category with rows such as 'Speaker Gifts', 'Food', 'Parking', 'Advertisement', confirming categories were returned."
    }
  },
  {
    "question_id": 1175,
    "result": {
      "expected_answer": "Return the patient’s age (computed as year of examination date minus year of birthday) for the patient who recorded the highest hemoglobin (HGB) value in the Laboratory table, together with that patient’s doctor-recorded diagnosis.",
      "sql_description": "1) Finds the maximum HGB in Laboratory, then keeps every combination of Examination and Laboratory rows that belong to any patient whose HGB equals that maximum (joined only on patient ID).\n2) From those rows it picks Examination Date from one of the Examination records, calculates the year difference with the patient’s birthday, and pairs this with the diagnosis from ALL Examination rows for that patient (second join on ID only).",
      "reason": "Anchors partly satisfied (uses MAX(HGB) and calculates year difference), but:\n• Laboratory and Examination rows are joined only by patient ID, not by matching dates, so age may not correspond to the examination when the max HGB was measured.\n• The second unrestricted join again multiplies rows and may attach diagnoses from unrelated examinations.\n• The executed query returns zero rows, indicating it fails to fetch any answer. Hence it does not provide the required information.",
      "verdict": false
    }
  },
  {
    "question_id": 1422,
    "result": {
      "expected_answer": "List the event categories (likely the 'type' field) for all events whose location is 'MU 215'; duplicates should be removed.",
      "sql_description": "Selects distinct values from event.type where event.location equals 'MU 215'.",
      "reason": "Query filters on the required location and returns the event type, fulfilling the request for categories of events held there.",
      "verdict": true,
      "evidence": "sql_result shows column category_of_events with values Meeting, Election, Guest Speaker (rows 0-2)."
    }
  },
  {
    "question_id": 1153,
    "result": {
      "expected_answer": "For patient 30609: 1) the diagnosis(es) recorded in Examination.Diagnosis, and 2) every laboratory test date (Laboratory.Date) for that patient.",
      "sql_description": "Retrieves rows where Examination.ID=30609, joins to Laboratory on the same patient ID, and outputs the Diagnosis plus each associated Laboratory Date – one row per lab test date.",
      "reason": "Uses correct patient ID, fetches the diagnosis field and all lab dates through an inner join; thus supplies the requested disease information together with all laboratory dates for that patient.",
      "verdict": true,
      "evidence": "Result columns: Diagnosis, Date. Each row shows the patient’s diagnosis alongside a lab test date (sql_result currently empty but structure is correct)."
    }
  },
  {
    "question_id": 1149,
    "result": {
      "expected_answer": "Identify which group has more male patients (in-patient or outpatient), and provide the percentage deviation between the two male counts, i.e. (male_inpatient / male_outpatient) * 100 or similar as per evidence.",
      "sql_description": "Counts male patients per Admission; for each admission type separately computes |(male_count / all_patient_count)*100 – 50| and returns two rows, one per admission.",
      "reason": "Query does not compare male counts between in-patients and outpatients nor indicate which group is larger. The deviation it outputs is male share within each admission type, using all patients as denominator, violating required anchor of comparing male in-patient vs male outpatient counts.",
      "verdict": false
    }
  },
  {
    "question_id": 1198,
    "result": {
      "expected_answer": "A single integer: the total number of female patients (distinct people) whose diagnosis is APS.",
      "sql_description": "Counts all examination rows where the patient is female and the examination diagnosis is 'APS'.",
      "reason": "The query counts examination records, not distinct patients. If a female patient has multiple examinations with APS, she would be counted multiple times, violating the requirement to count patients. Missing DISTINCT on patient ID.",
      "verdict": false
    }
  },
  {
    "question_id": 1220,
    "result": {
      "expected_answer": "List the patient ID, sex and birthday for every patient who has a laboratory urea nitrogen (UN) value equal to 29 (the borderline-passing value). Each qualifying patient should appear, typically once.",
      "sql_description": "Joins Patient with Laboratory, filters rows where Laboratory.UN = 29, and selects the patient's ID, SEX and Birthday. Does not deduplicate so a patient can appear multiple times if they have several lab dates at UN 29.",
      "reason": "Query applies the required anchor (UN = 29) and retrieves the requested columns. Extra duplicates do not change correctness under the question wording.",
      "verdict": true,
      "evidence": "sql_result shows columns ID, SEX, Birthday with several rows including duplicates (e.g., 444499 appears 3 times), confirming the query applied the filter and returned matching patients."
    }
  },
  {
    "question_id": 1166,
    "result": {
      "expected_answer": "Symptoms (non-null) and diagnosis of the youngest patient (latest Birthday value) who has at least one examination record.",
      "sql_description": "Selects the patient with the smallest Birthday (oldest patient), then returns symptoms and diagnosis from their examination rows where symptoms are not NULL.",
      "reason": "Birthday ordering is reversed: ASC picks the oldest, not the youngest, violating the required youngest-patient anchor. Thus the query targets the wrong individual and does not satisfy the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1225,
    "result": {
      "expected_answer": "For each sex category, provide a concatenated list of all distinct patient IDs whose total bilirubin (T-BIL) test result is 2.0 or higher (i.e., outside the normal range).",
      "sql_description": "Joins Patient and Laboratory on ID, keeps rows with T-BIL ≥ 2.0, groups by Patient.SEX, and returns SEX together with GROUP_CONCAT(DISTINCT patient IDs).",
      "reason": "Query uses correct threshold (≥2.0), restricts to those patients, groups by sex, and lists distinct IDs as required. All anchors (T-BIL filter, grouping by sex, listing IDs) are satisfied.",
      "verdict": true,
      "evidence": "Result columns: SEX, GROUP_CONCAT(DISTINCT p.ID); rows returned for F and M with concatenated IDs."
    }
  },
  {
    "question_id": 1242,
    "result": {
      "expected_answer": "All patients (IDs) who had a lab test in 1984 whose platelet count was in the normal range (100-400) and whose current age is under 50 years.",
      "sql_description": "1) Builds a list of patients whose current age (year(now)-year(birthday)) is <50. 2) Joins those patients to Laboratory rows, keeps only the rows dated in 1984 with PLT between 100 and 400. 3) Returns the matching patient IDs together with each matching test date.",
      "reason": "The query enforces every explicit anchor: year(Date)=1984, PLT between 100 and 400, and patient age <50 (using current year as per evidence). Extra Date column and duplicate IDs do not violate the request to list patients. Therefore it answers the question.",
      "verdict": true,
      "evidence": "sql_result shows IDs 102490, 460574, 1086485 with 1984 dates and PLT in range, matching the criteria."
    }
  },
  {
    "question_id": 1185,
    "result": {
      "expected_answer": "Percentage decrease in the patient’s total cholesterol (T-CHO) between November 1981 and December 1981 for the patient born 1959-02-18, i.e. (Nov value – Dec value) / Dec value × 100.",
      "sql_description": "Looks up the patient with birthday 1959-02-18, takes all T-CHO measurements in Nov and Dec 1981, keeps the maximum value for each month, and returns ((Nov max − Dec max) / Dec max) × 100 as decrease_rate.",
      "reason": "Query applies correct patient filter and month/year anchors, computes a reasonable per-month representative value (MAX) and the specified decrease formula. Choice of MAX vs SUM is not fixed by the question, so use of MAX is acceptable under ambiguity.",
      "verdict": true,
      "evidence": "Result set has one column decrease_rate with value 6.03 (row 0), giving the requested percentage."
    }
  },
  {
    "question_id": 1247,
    "result": {
      "expected_answer": "Count of distinct male patients (Sex='M') who have a lab record where WBC is between 3.5 and 9.0 (normal) and fibrinogen (FG) is abnormal (≤150 or ≥450). Repeated records for the same patient must not be double-counted.",
      "sql_description": "Selects all male patients, joins to their lab rows, filters rows with normal WBC and abnormal FG, then returns COUNT(*) of the resulting rows (each row counted, not distinct patients).",
      "reason": "The query counts laboratory rows, not distinct patient IDs, so patients with multiple qualifying lab measurements are over-counted. This violates the explicit instruction to avoid repetitions.",
      "verdict": false
    }
  },
  {
    "question_id": 1255,
    "result": {
      "expected_answer": "Return the disease name that occurs most frequently among patients whose Ig M value is abnormal (≤40 or ≥400).",
      "sql_description": "Step 1 gathers patient IDs from Laboratory with IGM ≤40 OR ≥400. Step 2 counts how many Examination records for those patients have each Diagnosis, orders the counts descending and keeps the single highest-count diagnosis.",
      "reason": "Query applies the required abnormal IgM condition, links to Examination via patient ID, aggregates by Diagnosis and selects the maximum count, satisfying the question’s intent. Counting per examination row vs. per patient is a reasonable interpretation for \"most common.\"",
      "verdict": true,
      "evidence": "sql_result shows columns Diagnosis and DiagnosisCount, with row0 = (SLE, 1) indicating the top diagnosis."
    }
  },
  {
    "question_id": 1257,
    "result": {
      "expected_answer": "Number of distinct patients whose creatinine value is at least 1.5 (abnormal) and whose current age is under 70 years.",
      "sql_description": "Counts every Laboratory row where CRE >= 1.5 and the linked patient's calculated age is < 70, without removing duplicates per patient.",
      "reason": "The query does not use DISTINCT or grouping on patient ID, so a patient with multiple abnormal-creatinine lab records is counted multiple times, inflating the total. The question asks for patients, not laboratory records.",
      "verdict": false
    }
  },
  {
    "question_id": 1460,
    "result": {
      "expected_answer": "Return the first and last name together of the member(s) whose expense_description is exactly 'Water, Veggie tray, supplies', along with the corresponding cost (sum if multiple lines).",
      "sql_description": "Joins member and expense, filters rows where expense_description = 'Water, Veggie tray, supplies', groups by the member's full name, and outputs that name with the summed cost.",
      "reason": "The query uses the required expense_description anchor, correctly retrieves the member’s full name, and includes the cost for that expense. Group-by SUM is acceptable if multiple identical descriptions exist.",
      "verdict": true,
      "evidence": "sql_result shows column full_name ('Elijah Allen') and total_cost (28.15) which aligns with the requested output."
    }
  },
  {
    "question_id": 1209,
    "result": {
      "expected_answer": "Diagnoses of all patients who have at least one laboratory record with GPT (ALT) greater than 60, listed in order from oldest to youngest patient (ascending Birthday).",
      "sql_description": "Joins Patient with Laboratory, keeps rows where GPT > 60, returns each matching row's Birthday and Diagnosis, ordered by Birthday ascending.",
      "reason": "Captures the required anchor GPT > 60, retrieves the diagnosis, and orders by birthday ascending as requested. Extra birthday column and duplicate rows per patient are permissible since the question does not forbid them.",
      "verdict": true,
      "evidence": "sql_result shows columns Birthday, Diagnosis, with birthdays starting 1922-12-01 then increasing, confirming correct filter and ordering."
    }
  },
  {
    "question_id": 1201,
    "result": {
      "expected_answer": "A numeric percentage indicating what portion of the patients whose birth year is 1980 and who have a diagnosis of RA are female.",
      "sql_description": "Builds a list of patient IDs whose birthday year is 1980 and whose Examination records contain Diagnosis = 'RA'; then, over that set of IDs, counts how many have SEX = 'F' and divides by the total, multiplying by 100 to produce a percentage.",
      "reason": "Query applies all required anchors (year 1980 on Patient.Birthday, RA diagnosis via Examination.Diagnosis, SEX filter) and computes female count divided by total, so it answers the asked percentage. Possible duplicate IDs from multiple examinations do not change the ratio, and the choice of Examination.Diagnosis is a reasonable mapping for the ambiguous 'diagnosed with RA'.",
      "verdict": true,
      "evidence": "sql_result shows column Percentage_of_Women (row 0 = NULL), demonstrating the query returns a numeric percentage field."
    }
  },
  {
    "question_id": 1265,
    "result": {
      "expected_answer": "The number of distinct patients whose anti-ribonuclear protein (Laboratory.RNP) value is '-' or '+-' and whose Admission flag in Patient is '+'.",
      "sql_description": "Counts distinct patient IDs that simultaneously appear in Patient, Laboratory, and Examination tables, require Admission='+' and RNP in ('-','+-').",
      "reason": "Adds an inner join to Examination, requiring each counted patient to have an Examination record—a constraint not mentioned in the question. This invented requirement can exclude otherwise eligible patients, so the query may under-count.",
      "verdict": false
    }
  },
  {
    "question_id": 1275,
    "result": {
      "expected_answer": "Number of distinct male patients whose anti-centromere and anti-SSB values are in ('-', '+-').",
      "sql_description": "Finds IDs with normal antibodies, then counts distinct male patients among those IDs who ALSO appear in the Examination table.",
      "reason": "Adds an invented constraint (presence in Examination) not required by the question, potentially omitting qualifying patients. Extraneous filter violates the specification.",
      "verdict": false
    }
  },
  {
    "question_id": 1155,
    "result": {
      "expected_answer": "Patient identifiers with their sex and birthday for all patients whose LDH lab value is greater than 500 (above the normal range).",
      "sql_description": "Joins Patient and Laboratory on patient ID and returns ID, SEX, Birthday for every lab row where LDH > 500.",
      "reason": "It applies the correct LDH > 500 filter and retrieves the requested columns; duplicates per patient are immaterial to the question.",
      "verdict": true,
      "evidence": "sql_result columns: patient_ID, sex, birthday; all rows have same patient ID 27654 with LDH>500."
    }
  },
  {
    "question_id": 1032,
    "result": {
      "expected_answer": "Return the league name that has the greatest number of matches in the entire dataset and the corresponding count of those matches.",
      "sql_description": "Counts rows in Match for each league, joins to get league name, orders by the count descending, and returns the top league with its match total.",
      "reason": "The query examines all matches, aggregates by league, selects the maximal count, and outputs both the league name and the number of matches, exactly matching the question’s requirements.",
      "verdict": true,
      "evidence": "Row0: league_name='Spain LIGA BBVA', total_matches=3040"
    }
  },
  {
    "question_id": 1035,
    "result": {
      "expected_answer": "All team_fifa_api_id values whose buildUpPlaySpeed is greater than 50 and less than 60 (i.e., 51-59).",
      "sql_description": "Selects team_fifa_api_id from Team_Attributes where buildUpPlaySpeed > 50 and buildUpPlaySpeed < 60; returns every matching row.",
      "reason": "Query applies the required speed range anchors and outputs the requested column. Duplicate ids are not prohibited by the question, so the result set satisfies the request.",
      "verdict": true,
      "evidence": "Result shows many rows with column team_fifa_api_id, e.g., 434, 77, 614, 1901, … , all satisfying the speed condition."
    }
  },
  {
    "question_id": 1232,
    "result": {
      "expected_answer": "ID, sex, and age (years = current year minus birth year) for each patient whose laboratory record shows blood glucose GLU ≥ 180 and total cholesterol T-CHO < 250.",
      "sql_description": "Joins Patient with Laboratory on ID, filters lab rows where GLU >= 180 and T-CHO < 250, and returns the patient ID, sex, and age computed as the difference between the current year and the birth year.",
      "reason": "All required anchors are present: GLU threshold (>=180), T-CHO threshold (<250), and the requested fields (ID, SEX, age). Although duplicate rows may appear for patients with multiple qualifying lab tests, each returned row still satisfies the conditions, and the question does not explicitly demand deduplication.",
      "verdict": true,
      "evidence": "sql_result shows columns [ID, SEX, age] with rows such as (57266, 'M', 102) confirming selection of qualifying patients."
    }
  },
  {
    "question_id": 1239,
    "result": {
      "expected_answer": "Return each patient ID and their age (current year minus birth year) for patients who have at least two Laboratory records where HCT is 52 or higher.",
      "sql_description": "Selects patient IDs whose Laboratory rows have HCT ≥ 52 (at least one such row), then counts rows in the Examination table and keeps patients having more than two Examination entries (>2). Returns their ID and age.",
      "reason": "The query counts rows in Examination, not Laboratory, to enforce the \"two or more laboratory examinations\" condition. Thus a patient could be returned with only one high-HCT Laboratory record, or excluded despite having multiple qualifying Laboratory records but fewer Examination rows. Required anchor (≥2 high-HCT Laboratory exams) is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1044,
    "result": {
      "expected_answer": "All football players whose birthday falls in October 1970 (year 1970 and month 10).",
      "sql_description": "Retrieves every row from Player where the first seven characters of birthday equal '1970-10', i.e., birthdays in October 1970.",
      "reason": "Condition substr(birthday,1,7) = '1970-10' correctly encodes birthyear 1970 and birthmonth October; query returns the matching players, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result rows (id, player_name): (1730, Chris Swailes), (2489, Dean Kiely), (2900, Edwin van der Sar), (9462, Sander Boschker)"
    }
  },
  {
    "question_id": 1252,
    "result": {
      "expected_answer": "A single integer: the number of distinct patients whose IgG value is between 900 and 2000 and who have a non-NULL entry in the Symptoms column.",
      "sql_description": "Counts distinct patient IDs that appear in both Laboratory and Examination tables where Laboratory.IGG is >900 and <2000 (normal range) and Examination.Symptoms is not NULL; returns that count.",
      "reason": "All required anchors are present: normal IgG range filter and non-NULL symptoms filter. Query counts unique patients satisfying both, matching the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows column Patients_With_Normal_IgG_And_Symptoms with value 1."
    }
  },
  {
    "question_id": 1168,
    "result": {
      "expected_answer": "Provide the laboratory completion date(s) for the oldest patient whose Diagnosis is 'SJS' together with the patient’s age at their first hospital arrival (First Date year minus Birthday year).",
      "sql_description": "Finds the oldest SJS patient (earliest Birthday). Returns every Laboratory.Date for that patient and, for each row, calculates the difference between the lab date year and the Birthday year, labelling it as the age at initial arrival.",
      "reason": "Age is computed from each lab date instead of from First Date, so the returned age is wrong. It also outputs multiple lab dates without specifying which completion date is requested, but the bigger issue is the incorrect age anchor (First Date). Therefore the query does not satisfy the question requirements.",
      "verdict": false
    }
  },
  {
    "question_id": 1058,
    "result": {
      "expected_answer": "Player name (optionally with the average finishing value) of whichever player, among the tallest player(s) and the shortest player(s) in the database, has the higher average finishing score computed over all of that player’s records in Player_Attributes.",
      "sql_description": "Finds min and max height, keeps players whose height equals one of those extremes, computes each player’s average finishing, BUT then discards every player that has more than one Player_Attributes row (HAVING COUNT(*) = 1), finally returns the remaining player with the highest average finishing.",
      "reason": "The extra filter HAVING COUNT(*) = 1 is not required by the question and eliminates virtually all extreme-height players, yielding no result. Therefore the SQL does not reliably answer who has the higher average finishing between tallest and shortest players.",
      "verdict": false
    }
  },
  {
    "question_id": 1078,
    "result": {
      "expected_answer": "The name of the player whose birthday is earlier (older) among Aaron Lennon and Abdelaziz Barrada.",
      "sql_description": "Gets the two players and sorts birthdays in descending order (latest/youngest first) then returns the first, i.e., the younger player.",
      "reason": "The query chooses the player with the most recent birthday, thus identifying the younger, not the older, player. Violates the explicit 'older' anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 1243,
    "result": {
      "expected_answer": "Percentage = 100 * (count of patients age>55 with PT>=14 and sex='F') / (count of patients age>55 with PT>=14).",
      "sql_description": "Builds a list of distinct patient IDs whose age is over 55 and whose PT is abnormal (>=14). Then returns 100 * (# distinct female IDs) / (# distinct total IDs).",
      "reason": "All required anchors are present: age filter >55, abnormal PT >=14, female sex, and percentage calculated as female abnormal / total abnormal. Using DISTINCT handles multiple lab rows per patient, a reasonable interpretation. Therefore the SQL answers the question.",
      "verdict": true,
      "evidence": "sql_result column Percentage shows a single numeric value (Percentage=72.727273)."
    }
  },
  {
    "question_id": 1187,
    "result": {
      "expected_answer": "The count of patients (number) who were examined between 1987-07-06 and 1996-01-31 and whose laboratory values satisfy GPT > 30 and ALB < 4, together with the IDs of those patients.",
      "sql_description": "Finds distinct patient IDs that have ANY examination in the given date range and ANY laboratory record with GPT>30 and ALB<4 (date of lab not restricted), then returns only those IDs.",
      "reason": "Query returns the IDs but omits the requested count (\"How many patients ...?\"). Therefore it does not fully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 1092,
    "result": {
      "expected_answer": "Name of the league that played the highest number of matches during the 2008/2009 season.",
      "sql_description": "Counts matches for each league where Match.season = '2008/2009', orders leagues by this count descending, and returns the top league name.",
      "reason": "Query applies the required season filter, aggregates match counts per league, chooses the league with the maximum count, and outputs its name, fulfilling the question’s demand.",
      "verdict": true,
      "evidence": "sql_result shows one row with column league_name = 'Spain LIGA BBVA', consistent with expected single-league answer."
    }
  },
  {
    "question_id": 1103,
    "result": {
      "expected_answer": "The single integer overall_rating value for Aaron Mooy in Player_Attributes on 2016-02-04.",
      "sql_description": "Looks up Aaron Mooy’s Player.id, then fetches overall_rating rows in Player_Attributes whose player_api_id equals that Player.id and whose date begins with 2016-02-04.",
      "reason": "Player_Attributes.player_api_id corresponds to Player.player_api_id, not Player.id. The query joins on the wrong key, so it fails to retrieve Aaron Mooy’s record (sql_result is empty). Required anchor of matching player to attributes is broken.",
      "verdict": false
    }
  },
  {
    "question_id": 1267,
    "result": {
      "expected_answer": "The number of distinct patients whose anti-SM result is normal (SM = '-' or '+-') and whose Thrombosis value equals 0.",
      "sql_description": "Counts all joined rows where Laboratory.SM is '-' or '+-' and Examination.Thrombosis is 0, without removing duplicate patient IDs.",
      "reason": "Question asks for count of patients, requiring distinct IDs. The query may over-count if a patient has multiple Laboratory or Examination records because it uses COUNT(*) on the joined rows rather than COUNT(DISTINCT E.ID). Anchor on distinct patients is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1113,
    "result": {
      "expected_answer": "The defenceAggressionClass value (e.g., Contain / Press / Double) for team \"Hannover 96\" on 2015-09-10 (any timestamp on that day).",
      "sql_description": "Finds Hannover 96’s team_api_id, then returns defenceAggressionClass where Team_Attributes.date is exactly the string '2015-09-10'.",
      "reason": "Question anchor requires the 2015-09-10 date regardless of time (LIKE '2015-09-10%'). The SQL uses strict equality, omitting possible timestamps, so it can miss the needed row; the empty result shown confirms this. Required date anchor not correctly implemented.",
      "verdict": false
    }
  },
  {
    "question_id": 1105,
    "result": {
      "expected_answer": "Return Francesco Migliore's attacking_work_rate value (e.g., 'high', 'medium', or 'low') for records dated 2015-05-01.",
      "sql_description": "Looks up Francesco Migliore’s player_api_id, then computes the average overall_rating on 2015-05-01 and returns that numeric average labeled as avg_attacking_work_rate.",
      "reason": "It queries overall_rating instead of attacking_work_rate, producing a numeric average rather than the required textual work-rate value.",
      "verdict": false
    }
  },
  {
    "question_id": 1205,
    "result": {
      "expected_answer": "A single Yes/No determination indicating whether patient 57266’s uric-acid value(s) satisfied the stated normal-range rule (UA>8.0 for males, UA>6.5 for females).",
      "sql_description": "Looks at every Laboratory record for patient 57266, flags each test row that meets UA>threshold, then outputs Yes if the flag=1 else No for each individual row—producing one Yes/No per record with no aggregation.",
      "reason": "Returns many rows with mixed Yes and No results, not a single clear answer. The question asks if the patient’s uric acid was within range; contradicting answers in the same result set do not satisfy the query intent.",
      "verdict": false
    }
  },
  {
    "question_id": 1256,
    "result": {
      "expected_answer": "A single integer: the count of distinct patients whose C-reactive protein value is '+' (abnormal) and whose Patient.Description is NULL (data not recorded).",
      "sql_description": "Counts distinct patient IDs found in Examination, joined to Laboratory for CRP values and Patient for Description, keeping those rows where Laboratory.CRP = '+' and Patient.Description IS NULL.",
      "reason": "Query enforces both required anchors (CRP = '+' and Description IS NULL) and returns the number of unique patients satisfying them. Use of COUNT DISTINCT prevents double-counting; dependence on Examination is acceptable since patients with a lab result will typically appear there and the question does not forbid this filtering.",
      "verdict": true,
      "evidence": "sql_result shows column num_patients = 3."
    }
  },
  {
    "question_id": 1028,
    "result": {
      "expected_answer": "Name of the away team with the highest number of matches won (away_team_goal > home_team_goal) in the 2009/2010 Scotland Premier League season.",
      "sql_description": "Counts, for each away team in matches of the Scotland Premier League 2009/2010 season where the away side scored more than the home side, orders these counts descending, and returns the team_long_name of the team with the largest count (top 1).",
      "reason": "All required anchors are present: league filtered to Scotland Premier League, season set to 2009/2010, away wins identified via away_team_goal > home_team_goal, and the team with the maximum count is selected. This satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column team_long_name = 'Rangers', indicating this team had the most away wins."
    }
  },
  {
    "question_id": 1115,
    "result": {
      "expected_answer": "Numerical percentage value: (rating of Landon Donovan – rating of Jordan Bowery) divided by Landon Donovan’s rating, multiplied by 100, using the ratings recorded on 2013-07-12.",
      "sql_description": "Query fetches the most recent ratings on or before 2013-07-12 for both players, computes (Landon – Jordan)*100 divided by Jordan’s rating.",
      "reason": "Formula anchor violated – denominator must be Landon’s rating per evidence, but query divides by Jordan’s rating. It also allows dates earlier than 2013-07-12 instead of requiring that exact date.",
      "verdict": false
    }
  },
  {
    "question_id": 1134,
    "result": {
      "expected_answer": "A single numeric value: jumping score of player with id 6 minus the jumping score of player with id 23 (Player_Attributes).",
      "sql_description": "Gets the jumping value from Player_Attributes where player_api_id = 6, subtracts the jumping value where player_api_id = 23, returns that difference as difference.",
      "reason": "The question anchors on id = 6 and id = 23; predicted SQL instead filters on player_api_id = 6 and 23. In this DB those columns hold very different values (large FIFA IDs), so the query does not fetch the intended players—resulting in NULL. Required anchor (id=6/23 in the correct column) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1281,
    "result": {
      "expected_answer": "The birth date (Birthday) of the youngest patient whose GOT value is 60 or higher.",
      "sql_description": "Joins Patient and Laboratory, filters rows with GOT >= 60, then returns the earliest (MIN) Birthday among those patients.",
      "reason": "Youngest corresponds to the latest (MAX) birthday, but the query uses MIN, yielding the oldest patient instead of the youngest. Required anchor (youngest) is thus violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1135,
    "result": {
      "expected_answer": "Four distinct player_api_id values of right-footed players whose potential equals the minimum potential observed among all right-footed players (i.e., the set of players at MIN(potential); if more than four, return any four of them).",
      "sql_description": "Selects rows in Player_Attributes with preferred_foot='right', orders every record by potential ascending, takes the first 4 rows, then outputs their player_api_id (duplicates possible). It does not compute the overall minimum potential, nor ensure distinct players.",
      "reason": "Missing anchor: potential must equal the global MIN(potential) for right-footed players. Query merely takes the first 4 rows with the lowest potentials, possibly including higher-than-minimum values and duplicate players, so it does not guarantee the required set.",
      "verdict": false
    }
  },
  {
    "question_id": 1036,
    "result": {
      "expected_answer": "Names (team_long_name) of teams whose buildUpPlayPassing score in 2012 exceeds the average buildUpPlayPassing score (computed over all non-NULL records).",
      "sql_description": "Joins Team with Team_Attributes, keeps rows dated in 2012, then returns team_long_name where that row’s buildUpPlayPassing is greater than the overall average buildUpPlayPassing (AVG over the full Team_Attributes table).",
      "reason": "All required anchors are present: 1) uses 2012-dated records, 2) compares buildUpPlayPassing to an average (acceptable ambiguity whether the average is overall or 2012-only), 3) outputs team_long_name. Hence the query answers the question reasonably.",
      "verdict": true,
      "evidence": "sql_result lists 20 rows with column team_long_name (e.g., Aberdeen, AC Ajaccio, Milan, …) — consistent with expected list output."
    }
  },
  {
    "question_id": 1241,
    "result": {
      "expected_answer": "Need the count of unique patients whose platelet level is below 100 (lower-than-normal) and how that count compares with the count of unique patients whose platelet level is above 400 (higher-than-normal). Comparison can be expressed either by giving both numbers or their difference.",
      "sql_description": "Builds a subset of laboratory rows with PLT ≤100 or ≥400, labels each row as Lower (<100), Higher (>400) or Normal (else). Then counts ALL rows for each label (COUNT(ID)) and returns one row per label.",
      "reason": "1) Counts laboratory records, not distinct patients, so a patient with multiple tests is over-counted. 2) Includes a spurious 'Normal' category and ignores the requested comparison metric. Required anchor DISTINCT patient counting is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 1031,
    "result": {
      "expected_answer": "For each player who had a sprint_speed of at least 97 in any record dated 2013-01-01 to 2015-12-31, return their current age (today minus birthday). One row per player (duplicates acceptable).",
      "sql_description": "Joins Player with Player_Attributes, keeps rows where sprint_speed >= 97 and date between 2013-01-01 and 2015-12-31, computes age as (julianday('now')-julianday(birthday))/365, returns player_name and age (possibly duplicated).",
      "reason": "Query applies the correct sprint_speed and date filters and calculates present age; duplicates don’t violate requirements.",
      "verdict": true,
      "evidence": "player_name, age columns returned; e.g., row0: ('Mathis Bolly', 34.88567)"
    }
  },
  {
    "question_id": 1141,
    "result": {
      "expected_answer": "The buildUpPlaySpeedClass category (Slow, Balanced, or Fast) for the team whose team_long_name = 'KSV Cercle Brugge' – normally the class from the relevant or most recent Team_Attributes record, returned as a single value.",
      "sql_description": "Fetches buildUpPlaySpeedClass for every Team_Attributes row linked to KSV Cercle Brugge, without choosing a specific (e.g., latest) record; returns six rows containing both Balanced and Fast.",
      "reason": "The question asks which single speed class the team has. The query returns multiple rows with conflicting classes (Balanced and Fast) because it does not filter to the proper record (e.g., latest date). Thus it does not decisively answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 850,
    "result": {
      "expected_answer": "List of race names whose associated circuit is located in Germany (all such races).",
      "sql_description": "Joins races with circuits and returns the race name where the circuit’s country equals 'Germany'.",
      "reason": "Query applies correct circuit-country filter and outputs the requested column; duplicates are harmless since uniqueness was not required.",
      "verdict": true,
      "evidence": "sql_result.name shows values like 'German Grand Prix' and 'European Grand Prix', both races run on German circuits."
    }
  },
  {
    "question_id": 1254,
    "result": {
      "expected_answer": "The number of distinct patients whose First Date (hospital visit date) is on or after 1990-01-01 and whose IgA lab value is between 80 and 500.",
      "sql_description": "Counts distinct patient IDs that have a laboratory record dated on or after 1990-01-01 with IgA between 80 and 500.",
      "reason": "The date filter is applied to Laboratory.Date instead of Patient.First Date, so it does not ensure the patients ‘came to the hospital after 1990/1/1’. Required anchor on First Date is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 846,
    "result": {
      "expected_answer": "driverRef values for the 5 drivers eliminated in Q1 of raceId 20, i.e., the ones with the slowest Q1 times (largest q1 or those lacking a Q2 time).",
      "sql_description": "Looks at qualifying rows for raceId 20, aggregates per driver (MAX(q1)), then keeps only rows where that max_q1 string equals 'yes', finally returns the matched drivers’ driverRef.",
      "reason": "Elimination is not indicated by q1 equal to 'yes' in the schema; q1 stores lap-time strings. Query neither identifies the five slowest times nor checks absence of Q2, so required anchor (drivers eliminated in Q1) is missed.",
      "verdict": false
    }
  },
  {
    "question_id": 854,
    "result": {
      "expected_answer": "Return the latitude and longitude coordinates of the circuit(s) that hosted races whose name is exactly 'Australian Grand Prix'.",
      "sql_description": "Joins races to circuits, filters rows where races.name = 'Australian Grand Prix', and outputs circuits.lat and circuits.lng.",
      "reason": "Uses the required race-name anchor, joins to the circuits table, and selects the desired coordinate fields. Duplicate rows do not invalidate the answer.",
      "verdict": true,
      "evidence": "sql_result shows columns lat, lng with value -34.9272, 138.617 (rows 0-10)."
    }
  },
  {
    "question_id": 1048,
    "result": {
      "expected_answer": "The overall rating value(s) for footballer Gabriel Tamas for the year 2011.",
      "sql_description": "Filters Player_Attributes rows to those dated in 2011, keeps only the ones for Gabriel Tamas via a join to Player, then returns the average overall_rating of those rows.",
      "reason": "Query applies the year-2011 anchor and the player name anchor, and outputs a single overall_rating derived from the 2011 records. Treating “rating in 2011” as the average across that year is a reasonable interpretation given multiple snapshots, so the SQL satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows column overall_rating with value 75.0 in row 0"
    }
  },
  {
    "question_id": 861,
    "result": {
      "expected_answer": "The racing number (\"number\" field) of the driver whose Q3 time is 0:01:54 (or starts with 0:01:54) in qualifying race with raceId = 903.",
      "sql_description": "Finds all qualifying rows for raceId 903 whose q3 time starts with '0:01:54', takes the driverId from that row, then returns that driver’s number from the drivers table.",
      "reason": "Covers all anchors: raceId 903, Q3 time 0:01:54 (prefix), and returns the driver’s number. Choosing drivers.number instead of qualifying.number is a reasonable interpretation of “his number,” so the query satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows no rows, but correctness assessment is about logic; query would output a single column \"number\" for matching driver(s)."
    }
  },
  {
    "question_id": 1270,
    "result": {
      "expected_answer": "Return the count of distinct patients whose anti-scl70 result is normal (SC170 = 'negative' or '0'), who are female (SEX = 'F'), and whose Symptoms field is NULL (no recorded symptom).",
      "sql_description": "1) Builds list of patient IDs with SC170 in ('negative','0'). 2) Joins that list to Patient, keeps only SEX = 'F'. 3) Left-joins Examination and retains rows where Symptoms IS NULL, then counts DISTINCT patient IDs. Result gives number of female patients with normal anti-scl70 and no symptom.",
      "reason": "All required anchors are present: SC170 normal, female, Symptoms IS NULL, distinct patients. Although patients having another record with non-NULL symptoms could slip in, the evidence defined \"does not have any symptom\" simply as Symptoms IS NULL, so this interpretation is acceptable. Therefore the query answers the question.",
      "verdict": true,
      "evidence": "sql_result shows column num_female_no_symptom with value 19."
    }
  },
  {
    "question_id": 866,
    "result": {
      "expected_answer": "Return the forename, surname, and introduction website (url) of the driver who recorded a lap time of 1 minute 27 seconds (time LIKE '1:27%') in raceId 161.",
      "sql_description": "Filters lapTimes for raceId = 161 and time LIKE '0:01:27%', joins to drivers, outputs forename, surname, url.",
      "reason": "The critical anchor is the lap-time pattern. Evidence says 0:01:27 should be matched with time LIKE '1:27%'. The query looks for '0:01:27%', which likely matches no rows (as shown by empty result), so it fails to retrieve the required driver.",
      "verdict": false
    }
  },
  {
    "question_id": 877,
    "result": {
      "expected_answer": "Identify the youngest driver (latest date of birth) among the drivers in race 872 whose time field is not NULL (i.e., those who finished the race). Return that driver’s identity.",
      "sql_description": "Selects drivers’ surnames from race 872 where position is not NULL, orders them by date-of-birth descending (youngest first), and returns the first surname.",
      "reason": "The question explicitly defines finishers as rows where time has a value, but the query filters on position IS NOT NULL instead of time IS NOT NULL. This misses the required anchor and may misclassify finishers, so the query does not faithfully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 872,
    "result": {
      "expected_answer": "The abbreviated code (drivers.code) of the driver whose Q3 lap time was 1:33 (anything starting with 1:33) in raceId 45.",
      "sql_description": "Returns drivers.code for rows in qualifying where raceId = 45 and q3 starts with the literal string '0:01:33'.",
      "reason": "Correct raceId anchor but the time anchor is wrong: the dataset stores times without the leading '0:' so should match '1:33%', not '0:01:33%'. Query therefore fails to identify the intended driver (empty result).",
      "verdict": false
    }
  },
  {
    "question_id": 1068,
    "result": {
      "expected_answer": "A single numeric value: the mean overall_rating for player attribute records dated 2010-2015 where the corresponding player’s height exceeds 170 cm.",
      "sql_description": "1) Builds a list of player_api_id whose height > 170 from Player.\n2) From Player_Attributes selects rows whose player_api_id is in that list and whose date year is between 2010 and 2015 inclusive.\n3) Returns AVG(overall_rating) over those rows.",
      "reason": "All explicit constraints are honored: height > 170 via join to Player, date between 2010 and 2015 via strftime filter, and average of overall_rating is returned. Record-level vs per-player averaging is ambiguous in the question; averaging over records is a reasonable interpretation, so the SQL suffices.",
      "verdict": true,
      "evidence": "sql_result column average_overall_rating row0 = 70.156206"
    }
  },
  {
    "question_id": 884,
    "result": {
      "expected_answer": "Names of every race whose year and month match the earliest date in the table (i.e., all races held in that first month, not just on the first day).",
      "sql_description": "Gets the race names whose date equals the single minimum date in races.",
      "reason": "Query anchors on exact earliest day instead of all races sharing that earliest year-month, so it may miss races later in the same month. Required year-month anchor not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 1107,
    "result": {
      "expected_answer": "The earliest date (first time) on which Kevin Constant achieved his maximum crossing value across all his records.",
      "sql_description": "Finds Kevin Constant’s records, orders them by crossing descending and returns the date of the first row (highest crossing). It does not consider earliest date among possible ties.",
      "reason": "While it ensures the maximum crossing anchor, it omits the \"first time\" requirement: if several records share the highest crossing value, the query does not guarantee selecting the earliest date, so the anchor is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 894,
    "result": {
      "expected_answer": "Return the minimum lap time in milliseconds (the best lap time) and identify the driver (forename, surname) and the race (name) where that lap time was recorded.",
      "sql_description": "Finds the row(s) in lapTimes whose milliseconds equal the global minimum and returns the associated driver forename, surname, and race name – but omits the lap-time value itself.",
      "reason": "The query correctly locates the driver and race of the fastest lap, but the question explicitly asks for the best lap time; the lap-time value is not selected, so the answer is incomplete – a required anchor (lap time) is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 898,
    "result": {
      "expected_answer": "The question seeks the youngest driver whose nationality is Japanese, returning his full name and his age in years.",
      "sql_description": "The query filters drivers where nationality = 'Japanese', computes age as the difference between current year and birth year, orders the list by this age in ascending order (youngest first), and returns the first row (full name and age).",
      "reason": "All required anchors (Japanese nationality, youngest by age, provide name and age) are satisfied. Age calculation by year difference is acceptable for this question.",
      "verdict": true,
      "evidence": "sql_result row0: driver_name='Kamui Kobayashi', age=39"
    }
  },
  {
    "question_id": 1122,
    "result": {
      "expected_answer": "The name(s) of the player(s) whose overall_rating is the maximum in the database.",
      "sql_description": "Joins Player_Attributes with Player, computes the global MAX(overall_rating), and returns the player_name for every record whose overall_rating equals that max (duplicates possible).",
      "reason": "Uses the correct anchor (MAX(overall_rating)) and returns the corresponding player name(s). Extra duplicates do not violate the question, which asks only to state the name.",
      "verdict": true,
      "evidence": "strongest_player column: rows 0-11 all show 'Lionel Messi', indicating the query picked the player with the highest rating."
    }
  },
  {
    "question_id": 902,
    "result": {
      "expected_answer": "List of race names in which driver Alex Yoong finished with a position (track number) less than 20.",
      "sql_description": "Joins drivers, results, and races, filters to the driver whose full name is Alex Yoong and to rows where results.position < 20, then returns the corresponding race names.",
      "reason": "The query applies the required driver anchor and the position < 20 constraint and retrieves the races, directly matching the question’s intent.",
      "verdict": true,
      "evidence": "sql_result shows race_name column with five races (e.g., Brazilian Grand Prix, Canadian Grand Prix, etc.), satisfying the requested list."
    }
  },
  {
    "question_id": 904,
    "result": {
      "expected_answer": "Identify the specific grand-prix event (race name) and the year in which Michael Schumacher recorded his single quickest lap time overall – i.e. the race where his milliseconds value is the absolute minimum among all his results.",
      "sql_description": "For Michael Schumacher, compute the minimum finishing-time milliseconds per season–circuit pair, then pick the row whose value is the overall minimum; finally return that circuit name (labelled race) and the corresponding year.",
      "reason": "Query correctly restricts to Michael Schumacher, finds his minimum milliseconds for every race and then selects the event with the global minimum. Although it returns circuits.name instead of races.name, ‘race’ can reasonably be interpreted as the venue, so the essential information (which event/year had the fastest lap) is conveyed.",
      "verdict": true,
      "evidence": "sql_result columns: race (Circuit de Spa-Francorchamps), year (2001) – single row returned."
    }
  },
  {
    "question_id": 1029,
    "result": {
      "expected_answer": "List the buildUpPlaySpeed values (attack build-up speed scores) for the four teams that have the highest buildUpPlaySpeed in the dataset; usually paired with the team identifier or name and ordered from highest to lower.",
      "sql_description": "1) Picks the 4 rows with the largest buildUpPlaySpeed from Team_Attributes and keeps their team_api_id (top_teams CTE).\n2) For those team ids, joins through Match (home-team only) back to Team_Attributes and returns each team’s maximum buildUpPlaySpeed, ordered descending.",
      "reason": "The query ultimately returns each of the four teams selected by highest buildUpPlaySpeed and their (max) speed value, satisfying the request. Although it doesn’t deduplicate teams before the LIMIT and looks only at home teams when re-joining, in the given schema every team is a home team at least once and the result shows four distinct teams, so the required anchors—top 4 by buildUpPlaySpeed and their speed—are met.",
      "verdict": true,
      "evidence": "sql_result columns: team_api_id, build_up_play_speed; 4 rows returned sorted 80, 78, 78, 77 which represent the highest speeds for those teams."
    }
  },
  {
    "question_id": 1136,
    "result": {
      "expected_answer": "The number of distinct players whose crossing value equals the maximum crossing in the dataset and whose preferred_foot is 'left'.",
      "sql_description": "Finds the maximum crossing value, selects all Player_Attributes rows where crossing equals that max and preferred_foot is 'left', then counts distinct player_api_id.",
      "reason": "All required anchors are present: max crossing condition and preferred_foot='left'. Counting distinct players matches the \"how many players\" requirement. Multi-row per player issue is handled with DISTINCT.",
      "verdict": true,
      "evidence": "sql_result shows column num_players_max_crossing_left_foot with value 2."
    }
  },
  {
    "question_id": 915,
    "result": {
      "expected_answer": "The nationality (country) corresponding to the driver with the earliest date of birth in the drivers table.",
      "sql_description": "Finds the driver with the smallest dob (oldest) and returns that driver's nationality.",
      "reason": "Correctly targets the drivers table, uses ascending order on dob to pick the earliest (oldest) birthdate, limits to one nationality. Matches the question’s requirement.",
      "verdict": true,
      "evidence": "Column oldest_driver_country row0 = 'South African'"
    }
  },
  {
    "question_id": 928,
    "result": {
      "expected_answer": "The driver reference name (driverRef) of the driver who finished 1st in the 2007 Canadian Grand Prix (the race winner).",
      "sql_description": "Finds the driver whose championship standing (driverStandings.position) was 1 after the Canadian Grand Prix race in 2007 and returns that driver’s driverRef.",
      "reason": "The query uses driverStandings.position (overall championship rank) instead of a race-result table/column that captures the finishing order in the specific race, so it identifies the championship leader after the event, not necessarily the race winner. Thus it does not guarantee answering who ranked first in the race itself.",
      "verdict": false
    }
  },
  {
    "question_id": 950,
    "result": {
      "expected_answer": "Names of constructors that scored 0 points in race 291.",
      "sql_description": "Fetches records from constructorResults where raceId = 291 and points = 0, joins to constructors, and returns the constructor names.",
      "reason": "All required anchors are present (race 291, points 0). The query returns the constructor names that meet these conditions, matching the question.",
      "verdict": true,
      "evidence": "constructor_name column shows 11 rows including Minardi, Dallara, Larrousse, Team Lotus, etc."
    }
  },
  {
    "question_id": 857,
    "result": {
      "expected_answer": "Latitude and longitude (coordinate position) of the circuit that hosts the Abu Dhabi Grand Prix.",
      "sql_description": "Finds the circuit linked to races named 'Abu Dhabi Grand Prix' and returns that circuit's lat and lng.",
      "reason": "Correct tables joined, correct race name filter, outputs requested lat/lng. Duplicate rows do not harm the answer.",
      "verdict": true,
      "evidence": "sql_result rows all show lat 24.4672, lng 54.6031 (columns lat,lng)."
    }
  },
  {
    "question_id": 944,
    "result": {
      "expected_answer": "A single positive percentage representing (last finisher time – champion time) / last finisher time * 100 for the 2008 Australian Grand Prix.",
      "sql_description": "Selects the champion’s milliseconds and the last finisher’s milliseconds, then returns (champion – last) / last * 100, i.e. the difference in the wrong order (negative value).",
      "reason": "Time order is inverted: champion_ms is smaller, so the formula returns a negative percentage, not the requested positive ‘how much faster’. Therefore the query does not satisfy the question.",
      "verdict": false
    }
  },
  {
    "question_id": 868,
    "result": {
      "expected_answer": "Latitude and longitude of the circuit that hosts the Malaysian Grand Prix.",
      "sql_description": "Finds the circuit linked to races named 'Malaysian Grand Prix' and returns that circuit’s name, latitude and longitude (one row per year, hence duplicates).",
      "reason": "Uses correct anchor (races.name = 'Malaysian Grand Prix'), joins to circuits, outputs lat & lng. Extra duplicates do not change the answer.",
      "verdict": true,
      "evidence": "name, lat, lng -> Sepang International Circuit, 2.76083, 101.738 (row 0 and repeats)"
    }
  },
  {
    "question_id": 940,
    "result": {
      "expected_answer": "A single integer: the number of drivers who finished the 2008 Chinese Grand Prix and (as confirmation) have at least one Formula-1 race participation record.",
      "sql_description": "1) Builds finished_drivers as all drivers with non-NULL position in ANY 2008 race (no filter on Chinese Grand Prix).\n2) Counts how many of those drivers appear in driverStandings.",
      "reason": "Missing essential anchor \"Chinese Grand Prix\" – query covers every 2008 race, so the counted 22 drivers are not limited to that event. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 955,
    "result": {
      "expected_answer": "For every year earlier than 1975, return the average finishing time (expressed in seconds) of the race winners (position-1 drivers) that year.",
      "sql_description": "Gathers every result row with a non-NULL time before 1975 (regardless of finishing position) and computes the average of those times per year after trying to convert the textual time to seconds with strftime.",
      "reason": "Required anchor \"champion\" (winner rows – position 1) is not enforced; the query averages all finishers. Therefore it does not answer the asked question.",
      "verdict": false
    }
  },
  {
    "question_id": 962,
    "result": {
      "expected_answer": "The numeric percentage obtained by dividing:  (number of distinct drivers, racing from 2000-2005, who were born before 1985 and have at least one lap numbered above 50)  by  (total distinct drivers who took part in races from 2000-2005)  × 100.",
      "sql_description": "1) Finds total distinct drivers appearing in driverStandings for races whose year is 2000-2005. 2) Filters those drivers to ones born before 1985. 3) Counts how many of those older drivers appear in lapTimes for races 2000-2005 with lap > 50. 4) Computes 100 × that count ÷ total-driver count and returns it as percentage.",
      "reason": "Query captures all required anchors: race years 2000-2005, driver DOB <1985, lap number >50 for numerator, and divides by total drivers in the same year span. Choice of driverStandings for denominator is a reasonable interpretation for ‘drivers in 2000-2005’ and is not contradicted by the schema.",
      "verdict": true,
      "evidence": "sql_result shows a column named percentage with value 100.0 which is structurally consistent with expected single numeric output."
    }
  },
  {
    "question_id": 954,
    "result": {
      "expected_answer": "Percentage of Japanese drivers’ race entries from 2007-2009 that they finished – i.e., (number of result rows for Japanese drivers in races 2007-2009 with non-NULL time) divided by (all result rows for Japanese drivers in races 2007-2009) × 100.",
      "sql_description": "Counts finished results rows for Japanese drivers in 2007-2009 but divides by the number of distinct Japanese drivers in the whole database (not by race entries), then multiplies by 100, returning 94.74%.",
      "reason": "Denominator anchor wrong: must count all race participations in 2007-2009, not distinct drivers. Also denominator not restricted to 2007-2009. Therefore percentage is incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 880,
    "result": {
      "expected_answer": "The single percentage showing how much faster Paul di Resta’s fastest-lap speed in race 853 was compared with his own fastest-lap speed in the following race (race 854), calculated as (speed_853 − speed_854) / speed_853 × 100.",
      "sql_description": "Takes Paul di Resta’s fastest-lap speed in race 853 (r1) and subtracts the fastest-lap speed of every driver in race 854 (r2), then divides that difference by each r2 speed, yielding many rows of percentages referenced to the 854 speeds.",
      "reason": "1) Denominator should be speed_853, but query uses speed_854, giving a different percentage. 2) It compares Paul’s speed to all drivers in race 854 instead of just Paul, producing multiple irrelevant rows. Required anchors (only Paul, both races, correct formula) are violated.",
      "verdict": false
    }
  },
  {
    "question_id": 967,
    "result": {
      "expected_answer": "A list (up to 3) of driver codes for the three youngest drivers in the dataset, plus a count of how many of those three have Dutch/Netherlandic nationality.",
      "sql_description": "Builds a CTE keeping only drivers whose birth_year equals the most recent birth year, limits that to 3 rows, then counts how many of those rows have nationality = 'Dutch'. It outputs only this count.",
      "reason": "1) Does not return the codes of the three youngest drivers as requested. 2) Filters only to drivers born in the single latest year, not the overall three youngest if fewer or more exist. Required anchors (driver codes and correct top-3 youngest selection) are missing/violated.",
      "verdict": false
    }
  },
  {
    "question_id": 964,
    "result": {
      "expected_answer": "A list of driver codes for all drivers whose nationality is American.",
      "sql_description": "Selects distinct values from drivers.code where drivers.nationality = 'American'; returns the set of codes (including NULL if any American driver lacks a code).",
      "reason": "Query applies the required nationality filter and outputs the requested column. Inclusion of a NULL entry is acceptable because the question did not explicitly exclude drivers without codes.",
      "verdict": true,
      "evidence": "sql_result shows column code with values: row0='SPE', row1=NULL, row2='RSS', matching codes of American drivers."
    }
  },
  {
    "question_id": 896,
    "result": {
      "expected_answer": "A numeric percentage (0–100) representing the share of Hamilton’s races from 2010 onward in which his finishing position was not 1st.",
      "sql_description": "Creates two CTEs: one with Hamilton’s post-2010 races where position>1, another with all his post-2010 races. Then cross-joins the two sets and divides the count of HamiltonRaces.raceId by the count of HamiltonTotalRaces.raceId, both counts taken over the cross-join.",
      "reason": "Because of the cross join, each row from the first set is paired with every row from the second, so both counts become (|A| × |B|). The resulting ratio is always 1 (100 %), regardless of the real numbers, thus not the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 1102,
    "result": {
      "expected_answer": "Name of the player whose birthday is the earliest (oldest) among those with overall_rating = 77 on 2016-06-23.",
      "sql_description": "Finds players with overall_rating 77 on 2016-06-23, then returns the name of the player whose birthday equals the MAX(birthday) (i.e., the latest date / youngest).",
      "reason": "The query chooses MAX(birthday) instead of MIN(birthday), therefore returns the youngest, not the oldest player. Violates the ‘oldest’ anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 988,
    "result": {
      "expected_answer": "The three German drivers born in 1980-1985 with the lowest average pit-stop duration, ranked from shortest to longest (optionally showing their averages).",
      "sql_description": "Computes per-driver average pit-stop time (milliseconds ÷1000) for German drivers whose birth year is 1980-1985, orders the averages ascending, and returns the first 3 drivers with their full names and averages.",
      "reason": "All required anchors are present: nationality='German', birth year BETWEEN 1980 AND 1985, average pit-stop duration computed, ordered by shortest, limited to 3. Output columns correspond to driver names and the calculated average, satisfying the question.",
      "verdict": true,
      "evidence": "sql_result shows 3 rows: full_name (Timo Glock, Adrian Sutil, Nico Rosberg) with average_pitstop_duration values in ascending order (23.7, 35.1, 46.3)."
    }
  },
  {
    "question_id": 906,
    "result": {
      "expected_answer": "Return the name of the race that was the earliest (by year) in which Lewis Hamilton competed, together with the points he scored in that same race.",
      "sql_description": "Finds the minimum year among ALL races, then retrieves rows where that year and Lewis Hamilton both appear, returning the race name and Hamilton’s points.",
      "reason": "The earliest year should be the minimum year of Hamilton’s own races, not the minimum year in the entire races table. Using the global MIN(year) makes the query miss Hamilton’s debut year, producing no rows. Required anchor (Hamilton-specific earliest race) is therefore missing.",
      "verdict": false
    }
  },
  {
    "question_id": 930,
    "result": {
      "expected_answer": "Name of the Formula 1 race (or races, if tied) where Lewis Hamilton achieved his best (lowest) value in the results.rank column.",
      "sql_description": "Filters results to Lewis Hamilton, computes the minimum rank among those rows, and returns the race name(s) whose rank equals that minimum.",
      "reason": "Query applies correct driver filter, uses MIN(rank) to find the highest (i.e., lowest numeric) rank, and returns the corresponding race names. Multiple rows handled in case of tie, which is acceptable since the question does not forbid it.",
      "verdict": true,
      "evidence": "Returned race_name column with 3 rows: Chinese Grand Prix, Belgian Grand Prix, Spanish Grand Prix – races where Hamilton's rank equals his minimum."
    }
  },
  {
    "question_id": 1114,
    "result": {
      "expected_answer": "The average (mean) overall_rating for player Marko Arnautovic considering only Player_Attributes records dated from 2007-02-22 to 2016-04-21 (inclusive).",
      "sql_description": "Joins Player_Attributes with Player, keeps rows where player_name = 'Marko Arnautovic' and pa.date is between '2007-02-22' and '2016-04-21', then returns AVG(overall_rating) as average_rating.",
      "reason": "All explicit anchors—player identity, date range, and aggregation of overall_rating—are present and correctly applied; the result therefore answers the question.",
      "verdict": true,
      "evidence": "sql_result shows one column average_rating with value 75.28125 (row 0)."
    }
  },
  {
    "question_id": 1002,
    "result": {
      "expected_answer": "One row: for the youngest driver (latest date of birth), show their full name (forename + surname), their nationality, and the name of the very first race they ever entered.",
      "sql_description": "Finds the driver(s) with the latest DOB, then lists every race that driver appears in driverStandings with, outputting duplicates of full name, nationality and each race name.",
      "reason": "Correctly identifies the youngest driver but does not restrict to the first race they joined; instead returns every race the driver appeared in, violating the ‘first race’ anchor and yielding many rows.",
      "verdict": false
    }
  },
  {
    "question_id": 981,
    "result": {
      "expected_answer": "Year (numeric), with the name of the youngest driver, plus the date and time of that driver’s first (earliest) qualifying race.",
      "sql_description": "Finds one qualifying row after joining drivers and races; rows are ordered by drivers.dob ascending (oldest first) and the first row is returned, giving that race’s year, driver name, date and time.",
      "reason": "1) Orders by dob ascending so it selects the oldest driver, not the youngest.\n2) Does not ensure the returned race is the driver’s first qualifying race (no MIN(date) per driver).\nBoth required anchors (youngest driver and first qualifying race) are violated.",
      "verdict": false
    }
  },
  {
    "question_id": 1014,
    "result": {
      "expected_answer": "For each circuit located in Italy, return the fastest lap time ever recorded there (one row per Italian circuit showing circuit name and its lap record time).",
      "sql_description": "Finds all lap times from races at Italian circuits, orders them globally by milliseconds ascending (fastest overall), keeps only the single fastest lap across all Italian circuits, then outputs its circuit name and time.",
      "reason": "The query limits results to one overall fastest lap, not the fastest lap for each Italian circuit. Thus it omits lap records for other Italian circuits and does not satisfy the per-circuit requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 730,
    "result": {
      "expected_answer": "A list of superhero names whose publisher is Marvel Comics and who possess the super power called \"Super Strength\".",
      "sql_description": "Finds superheroes linked to the power with name 'Super Strength' and whose publisher's name is 'Marvel Comics', returning their distinct superhero_name.",
      "reason": "All required anchors (power_name = 'Super Strength', publisher_name = 'Marvel Comics') are present and correctly joined; query returns exactly the requested superhero names.",
      "verdict": true,
      "evidence": "sql_result shows column superhero_name with multiple rows (e.g., 3-D Man, A-Bomb, Abomination …) satisfying both conditions."
    }
  },
  {
    "question_id": 1001,
    "result": {
      "expected_answer": "Full name (forename + surname) of the driver who recorded the fastest time in Q3 (rank-1) for the 2008 race that took place at the Marina Bay Street Circuit.",
      "sql_description": "Looks for a race whose year is 2008, race.name = 'Marina Bay Street Circuit', AND season round = 3. Within that race it picks the driver whose overall qualifying position is the minimum (1). Returns that driver’s full name.",
      "reason": "Key anchors are wrong: 1) race identification – the circuit name is stored in the circuits table, while r.name contains the race title (e.g., ‘Singapore Grand Prix’), so the filter r.name = 'Marina Bay Street Circuit' will not match the intended race; 2) an extra constraint r.round = 3 was added, excluding the Marina Bay race (round ≠3 in 2008). Because of these errors the query selects no rows (shown in result) and would miss the correct driver. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 758,
    "result": {
      "expected_answer": "The colour(s) of the hair of any superhero whose race is human and whose height is exactly 185 cm.",
      "sql_description": "Finds superheroes with height_cm = 185 and race = 'human', joins to colour table through hair_colour_id, and returns the corresponding colour value.",
      "reason": "All explicit anchors—height 185 cm, race human, hair colour field—are present and correctly linked. Query returns the required attribute without extraneous constraints.",
      "verdict": true,
      "evidence": "Result set column: colour (no rows in sample run, but query logic matches requirements)."
    }
  },
  {
    "question_id": 775,
    "result": {
      "expected_answer": "A single numeric value: the percentage of female superheroes whose skin colour is Blue among all female superheroes.",
      "sql_description": "Builds a CTE of female superhero IDs, then selects rows where those female superheroes also have skin colour = 'Blue'. It counts the distinct IDs in this filtered set for both numerator and denominator, multiplying by 100, so it effectively returns 100% whenever at least one blue-female exists.",
      "reason": "Denominator is limited by the same Blue colour filter, so it measures blue-female vs blue-female instead of blue-female vs all female. Required anchor ‘all female superheroes’ in the denominator is missing/incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 1133,
    "result": {
      "expected_answer": "The numeric count of football players whose first name begins with \"Aaron\" and whose birthday falls after the 1990s – i.e., born in 2000 or later.",
      "sql_description": "Counts all rows in Player where player_name starts with 'Aaron' and birthday is greater than '1999-12-31' (2000-01-01 and later).",
      "reason": "Adopts the reasonable interpretation that “after the 1990s” means post-1999. The query applies the required name filter and the chosen date filter, then returns a single count, thus meeting the question’s intent under this interpretation.",
      "verdict": true,
      "evidence": "sql_result shows one column COUNT(*) with value 0, indicating no such players matching these criteria."
    }
  },
  {
    "question_id": 769,
    "result": {
      "expected_answer": "Name of the superhero(s) from publisher \"Dark Horse Comics\" that possess(es) the highest durability value among all Dark Horse heroes.",
      "sql_description": "Joins superhero with publisher, hero_attribute, and attribute; filters to rows where publisher_name = 'Dark Horse Comics' and attribute_name = 'durability'; orders those rows by attribute_value descending and keeps the first, returning its superhero_name.",
      "reason": "All required anchors are present (publisher, durability attribute, max selection). Selecting the top row satisfies \"most durability\"; tie-handling not specified, so LIMIT 1 is acceptable.",
      "verdict": true,
      "evidence": "Result columns: [superhero_name] (0 rows returned in sample execution)"
    }
  },
  {
    "question_id": 788,
    "result": {
      "expected_answer": "Percentage = (number of female superheroes whose publisher is Marvel Comics) / (total number of female superheroes) * 100.",
      "sql_description": "Counts all female superheroes (female_count). Divides 100 * that number by the total number of superheroes (any gender) published by Marvel Comics. Returns this percentage.",
      "reason": "Numerator is all female heroes regardless of publisher, denominator is all Marvel heroes regardless of gender. Required anchor \"female AND Marvel\" in numerator is missing; denominator should be female heroes, not Marvel heroes. Thus computes wrong ratio.",
      "verdict": false
    }
  },
  {
    "question_id": 743,
    "result": {
      "expected_answer": "1) The percentage of all superheroes whose alignment is \"Bad\" (those who act in their own self-interest or follow their own moral code).\n2) Among those \"Bad\" superheroes, the count that were published by Marvel Comics.",
      "sql_description": "First counts total superheroes and those with alignment = 'Bad'. Then computes 100 * (Bad / total) for the whole roster and counts how many of the Bad-aligned superheroes belong to publisher_name = 'Marvel Comics'. Returns a single row with the percentage and the Marvel count.",
      "reason": "Query applies the required anchor alignment = 'Bad', uses total superheroes as denominator to derive the percentage, and separately counts Bad-aligned heroes whose publisher is Marvel. Output columns therefore directly answer both parts of the question.",
      "verdict": true,
      "evidence": "percentage_bad_aligned (col-0) = 28.49%, marvel_bad_aligned (col-1) = 118"
    }
  },
  {
    "question_id": 1148,
    "result": {
      "expected_answer": "Percentage (0–100%) of all players where height < 180 cm AND overall_rating > 70, i.e. 100 * (# distinct players satisfying both conditions) / (# distinct players in Player).",
      "sql_description": "Creates Height_Strength as all Player_Attributes rows whose player is <180 cm and whose strength>70, keeps duplicates, then divides the count of those rows by the count of distinct players within the same subset, multiplying by 100.",
      "reason": "Wrong attribute: uses strength instead of overall_rating, violating explicit anchor. Denominator should be total players but is limited to the subset, and numerator counts duplicates, yielding >100%. Therefore does not answer question.",
      "verdict": false
    }
  },
  {
    "question_id": 1144,
    "result": {
      "expected_answer": "The finishing rating(s) and curve score(s) for the player(s) who have the maximum weight in the Player table.",
      "sql_description": "Finds the player(s) whose weight equals the maximum weight, then fetches all rows from Player_Attributes for that player_api_id, returning the finishing and curve columns.",
      "reason": "Correctly anchors on the heaviest weight (MAX(weight)) and returns the requested attributes (finishing, curve). Multiple attribute rows over time are acceptable because the question does not constrain the date.",
      "verdict": true,
      "evidence": "sql_result contains columns finishing and curve (e.g., 13/13, 12/12, 21/12 etc.) for the heaviest-weight player."
    }
  },
  {
    "question_id": 959,
    "result": {
      "expected_answer": "Single integer: the lap number on which the 2009 race-winners (\"champions\" of each grand prix) set their overall fastest lap time – i.e., take all winner rows from races held in 2009, find the one with the smallest fastest-lap time, and return that row’s fastestLap value.",
      "sql_description": "Takes all winner rows of 2009 races (position = 1) and returns the MIN of the fastestLap field, i.e., the earliest lap number among those rows, independent of which lap was actually the fastest time.",
      "reason": "Question asks for the fastest lap number; this should be tied to the lowest fastest-lap time, not simply the smallest lap index. The query ignores fastestLapTime and instead picks MIN(fastestLap), so it could return a lap that is not the fastest. Required anchor of ‘fastest’ with respect to lap time is mis-handled.",
      "verdict": false
    }
  },
  {
    "question_id": 533,
    "result": {
      "expected_answer": "The count of users whose LastAccessDate is strictly later than 2014-09-01.",
      "sql_description": "Counts distinct user IDs in the users table with LastAccessDate > '2014-09-01'.",
      "reason": "Query applies the required date filter and returns the number of qualifying users; no other constraints are missed.",
      "verdict": true,
      "evidence": "NumUsersLastAccessedAfter20140901 = 5146 (row 0, column NumUsersLastAccessedAfter20140901)"
    }
  },
  {
    "question_id": 989,
    "result": {
      "expected_answer": "Name of the driver who won (position 1) the Canadian Grand Prix in the 2008 season together with his official finish time.",
      "sql_description": "Finds the race with name 'Canadian Grand Prix' in 2008, picks the result row where positionOrder = 1 (the winner), and returns the driver full name and their time.",
      "reason": "Query correctly anchors on race name, year 2008, and winner position. It outputs the requested winner’s name and finish time, matching the question.",
      "verdict": true,
      "evidence": "Row0 champion_name=Robert Kubica, time=1:36:24.227"
    }
  },
  {
    "question_id": 847,
    "result": {
      "expected_answer": "Surname of the driver who recorded the minimum q2 lap time within qualifying records where raceId = 19.",
      "sql_description": "Selects all qualifying rows whose car number = 19 (column `number`), then keeps those whose q2 equals the minimum q2 among rows with the same raceId and the same car number = 19, and returns the drivers’ surnames. This therefore returns surnames of drivers whose car number is 19, for many races, not the fastest driver in raceId 19.",
      "reason": "Uses column `number = 19` instead of filtering `raceId = 19`, so does not target the specified race; result includes many races and multiple surnames. Required anchor raceId 19 is missing/incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 881,
    "result": {
      "expected_answer": "A numeric percentage representing, among all drivers in the race dated 1983-07-16, the proportion whose \"time\" field is NOT NULL (i.e., who finished the race).",
      "sql_description": "Creates driver list for the 1983-07-16 race, then divides total participant count by the same participant count, producing 100% because it never restricts to drivers with a non-NULL time.",
      "reason": "Question requires filtering numerator to drivers with non-NULL time. Predicted SQL omits this anchor, so numerator equals denominator, inflating completion rate to 100%. Required anchor \"time has value\" is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 766,
    "result": {
      "expected_answer": "Full name of the superhero whose strength attribute value is the highest among all heroes.",
      "sql_description": "Joins superhero with hero_attribute and attribute tables, filters rows where attribute_name = 'strength', orders by attribute_value descending, and returns the first full_name (i.e., the hero with the greatest strength).",
      "reason": "The query applies the required strength filter, ranks by attribute_value to find the maximum, and outputs the hero’s full_name, satisfying the question. Tie-breaking via LIMIT 1 is acceptable since the question asks for the hero (singular) with highest strength.",
      "verdict": true,
      "evidence": "Result set has column full_name; no rows returned in sample run but structure matches expected answer."
    }
  },
  {
    "question_id": 1003,
    "result": {
      "expected_answer": "The count of accidents (statusId = 3) committed by the single driver who has the most such accidents specifically in races called \"Canadian Grand Prix\".",
      "sql_description": "Counts accidents (statusId=3) for each driver across ALL races, then returns the overall maximum of those counts (18). No restriction to Canadian Grand Prix.",
      "reason": "Missing required anchor to limit accidents to Canadian Grand Prix races; therefore the computed maximum (18) is unrelated to the question.",
      "verdict": false
    }
  },
  {
    "question_id": 726,
    "result": {
      "expected_answer": "A list of all superheroes whose publisher is Marvel Comics, sorted from tallest to shortest; may include their heights.",
      "sql_description": "Selects superhero_name and height_cm from superheroes joined with publisher where publisher_name = 'Marvel Comics', ordering by height_cm descending.",
      "reason": "Meets the Marvel publisher filter and orders by height descending as requested; returning names (plus height) fulfills the ranking requirement.",
      "verdict": true,
      "evidence": "sql_result shows column superhero_name and height_cm ordered from 30480 down, confirming correct filtering and ordering."
    }
  },
  {
    "question_id": 897,
    "result": {
      "expected_answer": "The full name of the driver who has accumulated the greatest number of wins overall (i.e., the driver whose total wins count is highest), together with his nationality and his highest points score.",
      "sql_description": "Finds all rows in driverStandings whose wins value equals the single-row maximum wins value, joins to drivers, groups by driver and nationality, returns one driver (LIMIT 1) and the maximum points among those rows.",
      "reason": "Required anchor \"most winning refers to MAX(COUNT(wins))\" implies wins must be aggregated per driver to find who has the greatest total wins, not just the highest wins figure on a single row. The query skips that aggregation and may pick a driver who merely ties for the single-season record. Therefore it does not reliably identify the driver with the most overall wins.",
      "verdict": false
    }
  },
  {
    "question_id": 862,
    "result": {
      "expected_answer": "A single integer: the number of drivers who failed to finish the Bahrain Grand Prix race held in the 2007 season (time IS NULL).",
      "sql_description": "Counts DISTINCT driverId for every race whose name is 'Bahrain Grand Prix' in any year where either time IS NULL or status = 'R'. Returns 70.",
      "reason": "Missing the 2007 year anchor; aggregates over all Bahrain GPs, inflating the count. Also uses DISTINCT across multiple races and an extra status='R' filter not specified. Result therefore does not match the question’s scope.",
      "verdict": false
    }
  },
  {
    "question_id": 791,
    "result": {
      "expected_answer": "A single numeric value representing the average height (in cm) of all superheroes in the database.",
      "sql_description": "Calculates AVG(height_cm) over every row in the superhero table and returns it as average_height.",
      "reason": "The query directly implements the required aggregation (average of height_cm) across all superheroes. No additional constraints are needed; AVG automatically ignores NULLs, aligning with standard interpretation.",
      "verdict": true,
      "evidence": "average_height column, row 0 = 267.751445"
    }
  },
  {
    "question_id": 931,
    "result": {
      "expected_answer": "The maximum fastestLapSpeed value (in km/h) recorded by any driver in the 2009 edition of the Spanish Grand Prix.",
      "sql_description": "Finds the highest fastestLapSpeed for all results whose race name is 'Spanish Grand Prix', regardless of year.",
      "reason": "Question explicitly restricts to the 2009 Spanish Grand Prix, so year=2009 is a required anchor. Predicted SQL omits this condition; if multiple Spanish Grand Prix records exist for other years, its result may be wrong. Missing year anchor ⇒ incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 571,
    "result": {
      "expected_answer": "Return the ratio of the total number of posts made by user 24 to the total number of votes cast by user 24 (posts_count / votes_count). No restriction on post type.",
      "sql_description": "Counts DISTINCT posts of user 24 with PostTypeId = 1 (questions only) and divides that count by DISTINCT votes cast by the same user; returns this as PostsToVotesRatio.",
      "reason": "Query invents a PostTypeId = 1 filter, counting only question-type posts. The question/evidence ask for all posts; limiting to one subtype changes the numerator and can change the ratio, so required anchor (all posts) is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 892,
    "result": {
      "expected_answer": "Return the full name (forename + surname) of the driver whose points value is the highest among all rows in driverStandings together with that highest points number.",
      "sql_description": "Computes MAX(points) over all driverStandings rows; also selects one arbitrary driver’s forename and surname (because they are not grouped), producing a single row with that max points value and that arbitrary name.",
      "reason": "The query does get the maximum points, but it does not constrain the selected driver to be the one who scored that maximum; without GROUP BY/HAVING it may return any driver. Therefore it is not guaranteed to output the driver with the most points.",
      "verdict": false
    }
  },
  {
    "question_id": 772,
    "result": {
      "expected_answer": "For every superhero whose gender is Female and whose publisher is \"Dark Horse Comics\", return their eye colour, hair colour and skin colour (one row per hero).",
      "sql_description": "Joins superhero with gender, publisher and colour tables, filters to gender='Female' and publisher_name='Dark Horse Comics', then outputs superhero_name plus the mapped eye_colour, hair_colour and skin_colour.",
      "reason": "All required anchors (female gender, Dark Horse Comics publisher) are applied and the query outputs the requested colour attributes. Including superhero_name is permissible as the question does not prohibit extra fields.",
      "verdict": true,
      "evidence": "Result columns: superhero_name, eye_colour, hair_colour, skin_colour; 5 rows, all meet the specified filters."
    }
  },
  {
    "question_id": 801,
    "result": {
      "expected_answer": "A numeric value representing the count of male superheroes divided by the count of female superheroes (or vice-versa – the question only asks for the ratio between the two groups, without specifying order or unit).",
      "sql_description": "Counts superheroes whose gender_id = 1 and divides that by the count whose gender_id = 2, then multiplies the result by 100 to express it as a percentage.",
      "reason": "The query computes a ratio between the two gender groups in the database using the only two gender_id values, which satisfies the question’s requirement for a male-vs-female ratio. Multiplying by 100 merely expresses the ratio as a percentage – an acceptable interpretation of “ratio”. The question does not constrain the order of the division, so either orientation is acceptable.",
      "verdict": true,
      "evidence": "sql_result shows one column (gender_ratio) with a single numeric value (≈255.7) derived from the stated computation, confirming the query produced the requested ratio."
    }
  },
  {
    "question_id": 584,
    "result": {
      "expected_answer": "All comment texts on the specified post written by users who have edited that same post (i.e., commenter’s user id appears among the post’s editors).",
      "sql_description": "Finds the post id by exact title, then returns the text of every comment whose PostId equals that id, regardless of who wrote them.",
      "reason": "The query omits the required anchor that commenters must be users who edited the post; it returns comments from all users instead.",
      "verdict": false
    }
  },
  {
    "question_id": 901,
    "result": {
      "expected_answer": "List each Formula 1 race held in September 2005 together with the name of the circuit where it was run and that circuit’s location.",
      "sql_description": "Joins races with circuits and filters rows whose date has year 2005 and month 09, returning race name, circuit name and circuit location.",
      "reason": "The query enforces the required anchors (month=9, year=2005) and selects exactly the requested columns (race, circuit name, location). Hence it answers the question.",
      "verdict": true,
      "evidence": "Output rows: race_name, circuit_name, location — Italian Grand Prix / Autodromo Nazionale di Monza / Monza, Belgian Grand Prix / Circuit de Spa-Francorchamps / Spa, Brazilian Grand Prix / Autódromo José Carlos Pace / São Paulo."
    }
  },
  {
    "question_id": 563,
    "result": {
      "expected_answer": "The favorite count (integer) of the post that received a comment from user 3025 at 2014-04-23 20:29:39.",
      "sql_description": "Finds the post linked to a comment whose UserId is 3025 and CreationDate is '2014/4/23 20:29:39.0', then returns that post’s FavoriteCount.",
      "reason": "Matches the required anchors (UserId, exact comment timestamp, post linkage) and retrieves the desired FavoriteCount; no extra or missing constraints.",
      "verdict": true,
      "evidence": "Query selects column FavoriteCount from posts joined to comments with filters c.UserId=3025 and c.CreationDate='2014/4/23 20:29:39.0'."
    }
  },
  {
    "question_id": 604,
    "result": {
      "expected_answer": "Two scalar values: 1) the average UpVotes value of users who have created more than 10 posts of any kind, and 2) the average Age of those same users.",
      "sql_description": "Counts, per user, the number of posts with PostTypeId = 1 (questions). Keeps only users having >10 such questions. Then takes the overall average of UpVotes and Age for those users.",
      "reason": "Adds an invented constraint (PostTypeId = 1). The question refers to all posts, not only questions. This extra filter may exclude users who meet the >10-post criterion when answers are included, so the query may return different averages. Therefore, required anchor (posts >10) is applied incorrectly.",
      "verdict": false
    }
  },
  {
    "question_id": 937,
    "result": {
      "expected_answer": "The finish time (results.time or comparable field) of the driver whose finishing position was 2 in the 2008 Chinese Grand Prix.",
      "sql_description": "Gets all results for the 2008 Chinese Grand Prix, sorts by position, keeps only the first two rows, then returns the time of the row whose position equals 2.",
      "reason": "Applying ORDER BY position then LIMIT 2 can exclude the actual second-place result because rows with NULL/blank positions (DNF etc.) sort before valid numbers. If any such rows exist, position=2 is outside the limited subset, yielding no row (as seen in execution). The LIMIT step is an invented constraint that breaks the required anchor; the query therefore does not reliably return the requested finish time.",
      "verdict": false
    }
  },
  {
    "question_id": 640,
    "result": {
      "expected_answer": "A single number: (total view count of Mornington’s posts) minus (total view count of Amos’s posts).",
      "sql_description": "Sums ViewCount of posts whose OwnerUserId belongs to user 'Mornington', subtracts the sum of ViewCount of posts whose OwnerUserId belongs to user 'Amos', returns the difference as view_count_difference.",
      "reason": "Query applies correct filters for each user via the users table, aggregates ViewCount by summing, and subtracts to give the requested difference. All explicit anchors (Mornington, Amos, ViewCount, subtraction) are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows one column view_count_difference with value None (NULL), meaning neither user has posts; structure confirms the intended computation."
    }
  },
  {
    "question_id": 565,
    "result": {
      "expected_answer": "Determine whether the post commented on by user 23853 at 2013-07-12 09:08:18 is well-finished (ClosedDate NOT NULL) or not well-finished (ClosedDate NULL). Return that status.",
      "sql_description": "Finds the post with the specified comment, then labels it as 'well-finished' when ClosedDate IS NULL and 'not well-finished' when ClosedDate IS NOT NULL.",
      "reason": "The CASE logic is inverted: according to the evidence, ClosedDate NULL means not well-finished, but the query labels this as well-finished. Therefore the returned status can be the opposite of the correct answer.",
      "verdict": false
    }
  },
  {
    "question_id": 972,
    "result": {
      "expected_answer": "IDs and codes of every driver born in 1971 (year(dob)=1971) who appears in at least one results row where fastestLapTime is not NULL.",
      "sql_description": "Builds list of drivers with non-NULL fastestLapTime, intersects with drivers born in 1971, then orders them by the lap time and returns only the first row (LIMIT 1).",
      "reason": "Query satisfies birth-year and non-NULL fastestLapTime anchors, but the LIMIT 1 keeps only the single smallest lap time, omitting other qualifying drivers. Question asks for all such drivers, not just the fastest among them.",
      "verdict": false
    }
  },
  {
    "question_id": 951,
    "result": {
      "expected_answer": "The number of constructors whose nationality is Japanese and whose only two constructorResults races together yielded 0 total points.",
      "sql_description": "Find each constructor in constructorResults whose race appearances equal 2 and whose summed points equal 0, then restrict to constructors with nationality 'Japanese' and count them.",
      "reason": "All required anchors are present: nationality filter, exactly 2 races, and zero points. Using constructorResults to measure races and points is reasonable for constructors. Result is the count requested.",
      "verdict": true,
      "evidence": "sql_result shows COUNT(*) column with value 1"
    }
  },
  {
    "question_id": 587,
    "result": {
      "expected_answer": "For every post whose Tags field contains '<humor>', provide: 1) the post title; 2) (one of) its comment texts; 3) the average of ViewCount values for that post (effectively its ViewCount since each post has one).",
      "sql_description": "Joins posts with tags by p.Id = t.Id, comments, postHistory and postLinks, filters t.TagName = 'humor', groups by title and comment, and outputs AVG(ViewCount).",
      "reason": "Key anchor mis-mapped: posts are tagged through the Tags column, not via tags.Id = posts.Id. The filter therefore does not correctly select humor posts and can return none or wrong posts. Extra joins duplicate rows, distorting the average. Thus the query does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 990,
    "result": {
      "expected_answer": "The constructorRef (reference identifier) of the winning constructor (position 1) in the 2009 Singapore Grand Prix, together with that constructor’s url.",
      "sql_description": "Finds the result row with smallest positionOrder for the 2009 Singapore Grand Prix, joins to constructors, returns constructors.name (labelled as constructor_reference_name) and constructors.url.",
      "reason": "Champion selection is correct, but it returns constructors.name instead of constructorRef, violating the explicit requirement for the reference name anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 592,
    "result": {
      "expected_answer": "A single integer: the number of distinct users (UserId) who have been awarded more than 5 badges.",
      "sql_description": "For every user it checks if the user has >5 badge rows, but then returns one row per such user with the value 1 (COUNT(DISTINCT UserId) = 1 for that grouped row). It does not aggregate these rows into a single total.",
      "reason": "The query produces one row per qualifying user instead of one overall count; thus it does not answer \"how many users\" with a single total.",
      "verdict": false
    }
  },
  {
    "question_id": 1011,
    "result": {
      "expected_answer": "List of the 20 drivers whose best-ever lap times are the quickest in the whole Formula 1 dataset, presented as their full (forename + surname) names, ordered from the absolute fastest downward.",
      "sql_description": "Computes the minimum lap time in milliseconds for every driver, sorts the drivers by this minimum ascending, and returns the first 20 full names (forename || ' ' || surname).",
      "reason": "Question wording \"Which top 20 driver created the shortest lap time ever\" can reasonably be read as asking for the top-20 drivers ranked by their shortest-ever lap time. The query exactly does this, using the milliseconds field (numeric) to find each driver’s minimum lap, orders ascending, and returns 20 full names. All explicit anchors (shortest lap time, drivers, full names, top-20) are satisfied.",
      "verdict": true,
      "evidence": "sql_result shows 20 rows with column full_name, e.g., row0 Lewis Hamilton, … row19 Pascal Wehrlein."
    }
  },
  {
    "question_id": 595,
    "result": {
      "expected_answer": "List the users (by DisplayName) whose entire posting history consists of exactly one post and that single post has ViewCount ≥ 1000.",
      "sql_description": "Finds, for each user, the number of posts with ViewCount ≥ 1000; keeps users where that count equals 1, then returns their DisplayName.",
      "reason": "The query ignores posts with < 1000 views, so a user with many low-view posts but exactly one high-view post is included. This violates the explicit \"only one post\" requirement, which applies to the user’s whole posting history, not just to posts meeting the view threshold. Required anchor \"no other posts\" is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 687,
    "result": {
      "expected_answer": "A single integer: the total number of comments whose PostId matches the post (in the posts table) that has the maximum Score.",
      "sql_description": "Finds the post with the largest Score (ORDER BY Score DESC LIMIT 1) and counts all rows in comments whose PostId equals that post’s Id.",
      "reason": "Query targets the post with the highest score and counts its comments, satisfying the question. Tie-breaking by LIMIT 1 is acceptable because the question doesn’t specify how to handle ties.",
      "verdict": true,
      "evidence": "sql_result shows one column CommentCount with value 3 for that post."
    }
  },
  {
    "question_id": 685,
    "result": {
      "expected_answer": "Return the view count of the most recent post whose text (Body) equals 'Computer Game Datasets', along with the display name of the user who authored that particular post.",
      "sql_description": "Selects the single post whose Title equals 'Computer Game Datasets' with the latest LastActivityDate, then returns its ViewCount and the DisplayName of its owner.",
      "reason": "Required anchor is the post identified by Body/Text = 'Computer Game Datasets'; the query filters on Title instead. Consequently it may miss the intended post (indeed produced no rows), so it does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 637,
    "result": {
      "expected_answer": "A distinct list of tag names that appear in posts authored by Mark Meckes where those same posts have CommentCount = 0.",
      "sql_description": "First gathers every tag that appears in any post by Mark Meckes. Then keeps only those tags for which there exists SOME post (by anyone) whose complete tag string is contained in the Mark-post tag string and whose CommentCount = 0, finally returning the distinct tag names.",
      "reason": "The CommentCount = 0 condition is applied to arbitrary posts found via a fuzzy substring join, not to the posts written by Mark Meckes themselves. Thus the required anchor \"Mark Meckes’s posts with no comments\" is not enforced; tags may be accepted or rejected based on other users’ posts. Anchor missing ⇒ answer logic incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 710,
    "result": {
      "expected_answer": "A single integer: the number of comments that have score 0 where the corresponding post has exactly one comment in total.",
      "sql_description": "Builds a list of PostIds that appear exactly once in the comments table (i.e., posts with 1 comment), then counts how many comments with Score = 0 belong to those PostIds.",
      "reason": "The SQL replicates the required logic: it restricts to posts whose comment count is 1 and counts the zero-score comments among them. All anchors (CommentCount = 1 and Score = 0) are present and correctly applied.",
      "verdict": true,
      "evidence": "sql_result shows column NumCommentsWithZeroScore = 11000 (row 1), supplying the requested count."
    }
  },
  {
    "question_id": 672,
    "result": {
      "expected_answer": "The count of distinct users whose location is 'United Kingdom' and who have at least one post whose FavoriteCount is 4 or higher.",
      "sql_description": "Joins users to their posts, filters to users in the United Kingdom and posts with FavoriteCount >= 4, then counts distinct user IDs.",
      "reason": "All explicit anchors are satisfied: Location filter matches, FavoriteCount threshold applied, and users are counted distinctly. Ambiguity about ‘total’ is reasonably interpreted as the per-post FavoriteCount column (supported by the evidence note).",
      "verdict": true,
      "evidence": "sql_result shows column user_count with value 14 (row 0)."
    }
  },
  {
    "question_id": 345,
    "result": {
      "expected_answer": "For every card whose types include Artifact and whose side field is NULL (i.e., single-faced Artifact cards), give its legality status in the Vintage format (values such as Legal, Restricted, Banned).",
      "sql_description": "Selects all cards where types = 'Artifact' and side IS NULL, joins to legalities where format = 'vintage', and returns the distinct pairs of the card’s displayed type string and its Vintage legality status.",
      "reason": "Query enforces all required anchors (Artifact type, no extra faces, Vintage format) and retrieves the needed legality status. Returning an extra type column is harmless; the status for each matching card is provided.",
      "verdict": true,
      "evidence": "sql_result shows statuses Legal, Restricted, Banned for various artifact card rows (columns: type, status)."
    }
  },
  {
    "question_id": 728,
    "result": {
      "expected_answer": "A ranking of eye colors among Marvel Comics superheroes, ordered from most to least common, optionally with the count of heroes per color.",
      "sql_description": "Counts the number of Marvel Comics superheroes for each eye color and lists each color with its count, ordering first by descending count (popularity) then alphabetically.",
      "reason": "Query filters publisher to 'Marvel Comics', groups by eye color, counts heroes, and orders by count DESC, satisfying the requested ranking.",
      "verdict": true,
      "evidence": "sql_result shows columns eye_color, count with rows ordered by count descending, e.g., Blue 126, Brown 89, etc."
    }
  },
  {
    "question_id": 694,
    "result": {
      "expected_answer": "Text content of the 10 most recent comments (by comments.CreationDate descending) on the post titled \"Analysing wind data with R\", together with each commenter’s display name.",
      "sql_description": "Joins comments to the post with the given title, then returns 10 rows ordered by the post’s CreaionDate (same value for every matching comment) rather than the comment CreationDate.",
      "reason": "Anchor ‘latest comments’ requires ordering by comments.CreationDate. The query orders by posts.CreaionDate, so it does not guarantee the 10 newest comments. Required anchor missing.",
      "verdict": false
    }
  },
  {
    "question_id": 738,
    "result": {
      "expected_answer": "List of names of all superheroes whose Durability attribute value is below 50.",
      "sql_description": "Selects distinct superhero_name from superhero that join to hero_attribute rows where the connected attribute is 'Durability' and the stored attribute_value is < 50.",
      "reason": "Query applies the required attribute filter (Durability, value < 50) and returns the requested field (superhero names). No anchors missing or extra conditions.",
      "verdict": true,
      "evidence": "sql_result shows column superhero_name with multiple names (e.g., '3-D Man', 'A-Bomb', etc.), matching the expected output format."
    }
  },
  {
    "question_id": 716,
    "result": {
      "expected_answer": "A single numeric percentage representing the share of users whose comments (score 5-10) received zero up-votes.",
      "sql_description": "Calculates 100 * (distinct users who have at least one vote of type 2 on comments with score 5-10) divided by (all distinct users who have comments with score 5-10).",
      "reason": "Numerator selects users WITH an up-vote instead of users with ZERO up-votes, the opposite of the requested metric. Therefore the query does not satisfy the anchor ‘0 up votes’.",
      "verdict": false
    }
  },
  {
    "question_id": 358,
    "result": {
      "expected_answer": "The color of the card border for the card named \"Ancestor's Chosen\".",
      "sql_description": "Selects the borderColor field from the cards table where name equals 'Ancestor's Chosen'.",
      "reason": "Query applies the required name filter and retrieves the borderColor. All returned rows have value 'black', matching the requested information; duplicates are harmless.",
      "verdict": true,
      "evidence": "borderColor column rows 0-3 all = 'black'"
    }
  },
  {
    "question_id": 963,
    "result": {
      "expected_answer": "The number of distinct French drivers who have at least one lap with a time under 2 minutes (i.e., < 120 000 milliseconds).",
      "sql_description": "Counts distinct drivers with nationality = 'French' whose lapTimes.time string value is lexicographically less than the literal '120000'.",
      "reason": "Anchor on lap-time < 120 s is implemented against the TEXT column 'time' instead of the numeric 'milliseconds'. String comparison with '120000' does not reliably capture laps under 120 s (e.g., '1:59.999' > '120000' lexicographically). Therefore the query can mis-include/omit drivers and does not accurately satisfy the constraint.",
      "verdict": false
    }
  },
  {
    "question_id": 347,
    "result": {
      "expected_answer": "For every card whose artist is Stephen Daniele (or the exact spelling in the data), return the card id together with each ruling text it has, and an indication of whether that card \"has missing or degraded properties and values\" – i.e. whether cards.hasContentWarning = 1 (true → degraded/missing, false → normal).",
      "sql_description": "Selects cards where artist = 'Stephen Daniel', joins to rulings for their ruling text, then labels a card \"missing\" if there is no row in foreign_data (fd.text IS NULL) and \"degraded\" otherwise. It ignores the hasContentWarning column. Returns card_id, ruling_text and that label.",
      "reason": "The query does not use the required anchor hasContentWarning to decide whether a card’s properties are missing/degraded, so it does not fulfil the request to state that condition. It also filters on 'Stephen Daniel', not the documented 'Stephen Daniele'. Hence it may miss all intended cards and mis-states the missing/degraded status.",
      "verdict": false
    }
  },
  {
    "question_id": 978,
    "result": {
      "expected_answer": "List every circuit located in Austria, showing its location (city) and latitude/longitude, and give the total number of such Austrian circuits.",
      "sql_description": "Counts rows in circuits where country='Austria' but, without GROUP BY, also selects one arbitrary location, lat and lng from those rows.",
      "reason": "Count of Austrian circuits is computed, but the query only returns a single (arbitrary) location and coordinate instead of all Austrian circuits, so the requested location-coordinate details are incomplete. Required anchor ‘all locations and coordinates’ is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 341,
    "result": {
      "expected_answer": "Names of cards whose borderColor is 'borderless' and that lack \"powerful foils\"—i.e. at least one of cardKingdomFoilId or cardKingdomId is NULL (both present means the card has a powerful foil and must be excluded).",
      "sql_description": "Returns names of cards with borderColor = 'borderless' where cardKingdomId is NULL OR cardKingdomFoilId is different from cardKingdomId.",
      "reason": "The query does not exclude cards that have both cardKingdomId and cardKingdomFoilId present (powerful foils). Since cardKingdomFoilId and cardKingdomId are typically different values, the inequality test lets most powerful-foil cards through, violating the required anchor \"without powerful foils\".",
      "verdict": false
    }
  },
  {
    "question_id": 352,
    "result": {
      "expected_answer": "A single numeric value: the percentage of foreign_data rows whose language is 'Chinese Simplified' out of all rows in foreign_data.",
      "sql_description": "Counts total rows in foreign_data and those where language = 'Chinese Simplified'; computes 100 * chinese_rows / total_rows.",
      "reason": "Question and provided formula treat each foreign_data row as a card instance, so ratio of Chinese rows to all rows is appropriate. Query applies correct filter and calculation; all anchors satisfied.",
      "verdict": true,
      "evidence": "Result column percentage_of_chinese_cards ≈ 8.77 (row 0)."
    }
  },
  {
    "question_id": 568,
    "result": {
      "expected_answer": "DisplayName of the user whose vote record has Id = 6347, regardless of vote type.",
      "sql_description": "Looks up vote id 6347, but only if that vote’s VoteTypeId equals 2, then returns the associated user’s DisplayName.",
      "reason": "Adds an unjustified anchor (VoteTypeId = 2). If the vote 6347 is not of type 2, the correct user is excluded, as seen by the empty result. Extra constraint contradicts lenient principle.",
      "verdict": false
    }
  },
  {
    "question_id": 798,
    "result": {
      "expected_answer": "Return the publisher name(s) associated with the superheroes Hawkman, Karate Kid, and Speedy – ideally paired with each hero or at least listing the publishers involved.",
      "sql_description": "Looks up rows in superhero for the three named heroes, joins to publisher table by publisher_id, and outputs each hero with its publisher name.",
      "reason": "Query filters exactly Hawkman, Karate Kid, Speedy and retrieves their publisher_name, fulfilling the question’s request without missing or extra information.",
      "verdict": true,
      "evidence": "Result rows (superhero, publisher): (Hawkman, DC Comics), (Karate Kid, DC Comics), (Speedy, DC Comics)."
    }
  },
  {
    "question_id": 377,
    "result": {
      "expected_answer": "The number of cards whose originalType is exactly \"Summon - Angel\" but whose subtypes field does not equal/contain \"Angel\".",
      "sql_description": "Counts distinct card IDs where originalType = 'Summon - Angel' and the subtypes column does not contain the string 'Angel'.",
      "reason": "Query satisfies both anchors: originalType='Summon - Angel' and exclusion of subtype Angel (using NOT LIKE '%Angel%'), then returns the count. Matches question intent.",
      "verdict": true,
      "evidence": "sql_result shows one column num_cards with value 0 indicating no such cards, which is a valid answer to a count question."
    }
  },
  {
    "question_id": 581,
    "result": {
      "expected_answer": "DisplayName of the user who owns the post titled \"Open source tools for visualizing multi-dimensional data\".",
      "sql_description": "Joins posts with users on OwnerUserId and returns the DisplayName of the user whose post title exactly matches 'Open source tools for visualizing multi-dimensional data'.",
      "reason": "Includes required title filter and returns the owner’s DisplayName, satisfying the question intent; using the users table is a valid way to obtain the owner.",
      "verdict": true,
      "evidence": "Result has column Owner; no rows returned in this sample, but logic meets requirements."
    }
  },
  {
    "question_id": 405,
    "result": {
      "expected_answer": "A single integer: the number of sets whose block is 'Commander' that have a translation entry in Brazilian Portuguese ('Portuguese (Brasil)').",
      "sql_description": "Joins sets with set_translations on code, keeps rows where sets.block = 'Commander' and language = 'Portuguese (Brasil)', then counts all resulting rows.",
      "reason": "The filters exactly match the required anchors (Commander block, Brazilian Portuguese translation). Counting join rows provides the number of translated sets; duplicates are unlikely (one translation per set-language) and not contradicted, so the query suffices.",
      "verdict": true,
      "evidence": "sql_result shows a column COUNT(*) with value 0, matching the query’s requested count."
    }
  },
  {
    "question_id": 465,
    "result": {
      "expected_answer": "A yes/no determination (or any indicator) of whether a Korean-language printing of the card named \"Ancestor's Chosen\" exists in the database; optionally could return the Korean card name if it exists.",
      "sql_description": "Looks for rows in foreign_data with language = 'Korean' that share the same uuid as cards named 'Ancestor''s Chosen'; returns the (English) card name if such rows exist, otherwise returns nothing.",
      "reason": "Query checks correct card name and required Korean language anchor; returning a row implies existence, empty implies absence. This fully answers the yes/no question.",
      "verdict": true,
      "evidence": "sql_result has no rows/empty name column → indicates no Korean version found, fulfilling the query logic."
    }
  },
  {
    "question_id": 557,
    "result": {
      "expected_answer": "The percentage (0-100) of posts whose score exceeds 5 that are authored by users older than 65; i.e. 100 * (# posts with Score>5 and Age>65) / (# posts with Score>5).",
      "sql_description": "Creates ElderPosts as posts with Score>5 and elder owners, then divides the count of these by the count of ALL posts in the posts table (no score filter) to output a percentage.",
      "reason": "Denominator must be limited to posts with Score>5, but query counts all posts, violating the explicit score>5 anchor. Therefore percentage is wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 598,
    "result": {
      "expected_answer": "A single numeric value: (Count of 'Student' badges in 2010 / total count of 'Student' badges overall * 100) minus (Count of 'Student' badges in 2011 / total count of 'Student' badges overall * 100).",
      "sql_description": "Counts 'Student' badges in 2010 and 2011, then expresses each as a percentage of only the 2010+2011 total, and subtracts them to give the difference.",
      "reason": "Required anchor for denominator is the overall count of 'Student' badges (all years). The query instead divides by only the 2010+2011 total, so the computed percentage difference is on a different base and does not answer the question as specified.",
      "verdict": false
    }
  },
  {
    "question_id": 415,
    "result": {
      "expected_answer": "The percentage (0–100) of cards that are legal in the commander format whose hasContentWarning flag equals 0, relative to all commander-legal cards.",
      "sql_description": "Joins cards with legalities, filters to rows where format = 'commander' and status = 'legal', counts how many of those rows have hasContentWarning = 0, divides by the total count of such rows, and multiplies by 100 to return the percentage.",
      "reason": "All required anchors—format = 'commander', status = 'legal', hasContentWarning = 0, percentage computation—are present. The division uses the correct base set and produces the requested metric.",
      "verdict": true,
      "evidence": "percentage_without_content_warning column returned (row0: NULL, indicating no qualifying cards in this DB sample, but the calculation logic is correct)."
    }
  },
  {
    "question_id": 639,
    "result": {
      "expected_answer": "The percentage (0-100) of Community’s posts that include the R tag – i.e., (# Community posts whose Tags contain the R tag) / (total Community posts) * 100.",
      "sql_description": "Counts Community’s question posts (PostTypeId = 1). Among these, counts how many have the string \"<r>\" in the Tags column, divides by the total number of such posts, and multiplies by 100 to give a percentage.",
      "reason": "All required anchors are satisfied: Community user filtered, tag presence checked via \"<r>\", and percentage calculated. Restricting to PostTypeId=1 is a reasonable interpretation because only question posts carry Tags, so it does not contradict the question.",
      "verdict": true,
      "evidence": "sql_result shows a single column named percentage (row 0), indicating the query returns the requested metric."
    }
  },
  {
    "question_id": 586,
    "result": {
      "expected_answer": "Display name(s) of the user(s) who awarded a bounty of 50 points on a post whose title contains the word \"variance\".",
      "sql_description": "Joins votes to posts and users, keeps only votes with BountyAmount = 50 and posts where Title LIKE '%variance%', returns the corresponding users' DisplayName.",
      "reason": "Query checks the required bounty amount (50) and filters posts with titles mentioning 'variance', then outputs the user display names, satisfying all explicit anchors in the question.",
      "verdict": true,
      "evidence": "sql_result shows DisplayName column with rows 0:'chl', 1:'shabbychef', matching the requested information."
    }
  },
  {
    "question_id": 474,
    "result": {
      "expected_answer": "A single integer: the count of distinct sets that (1) have at least one Italian translation and (2) have baseSetSize < 100.",
      "sql_description": "Joins cards, set_translations, and sets, filters for Italian translations and baseSetSize < 100, then counts DISTINCT card ids, i.e., number of cards, not sets.",
      "reason": "Question asks for number of qualifying sets, not cards. Query counts cards, so anchors the wrong entity and inflates the count.",
      "verdict": false
    }
  },
  {
    "question_id": 459,
    "result": {
      "expected_answer": "Name (optionally with cost) of the card that has the higher convertedManaCost when comparing \"Serra Angel\" and \"Shrine Keeper\".",
      "sql_description": "Fetches the two specified cards, orders them by convertedManaCost descending, and returns the first row (highest cost) with its cost value.",
      "reason": "Query restricts to the two candidate names, compares their convertedManaCost via ORDER BY DESC, and returns the top one, thus identifying which costs more. All required anchors (both names, cost comparison) are present.",
      "verdict": true,
      "evidence": "Returned columns: name='Serra Angel', convertedManaCost=5.0 (row 1)."
    }
  },
  {
    "question_id": 665,
    "result": {
      "expected_answer": "A single numeric value: the average monthly number of postLinks created during 2010 whose associated post has at most 2 answers (i.e., total such links in 2010 divided by 12).",
      "sql_description": "Counts distinct links per month where the LINK creation month comes from pl.CreationDate but the year constraint is applied to the POSTS creation date (p.CreaionDate LIKE '2010%'); returns one row per month with that count.",
      "reason": "1) The 2010 filter is applied to the post’s creation date, not the link’s creation date, so links outside 2010 can be included – key anchor violated.\n2) It outputs monthly counts instead of the required overall average, returning 8 rows instead of one value.\nTherefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 683,
    "result": {
      "expected_answer": "The percentage (0-100) of posts created in 2011 whose owners have reputation greater than 1000:  (posts with CreationDate in 2011 AND owner reputation >1000) / (all posts with CreationDate in 2011) * 100.",
      "sql_description": "Counts posts whose owners authored at least one 2011 post and divides by total posts in the entire table (all years), returning that percentage.",
      "reason": "The denominator is not limited to 2011, and the numerator includes posts from any year by qualifying owners. Thus the required 2011 time anchor on both counts is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 528,
    "result": {
      "expected_answer": "Pairs of (card name, format) for every card whose set is 'Hour of Devastation', limited to formats where the card’s legality status is 'Legal'.",
      "sql_description": "Joins cards with sets to keep only cards whose set name is 'Hour of Devastation', then joins legalities, filters rows where legality status is 'Legal', and outputs each card’s name along with each format where it is legal.",
      "reason": "Query applies the required set anchor, filters legality to 'Legal', and returns both requested fields (card name and legal format). This satisfies all explicit constraints of the question.",
      "verdict": true,
      "evidence": "Result columns: name, format (e.g., rows like ['Act of Heroism', 'commander'], ['Adorned Pouncer', 'legacy'], etc.), showing cards from Hour of Devastation with their legal formats."
    }
  },
  {
    "question_id": 530,
    "result": {
      "expected_answer": "A list of every card illustrated by Allen Williams together with each card’s frameVersion. Additionally, the answer should allow us to see which of those cards, if any, are banned (e.g., by flagging or listing them separately).",
      "sql_description": "Selects frameVersion and name from cards where artist = 'Allen Williams' AND the card’s uuid appears in legalities with status = 'Banned'; i.e., it returns ONLY cards by Allen Williams that are banned.",
      "reason": "Query omits Allen Williams cards that are NOT banned, so it does not list all frame styles and cards he worked on. It only performs the banned-card sub-task.",
      "verdict": false
    }
  },
  {
    "question_id": 206,
    "result": {
      "expected_answer": "The chemical element(s) of both atoms that participate in the bond whose bond_id is 'TR004_8_9'.",
      "sql_description": "Gets the element for every atom whose atom_id appears in the connected.atom_id field for rows where connected.bond_id = 'TR004_8_9'. It ignores the connected.atom_id2 column, so it only returns elements for the 'first' atom in each matching row.",
      "reason": "The question requires the elements of all atoms involved in the bond. The connected table stores the two atoms in atom_id and atom_id2. The query joins only through connected.atom_id, so if the table has the usual single row per bond, the element of the second atom (atom_id2) will be omitted. Therefore the query may miss an element and is logically incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 366,
    "result": {
      "expected_answer": "The rules text of the card “Benalish Knight” – i.e., the abilities printed on the card.",
      "sql_description": "Retrieves all originalText values from the cards table where name = 'Benalish Knight' and outputs them as the rule text.",
      "reason": "The query uses the correct card name anchor and returns the originalText field, which stores the printed rules. This satisfies the request for the card’s rule; extra NULL/duplicate rows do not contradict the question.",
      "verdict": true,
      "evidence": "rule_of_playing_card_Benalish_Knight rows include \"Flash (You may play this spell …)\" and \"First strike\\nYou may play Benalish Knight …\", matching the card’s rules."
    }
  },
  {
    "question_id": 344,
    "result": {
      "expected_answer": "Names of cards whose printing rarity is mythic and whose legality status is \"Banned\" in the gladiator format.",
      "sql_description": "Joins cards with legalities on uuid and returns the card names where cards.rarity = 'mythic', legalities.format = 'gladiator', and legalities.status = 'Banned'.",
      "reason": "All required anchors (rarity mythic, format gladiator, banned status) are present. Though duplicates appear because DISTINCT is not used, the query still correctly identifies the qualifying cards, so it satisfies the request.",
      "verdict": true,
      "evidence": "sql_result shows card_name column with mythic cards banned in gladiator, e.g., rows: 0:'Oko, Thief of Crowns', 2:'Nexus of Fate'."
    }
  },
  {
    "question_id": 213,
    "result": {
      "expected_answer": "The bond_type value of the bond linking atom TR004_8 with atom TR004_20 (either order).",
      "sql_description": "Attempts to get b.bond_type for bonds whose connected row matches the two atoms (both orders) and whose bond_id equals that in connected, but mistakenly joins bond and connected on b.molecule_id = c.bond_id, so the join drops the correct rows, returning nothing.",
      "reason": "Required anchor satisfied (atoms and bond_type) but wrong join (molecule_id vs bond_id) makes the query unable to find the bond, producing empty result; so it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 218,
    "result": {
      "expected_answer": "Percentage = 100 * (number of distinct carcinogenic (label = '+') molecules that have no atom with element = 'f') / (total number of carcinogenic molecules).",
      "sql_description": "Joins each molecule with its atoms, then keeps only rows where the atom is fluorine or NULL (from molecules that have no atoms). It then counts rows (not distinct molecules) where label = '+' and atom is NOT fluorine, divides by the number of distinct molecules remaining after the filter – which includes non-carcinogenic ones – to return a percentage.",
      "reason": "Key anchors are violated: (1) the query excludes carcinogenic molecules that possess non-fluorine atoms but no fluorine, so it misses the target set; (2) the numerator counts rows, not molecules, and evaluates to zero because the remaining rows are fluorine or NULL; (3) the denominator is all molecules after the flawed filter, not only carcinogenic ones. Thus it does not compute the requested percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 391,
    "result": {
      "expected_answer": "Names of cards whose originalType is exactly 'Artifact', whose colors list includes 'B' (black), and that have at least one non-English entry in foreign_data – i.e., black artifact cards with a foreign-language translation.",
      "sql_description": "Joins cards with foreign_data on uuid, keeps rows where originalType='Artifact', colors contains 'B', and language is not 'English'; outputs the card name (one row per foreign translation).",
      "reason": "All required anchors (artifact, black color, foreign translation) are correctly implemented. Extra duplicates arise from multiple translations but do not add unrelated cards, so the answer set is semantically correct.",
      "verdict": true,
      "evidence": "sql_result shows names like 'Executioner\\'s Capsule', 'Thopter Foundry', 'Time Sieve' in the card_name column, each meeting the stated filters."
    }
  },
  {
    "question_id": 412,
    "result": {
      "expected_answer": "The French-language foreign name(s) of all cards illustrated by Matthew D. Wilson that have type containing \"Creature\", a normal layout and a black border.",
      "sql_description": "Joins cards to foreign_data with language='French', filters for normal layout, black border, Creature type and the given artist, but then returns c.name (the English card name) instead of f.name (the French foreign name).",
      "reason": "Required anchor \"foreign name\" is not satisfied: query outputs the English card name from cards.name, not the French foreign_data.name.",
      "verdict": false
    }
  },
  {
    "question_id": 230,
    "result": {
      "expected_answer": "The chemical elements that make up molecule TR060 and the molecule’s carcinogenic label (‘+’ or ‘-’).",
      "sql_description": "Gets every atom belonging to molecule TR060, returning its element plus the label from the molecule table.",
      "reason": "Query filters by molecule_id=TR060, joins to obtain the label, and outputs the element and label. This directly provides the requested elements and label; duplicates of elements do not contradict the question.",
      "verdict": true,
      "evidence": "Result shows column element (values like c, h, o) and label (all ‘-’) for each atom row."
    }
  },
  {
    "question_id": 236,
    "result": {
      "expected_answer": "Return the bond_type and the two atom IDs (atom_id, atom_id2) for the specific bond whose bond_id is 'TR001_6_9'.",
      "sql_description": "Retrieves bond_type and connected atom IDs for every bond belonging to the molecule whose label is 'TR001_6_9'. It does not restrict to bond_id = 'TR001_6_9'.",
      "reason": "The question asks about the bond with ID 'TR001_6_9', but the SQL filters by molecule label, not by bond_id. The required bond_id anchor is missing, so it can return wrong or empty results.",
      "verdict": false
    }
  },
  {
    "question_id": 427,
    "result": {
      "expected_answer": "List of distinct languages in which cards from set code 'ARC' (whose MagicCardMarket name is 'Archenemy') are available.",
      "sql_description": "Retrieves DISTINCT foreign_data.language for cards whose setCode is 'ARC', by joining cards with sets (requiring sets.mcmName = 'Archenemy' and sets.code = cards.setCode) and foreign_data via uuid.",
      "reason": "Query applies both required anchors (mcmName = 'Archenemy', setCode = 'ARC') and returns the requested language values. Logic aligns with the question.",
      "verdict": true,
      "evidence": "Query projects one column language (none returned in sample run, but structure correct)."
    }
  },
  {
    "question_id": 407,
    "result": {
      "expected_answer": "A list of every card type (both supertypes and subtypes) for cards whose language is German; requires that both subtypes and supertypes be non-NULL.",
      "sql_description": "Returns DISTINCT values from the subtypes column for cards where subtypes and supertypes are not NULL, without any language filter and without including supertypes.",
      "reason": "Question requires all types (union of supertypes and subtypes) and implicitly limits to German cards. Query only retrieves subtypes, omits supertypes, and lacks any language constraint, so anchors are missing.",
      "verdict": false
    }
  },
  {
    "question_id": 416,
    "result": {
      "expected_answer": "A numeric percentage representing (French cards with power NULL or '*') divided by (all cards with power NULL or '*') times 100.",
      "sql_description": "Counts cards with NULL or '*' power only within French-language rows, then divides that count by the same count, yielding 100%.",
      "reason": "Denominator must include all cards without power irrespective of language. Query restricts both numerator and denominator to French, so percentage is always 100%, violating required anchor of total without-power cards.",
      "verdict": false
    }
  },
  {
    "question_id": 240,
    "result": {
      "expected_answer": "The chemical element symbols that appear in molecule TR004.",
      "sql_description": "Fetches the element value for every atom whose molecule_id equals 'TR004'.",
      "reason": "Correctly filters atoms of molecule TR004 and returns their element symbols. Although duplicates are included, the question does not explicitly require uniqueness, so the returned set still conveys all elements present.",
      "verdict": true,
      "evidence": "sql_result rows show element column with symbols such as s, n, o, c, h, p – all belonging to TR004."
    }
  },
  {
    "question_id": 462,
    "result": {
      "expected_answer": "The Italian translation(s) of the set(s) that contain the card named \"Ancestor's Chosen\".",
      "sql_description": "Looks up rows in cards with name 'Ancestor's Chosen', matches their setCode to set_translations, keeps only Italian language rows, and returns the translation (Italian set name).",
      "reason": "Satisfies all required anchors: filters by the specific card name, limits to Italian language, and outputs the set translation. Duplicate rows do not violate the question.",
      "verdict": true,
      "evidence": "italian_name_of_set rows: [0:'Set Base Decima Edizione',1:'Set Base Decima Edizione',2:'Sentenza']"
    }
  },
  {
    "question_id": 248,
    "result": {
      "expected_answer": "List of atoms (their IDs or at least their element symbols) that participate in any bond of type '#' within molecule TR041; i.e., the two atoms for every triple bond in that molecule, not all atoms of the molecule.",
      "sql_description": "Selects the element field of every atom whose molecule_id = 'TR041'. It joins to bond only through molecule_id and filters bond rows to bond_type '#', but does not tie the atom to a particular triple-bond row via bond_id. Thus any atom in TR041 is returned whenever the molecule has at least one triple bond.",
      "reason": "Missing anchor between bond and connected tables: atoms are not restricted to those in the triple bond(s). Query therefore over-includes atoms that are not part of any triple bond.",
      "verdict": false
    }
  },
  {
    "question_id": 473,
    "result": {
      "expected_answer": "A yes/no determination of whether the set(s) containing the card named \"Adarkar Valkyrie\" are marked as foreign-only (isForeignOnly = 1).",
      "sql_description": "Looks up all sets joined through cards where card name = 'Adarkar Valkyrie' and returns the isForeignOnly flag (plus the card name).",
      "reason": "The query correctly anchors on the card name and retrieves the isForeignOnly attribute of the associated set(s); this flag directly answers whether the set is only available outside the United States.",
      "verdict": true,
      "evidence": "sql_result shows name='Adarkar Valkyrie', isForeignOnly=0, indicating the relevant set is NOT foreign-only."
    }
  },
  {
    "question_id": 45,
    "result": {
      "expected_answer": "For every school that is administered by Ricci Ulrich, return the school name together with its average SAT writing score.",
      "sql_description": "Selects CDSCodes whose first administrator is Ricci Ulrich, joins those schools to their SAT records, and for each such school computes the average of AvgScrWrite, outputting School and the computed average.",
      "reason": "Anchors on administrator name, gets writing scores from satscores, aggregates by school; output corresponds exactly to requested list of schools with their average writing scores.",
      "verdict": true,
      "evidence": "sql_result columns: School, Average_Writing_Score; row0: Buchanan High 507.0"
    }
  },
  {
    "question_id": 529,
    "result": {
      "expected_answer": "Names of all sets that have at least one Korean translation record but have no Japanese translation record at all.",
      "sql_description": "Checks each set: left-joins to a Japanese translation row (st1) and a Korean translation row (st2). Keeps rows where the Japanese join returned NULL (no Japanese translation) and the Korean join returned a non-NULL translation (there is a Korean translation), then outputs the set name.",
      "reason": "The query precisely enforces the two anchors: absence of Japanese translation (st1 NULL) and presence of Korean translation (st2 not NULL). Minor duplicates are acceptable; no other constraints are violated.",
      "verdict": true,
      "evidence": "sql_result shows column [name] with two set names (rows 0-1), matching the requested output structure."
    }
  },
  {
    "question_id": 87,
    "result": {
      "expected_answer": "All administrator email addresses (valid format) for schools in San Bernardino County that belong to the district “San Bernardino City Unified”, opened between 2009-01-01 and 2010-12-31, and whose type is either a public Intermediate/Middle School (SOC = 62) or a Unified School (DOC = 54).",
      "sql_description": "Gets distinct AdmEmail1 values that look like valid emails for schools whose County is “San Bernardino”, City is “San Bernardino”, open date between 2009-01-01 and 2010-12-31, and SOC=62 or DOC=54.",
      "reason": "The question pinpoints the district “San Bernardino City Unified”, not merely any school whose City happens to be San Bernardino. The SQL omits the District filter, therefore can include/omit schools outside the specified district, violating an explicit anchor. All other conditions are handled, but the mandatory district anchor is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 201,
    "result": {
      "expected_answer": "Percentage = (number of carbon atoms) / (total number of atoms) within all molecules that contain at least one double bond, expressed as 0-100%.",
      "sql_description": "Counts how many atoms are carbon across double-bond molecules (numerator) but divides by the number of distinct molecules, not by the total atoms; joins may also duplicate atoms by bonding rows.",
      "reason": "Denominator anchor wrong: question/evidence requires COUNT(atom_id) but query uses COUNT(DISTINCT molecule_id), so result is not the requested percentage of carbon atoms.",
      "verdict": false
    }
  },
  {
    "question_id": 487,
    "result": {
      "expected_answer": "Percentage (0–100%) of cards in set 'Coldsnap' whose cardKingdomId AND cardKingdomFoilId are both non-NULL.",
      "sql_description": "Filters cards to setCode='CSP' (Coldsnap). Numerator adds COUNT(DISTINCT cardKingdomId) to COUNT(DISTINCT cardKingdomFoilId). Denominator is total card count in the set. No check that both columns are simultaneously non-NULL for a row.",
      "reason": "Required anchor “both cardKingdomId and cardKingdomFoilId not null” is violated. Query counts rows where either column is present and double-counts cards, producing impossible 200% result.",
      "verdict": false
    }
  },
  {
    "question_id": 518,
    "result": {
      "expected_answer": "Return the play format(s) that contain the most banned cards and list every banned card name within those format(s).",
      "sql_description": "Counts banned rows per (format, card) pair, compares each pair’s count to the maximum of those per-pair counts (typically 1), and outputs pairs whose individual count equals that maximum.",
      "reason": "The query measures duplicates for each single card instead of total banned cards per format; therefore it cannot identify the format with the greatest overall number of banned cards. Required anchor \"highest number of banned status per format\" is not computed, so result is unreliable.",
      "verdict": false
    }
  },
  {
    "question_id": 98,
    "result": {
      "expected_answer": "Return the account_id(s) (and optionally their loan amount) of those accounts that had at least one loan approved in 1997 with the minimum approved amount among all 1997 loans, restricted to accounts whose statement frequency is the weekly type ('POPLATEK TYDNE').",
      "sql_description": "Builds a list of loans approved in 1997 joined with the owning account to keep frequency, then filters rows whose amount equals the global minimum amount in that set and whose frequency is 'POPLATEK TYDNE'. Finally returns each qualifying account_id together with that minimum amount (named lowest_approved_amount).",
      "reason": "All required anchors—loan approval in 1997, global minimum loan amount, and weekly issuance frequency—are present and correctly enforced. Extra returned columns are acceptable. Query logic therefore satisfies the question.",
      "verdict": true,
      "evidence": "Result columns: account_id, lowest_approved_amount, frequency. An empty set simply means no such account exists in data, which is permissible."
    }
  },
  {
    "question_id": 215,
    "result": {
      "expected_answer": "A single integer: the count of distinct atoms whose element is iodine (i) or sulfur (s) that participate in a single ('-') bond, regardless of the element type of the atom they are bonded to.",
      "sql_description": "Counts distinct atoms (a.atom_id) where a.element is i or s, that are connected through a single bond (bond_type='-') to another atom a2 which is also required to be i or s.",
      "reason": "The SQL imposes an extra constraint that the *bonded partner* (a2) must also be iodine or sulfur. The question only asks for iodine/sulfur atoms in single bonds; it does not require the other atom in the bond to be of the same types. This additional filter can exclude valid atoms (e.g., iodine single-bonded to carbon), so the count may be understated.",
      "verdict": false
    }
  },
  {
    "question_id": 207,
    "result": {
      "expected_answer": "List (distinct) of all chemical element symbols that appear as either atom in any bond where bond_type = '=' (double bond). Both atoms in such bonds must be considered.",
      "sql_description": "Returns distinct element symbols of atoms whose atom_id appears in connected.atom_id (the first atom column) for bonds with bond_type='='.",
      "reason": "It only considers atoms stored in connected.atom_id and ignores those in connected.atom_id2, so elements that occur only as the second atom of a double bond are omitted. Required anchor: include both atoms in each double bond.",
      "verdict": false
    }
  },
  {
    "question_id": 228,
    "result": {
      "expected_answer": "Percentage of atoms in molecule TR206 that are hydrogen, expressed as a percentage with four decimal places.",
      "sql_description": "Counts hydrogen atoms in TR206, divides by total atoms in TR206, multiplies by 100 to produce the hydrogen percentage.",
      "reason": "SQL follows evidence formula: uses element='h' filter, molecule_id='TR206', divides by total atom count, converts to percent. Formatting (six decimals) exceeds required precision but still conveys correct value including at least four decimals, so accepted.",
      "verdict": true,
      "evidence": "sql_result.rows[0].percent = 45.454545"
    }
  },
  {
    "question_id": 197,
    "result": {
      "expected_answer": "A single numerical value: the average count of oxygen atoms for each molecule that is classified as single-bonded (bond_type = '-'). All molecules that satisfy the bond condition, even those with 0 oxygen atoms, must be included in the average.",
      "sql_description": "For every molecule that has at least one atom whose element = 'o' and also appears in the bond table with bond_type='-', it counts those oxygen atoms, then averages that count across those molecules. Molecules with no oxygen atoms are excluded from the calculation.",
      "reason": "The query omits single-bonded molecules that have zero oxygen atoms because it first filters the atom table with element='o'. Consequently the denominator of the average is smaller than it should be, giving a biased result. Required anchor (include all single-bonded molecules) is violated.",
      "verdict": false
    }
  },
  {
    "question_id": 219,
    "result": {
      "expected_answer": "Percentage of triple bonds among all bonds that belong to carcinogenic (+) molecules, i.e., (number of bonds with bond_type='#' in + molecules) / (total number of bonds in + molecules) * 100.",
      "sql_description": "Selects only triple bonds in carcinogenic molecules, then divides the count of DISTINCT bond ids by the total number of joined rows (connected-bond) in the same filtered set, returning one value called percent.",
      "reason": "Denominator should be all bonds in carcinogenic molecules, not just triple bonds. Because the query restricts rows to bond_type='#', both numerator and denominator concern only triple bonds, so it cannot produce the required proportion; it instead yields a misleading ratio influenced by join duplicates.",
      "verdict": false
    }
  },
  {
    "question_id": 36,
    "result": {
      "expected_answer": "Full name(s) (first + last) of every administrator of the school that has the greatest value of NumGE1500 (the highest count of students scoring 1500 or more on the SAT) in the whole dataset.",
      "sql_description": "Finds schools whose NumGE1500 is at least 1500, orders them by NumGE1500 descending, keeps the first one, then returns only the concatenation of AdmFName1 and AdmLName1 for that school.",
      "reason": "1) The >=1500 filter on NumGE1500 wrongly excludes any school whose high-score count is below 1500, so the selected school may not be the true maximum (and produced no rows).\n2) It returns only the first administrator instead of all up-to-three administrators requested by the question.\nRequired anchors (consider every school, give all administrators) are therefore missing.",
      "verdict": false
    }
  },
  {
    "question_id": 168,
    "result": {
      "expected_answer": "The percentage (0–100) of clients who opened their accounts in districts whose average salary (column A11 in the district table) exceeds 10000 that are female (gender = 'F'). Numerator: female clients in those districts. Denominator: all clients (any gender) in those districts.",
      "sql_description": "1) Builds a list of districts whose A11 average salary > 10000.\n2) Counts DISTINCT client_ids that are female and whose district appears in that list, multiplies by 100.\n3) Divides by a sub-count of DISTINCT female client_ids in the same set of districts (also filtered by gender='F').\nConsequently numerator and denominator are identical, so it always returns 100%.",
      "reason": "The denominator should include all clients in the qualifying districts, not only females. By restricting both numerator and denominator to gender='F', the query computes the share of women among women (always 100%), not the share of women among all clients. Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 239,
    "result": {
      "expected_answer": "The number of distinct bonds (bond_id) that involve an atom whose atom_id ends with \"_19\" (pattern TR%_19), counting bonds where that atom appears in either atom_id or atom_id2.",
      "sql_description": "Looks up the single atom_id that matches the pattern TR%_19, then counts DISTINCT bond_id in connected where that exact atom_id appears in either atom_id or atom_id2. Returns that count.",
      "reason": "All required anchors are present: it looks for atom 19 via the specified pattern (within a sub-query) and counts distinct bond_id connections where the atom is on either side. Since the sub-query produced exactly one atom_id in this database, the count (1) corresponds to the requested quantity. Although it would miss additional _19 atoms if they existed, the schema/run shows only one, so the query suffices under this reasonable interpretation.",
      "verdict": true,
      "evidence": "sql_result shows a single column num_connections with value 1 for that atom."
    }
  },
  {
    "question_id": 194,
    "result": {
      "expected_answer": "A list of clients who are owners (eligible for loans) and hold a high-level (gold) credit card, returning each client’s ID together with their age (in years).",
      "sql_description": "Retrieves client_id and birth_date from client records that have a related disp row of type OWNER and a related card of type 'gold'.",
      "reason": "Although the gold-card and OWNER anchors are satisfied, the query returns birth_date instead of the requested age; the required ‘age’ information is missing.",
      "verdict": false
    }
  },
  {
    "question_id": 47,
    "result": {
      "expected_answer": "A single numeric value: the total number of schools that opened in 1980 in Alameda County under DOC = 52, divided by 12 to give the average openings per month.",
      "sql_description": "Filters Alameda County schools with DOC = 52 that opened in 1980, groups them by opening month, counts distinct schools per month, then divides EACH month’s count by 12 and returns one row per month (opening_month, monthly_avg_opened_schools).",
      "reason": "Returns one row per month instead of a single overall average and divides monthly counts by 12, not the total count by 12. Thus the calculation and shape of the answer do not match the required single monthly average.",
      "verdict": false
    }
  },
  {
    "question_id": 232,
    "result": {
      "expected_answer": "The alphabetically first three molecule_id values of molecules that (1) are labelled '-' (non-carcinogenic) and (2) possess at least one bond of type '-' (a single bond).",
      "sql_description": "Builds list SingleBonds of molecules whose number of single bonds equals EXACTLY 1 (COUNT(*) = 1), then joins to molecule table, filters to label '-', orders by molecule_id and returns first 3.",
      "reason": "Question requires molecules that have at least one single bond; SQL restricts to molecules with exactly one single bond, excluding eligible molecules that contain multiple single bonds, so output may be incomplete.",
      "verdict": false
    }
  },
  {
    "question_id": 79,
    "result": {
      "expected_answer": "Identify which of the two counties – San Diego or Santa Barbara – has the greater number of exclusively-virtual schools (Virtual = 'F') and give that count.",
      "sql_description": "Counts schools with Virtual = 'F' in the two counties BUT only for schools that also appear in the frpm table; returns the county with the highest such count and the count itself.",
      "reason": "The extra condition requiring a matching frpm record is an invented constraint not stated in the question. It may exclude some virtual schools and can change which county appears to have the most, so the query does not reliably answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 247,
    "result": {
      "expected_answer": "The element values for all atoms whose atom_id does not appear in the connected table (i.e., atoms that form no bonds).",
      "sql_description": "Returns every atom whose atom_id is absent from connected.atom_id and outputs its atom_id together with its element value.",
      "reason": "Uses the provided definition of \"cannot bond\" (atom_id not in connected) and correctly retrieves the corresponding elements. Returning atom_id in addition to element is harmless and still fully answers the question.",
      "verdict": true,
      "evidence": "sql_result shows rows with columns atom_id, element, e.g., row0(atom_id=TR006_42, element=na), confirming retrieval of element values for non-bonding atoms."
    }
  },
  {
    "question_id": 92,
    "result": {
      "expected_answer": "Single number: how many districts have an average salary (column district.A11) for females that is >6000 and <10000.",
      "sql_description": "Counts distinct districts where the average transaction amount of female clients’ accounts is between 6000 and 10000. It groups by district, averages trans.amount, filters on gender='F', then outputs COUNT(DISTINCT district_id) (which equals 1) for every group, producing many rows of 1s.",
      "reason": "Uses trans.amount instead of district.A11 salary column; thus measures something unrelated to salary. Also returns one row per qualifying district instead of a single overall count. Missing required salary anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 12,
    "result": {
      "expected_answer": "The maximum (highest) percentage of students aged 5-17 who are eligible for free meals among schools whose SAT excellence rate (NumGE1500 / NumTstTakr) exceeds 0.3.",
      "sql_description": "1) Builds a list of CDSCodes where NumGE1500 / NumTstTakr > 0.3 in satscores (and NumTstTakr > 0). 2) Joins that list to frpm and selects the maximum value in column \"Percent (%) Eligible Free (Ages 5-17)\" (with Enrollment > 0).",
      "reason": "Query applies the required SAT excellence filter, then finds the highest eligible free rate (already stored as a percentage column) for ages 5-17. All explicit anchors are satisfied; computation aligns with the question.",
      "verdict": true,
      "evidence": "sql_result shows single column MAX(\"Percent (%) Eligible Free (Ages 5-17)\") = 0.904908 indicating the highest rate found."
    }
  },
  {
    "question_id": 263,
    "result": {
      "expected_answer": "Numeric percentage value: (number of atoms with element = 'cl' that participate in bonds of type '-' ) divided by (total atoms participating in bonds of type '-') *100.",
      "sql_description": "Finds molecules that have exactly one bond (regardless of bond type), then for all atoms in those molecules counts chlorine atoms and all atoms to compute a percentage.",
      "reason": "Missing required anchor bond_type='-'. Restricts to molecules with exactly one bond, which is not asked. Thus computes wrong population and percentage.",
      "verdict": false
    }
  },
  {
    "question_id": 281,
    "result": {
      "expected_answer": "A count of how many times each element (element symbols) appears as the 4th atom (identified by substring of atom_id having index 4, i.e. substr(atom_id,7,1)='4') among molecules whose label is '+'. Output: element with its tally.",
      "sql_description": "For molecules labelled '+', it first numbers all their atoms ordered lexicographically by atom_id and picks the atom whose row_number is 4 for each molecule, then counts these atoms by element.",
      "reason": "Question explicitly defines the 4th atom by substring pattern substr(atom_id,7,1)='4'. The query instead selects the 4th atom in lexicographic order per molecule, which can differ from the defined 4th atom (e.g., '_10' may precede '_2'). Thus the required anchor on atom_id substring is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 349,
    "result": {
      "expected_answer": "Return the card name and its artist for the card that has the highest number of rulings, plus an indication (Yes/No) of whether that card is a promotional printing.",
      "sql_description": "Counts rulings per card (uuid), keeps the uuid with the greatest count (LIMIT 1), joins to cards to output the card’s name, artist, and a Yes/No flag derived from cards.isPromo.",
      "reason": "Query correctly identifies the card with the maximum ruling count and supplies the requested fields, including promotional status. All explicit anchors—max ruling count and promo flag—are handled.",
      "verdict": true,
      "evidence": "Result columns: card='Teferi's Protection', artist='Chase Stone', isPromotionalPrinting='Yes' (row 0)."
    }
  },
  {
    "question_id": 125,
    "result": {
      "expected_answer": "For every district that has at least one loan contract still running with the client in debt (status = 'D'), return the district name and its state/region together with the percentage change in unemployment from 1995 (A12) to 1996 (A13), calculated as (A13 − A12)/A12 * 100.",
      "sql_description": "Joins loan → account → district, keeps only loans with status 'D', then outputs the district name (A2), state/region (A3), and the percentage unemployment increment computed from A12 and A13 for each matching loan row.",
      "reason": "All required anchors are met: status='D' filters the correct loan set; the query derives district and state from the district table; it computes the correct percentage formula using 1995 and 1996 rates. Duplicate rows per district are harmless, as the question does not demand uniqueness.",
      "verdict": true,
      "evidence": "Result contains columns [district, state, unemployment_increment] with values such as (row0) Strakonice | south Bohemia | 40.0, demonstrating correct computation and filtering."
    }
  },
  {
    "question_id": 17,
    "result": {
      "expected_answer": "A list of schools whose average SAT Writing score exceeds 499, ordered from highest to lowest average Writing score, displaying each school’s CharterNum (non-null only).",
      "sql_description": "Joins schools with satscores, keeps rows where AvgScrWrite > 499, groups by CharterNum, orders by the average writing score descending, and returns only CharterNum.",
      "reason": "Fails to enforce the explicit anchor that charter numbers must be non-null; the result includes a NULL CharterNum entry, so invalid charter numbers are not excluded.",
      "verdict": false
    }
  },
  {
    "question_id": 40,
    "result": {
      "expected_answer": "The phone number of the Fresno Unified school whose SAT reading average is the lowest among all schools in that district.",
      "sql_description": "Joins schools with satscores, keeps only records where schools.District = 'Fresno Unified', groups rows by school, orders the groups by the average AvgScrRead for each school in ascending order, and returns the Phone of the first (lowest-scoring) school.",
      "reason": "Query applies the correct district filter, computes per-school average reading score, orders to find the minimum, and returns that school’s phone number. Result therefore satisfies the question.",
      "verdict": true,
      "evidence": "sql_result shows one row with column Phone → “(559) 490-4290”, matching the requested information."
    }
  },
  {
    "question_id": 371,
    "result": {
      "expected_answer": "The numeric percentage (0–100) representing how many Story Spotlight cards have French language versions, calculated as (count of Story Spotlight cards in French) ÷ (total count of Story Spotlight cards) * 100.",
      "sql_description": "Builds a list of Story Spotlight card ids, then joins to foreign_data, keeps only rows where language = 'French', counts distinct ids, and divides that count by itself to output 100%.",
      "reason": "Denominator should be total Story Spotlight cards, but query restricts to French rows before both counts, so numerator and denominator are identical. Result is always 100%, violating the required percentage calculation anchor.",
      "verdict": false
    }
  },
  {
    "question_id": 145,
    "result": {
      "expected_answer": "Distinct client IDs of account holders who performed at least one credit-card withdrawal (operation = 'VYBER KARTOU') during 1998 whose withdrawal amount was below the average amount of such credit-card withdrawals in 1998.",
      "sql_description": "Computes the average amount of 1998 credit-card withdrawals, then returns distinct client IDs whose account has ANY transaction with amount lower than that average, regardless of its date or operation type.",
      "reason": "Missing required anchors: it does not constrain the selected transactions to 1998 or to operation 'VYBER KARTOU'. Therefore it can include clients without any 1998 credit-card withdrawals, violating the question’s conditions.",
      "verdict": false
    }
  },
  {
    "question_id": 402,
    "result": {
      "expected_answer": "A numeric percentage of cards that are both Story Spotlight (isStorySpotlight = 1) and have no text box (isTextless = 0) relative to all cards, plus the list of the IDs of those qualifying cards.",
      "sql_description": "Finds IDs of cards where isStorySpotlight = 1 and isTextless = 0, then appends a NULL row if any spotlight card fails that condition; no percentage is calculated.",
      "reason": "Query omits the required percentage and introduces an extraneous NULL row; thus it does not fully answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 173,
    "result": {
      "expected_answer": "1) The number of transactions in which account 3 requested an account statement (i.e., transactions whose purpose k_symbol corresponds to statement release). 2) The purpose (k_symbol) associated with all debit transactions whose amount totals 3539 for account 3.",
      "sql_description": "Counts rows for account_id=3 where type='S' and operation='INT_POS' (no k_symbol condition) and returns that as statement_count. Sums the amount of all rows for account_id=3 whose amount exactly equals 3539 and returns that sum as aim_total.",
      "reason": "Query fails to anchor on k_symbol to identify statement-release requests and instead relies on non-existent values in type/operation; thus the count is not the requested metric. For the second question it returns a numeric sum, not the aim/purpose (k_symbol). Required anchors on k_symbol and retrieval of purpose are missing.",
      "verdict": false
    }
  },
  {
    "question_id": 414,
    "result": {
      "expected_answer": "List of all languages in which the set with baseSetSize = 180 that is in the Ravnica block is translated.",
      "sql_description": "Finds all sets with exactly 180 cards (regardless of block), then returns the languages of all their translations.",
      "reason": "Required anchor \"block = 'Ravnica'\" is absent, so the query may include translations of 180-card sets from other blocks. Consequently, the result set is not guaranteed to pertain to the Ravnica block.",
      "verdict": false
    }
  },
  {
    "question_id": 120,
    "result": {
      "expected_answer": "List each account created between 1995 and 2000 whose owner lives in the region 'east Bohemia', showing the account_id together with the account’s statement issue frequency (value stored in account.frequency).",
      "sql_description": "Gets accounts whose creation date is 1995-2000, owned by a client whose district record has A6 = 'east Bohemia', then counts number of transactions per account (statement_frequency) and returns account_id with that count.",
      "reason": "1) Uses district.A6, which is a numeric field, not the region/area; thus the anchor 'east Bohemia' is unmatched.\n2) Returns a count of transactions instead of the account.frequency column that indicates statement-issuance frequency. Therefore key requested field is wrong.",
      "verdict": false
    }
  },
  {
    "question_id": 440,
    "result": {
      "expected_answer": "The language (e.g., Portuguese, Spanish, etc.) in which the foreign-language card name \"A Pedra Fellwar\" is printed.",
      "sql_description": "Looks up the uuid of a card whose ENGLISH name is 'A Pedra Fellwar' in cards, then returns the language(s) of foreign_data rows that share that uuid.",
      "reason": "The question concerns the foreign name 'A Pedra Fellwar'; the language must be identified via foreign_data.name='A Pedra Fellwar'. The query instead searches cards.name, so if the card's English name differs (very likely), no uuid is found, yielding empty output. Required anchor on foreign_data.name is missing, so the SQL does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 50,
    "result": {
      "expected_answer": "Return the postal (mailing/physical) street address and the actual name of the school that ranks 7th highest in AvgScrMath among all schools.",
      "sql_description": "Ranks schools by AvgScrMath descending, selects rows with rank 7, outputs the Street column as Postal_Street and a constant string \"School Name\".",
      "reason": "The query outputs a constant literal \"School Name\" instead of the real school name column, so the required school-name anchor is not satisfied.",
      "verdict": false
    }
  },
  {
    "question_id": 25,
    "result": {
      "expected_answer": "Funding types for those schools located in Riverside County whose SAT average-math score (the per-school ‚AvgScrMath‘ value) exceeds 400.",
      "sql_description": "Joins satscores with schools, keeps only records where the school is in Riverside County and the AvgScrMath value in that row is greater than 400, then returns the distinct FundingType values of those schools.",
      "reason": "All explicit anchors are satisfied: county = Riverside and AvgScrMath > 400. Interpreting “average of average math score” as the recorded per-school average math score (already an average) is reasonable and not contradicted. The query outputs the requested funding type(s); duplicates removal is harmless.",
      "verdict": true,
      "evidence": "sql_result has column FundingType with rows: None, Directly funded, Locally funded"
    }
  },
  {
    "question_id": 115,
    "result": {
      "expected_answer": "The percent of male clients (number of distinct male clients divided by total distinct clients, multiplied by 100) among the branch located in the South Bohemia region that has the largest number of inhabitants.",
      "sql_description": "1) Finds the single district in South Bohemia with the highest A4 (inhabitants). 2) Looks at all client-disp-account rows whose account belongs to that district and computes 100 * count(rows with gender='M') / count(all rows).",
      "reason": "The query counts rows produced by the client-disp-account join, not distinct clients, so clients with multiple dispositions/accounts are over-represented. The question explicitly asks for the percentage of male clients, which unambiguously refers to distinct clients. Missing DISTINCT anchor ⇒ incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 522,
    "result": {
      "expected_answer": "For every card whose edhrecRank equals 1, return each play format in which that card is BANNED – i.e., a list of (card name, format) pairs where status = 'Banned'.",
      "sql_description": "Gets all cards with edhrecRank = 1, joins to legalities, but returns only card name and the status value (renamed banned_play_format) without filtering to status = 'Banned' and without showing the format column.",
      "reason": "Fails two explicit anchors: it does not filter to status = 'Banned' and does not output the play format; instead it outputs the status values (Legal/Restricted/Banned). Therefore it does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 198,
    "result": {
      "expected_answer": "A single numeric value: the average number of single bonds (bond_type='-') per carcinogenic molecule (label='+').",
      "sql_description": "For each molecule (regardless of carcinogenicity) counts the number of single bonds, then takes the overall average of those counts.",
      "reason": "Required anchor label='+' (restricting to carcinogenic molecules) is missing, so the computed average includes non-carcinogenic molecules and does not answer the question.",
      "verdict": false
    }
  },
  {
    "question_id": 136,
    "result": {
      "expected_answer": "The number of loans approved between 1995-01-01 and 1997-12-31 whose amount is at least 250,000 and whose associated account has frequency = 'POPLATEK MESICNE'.",
      "sql_description": "Counts loans in the given date range and amount tied to accounts with monthly issuance BUT additionally restricts to loans with status = 'A'.",
      "reason": "The question does not limit loans by repayment status; all approved loans should be counted. Adding status = 'A' is an extra constraint that can omit valid loans (e.g., running contracts status 'C' or 'D'), so the query risks under-counting.",
      "verdict": false
    }
  },
  {
    "question_id": 152,
    "result": {
      "expected_answer": "A single scalar: the average 1995 crime count (A15) across all regions that (1) themselves have a 1995 crime count greater than 4000 and (2) possess at least one account whose opening date is on or after 1997-01-01.",
      "sql_description": "Builds a CTE of regions, averaging A15 over their districts, but keeps only regions whose accounts have transactions dated 1997-01-01 or later and whose total transaction amount exceeds 4000 and with ≥365 distinct transaction dates, then averages those regional A15 averages.",
      "reason": "Misses required anchors: (a) filters on SUM(trans.amount) > 4000 instead of A15 > 4000; (b) uses transaction dates rather than account opening dates for the 1997 condition. Therefore it does not correctly implement the question constraints.",
      "verdict": false
    }
  },
  {
    "question_id": 39,
    "result": {
      "expected_answer": "The average number of SAT test takers across schools in Fresno that opened in the year 1980.",
      "sql_description": "Joins satscores with schools, keeps rows where schools.City = 'Fresno' and OpenDate between 1980-01-01 and 1980-12-31, then returns AVG(NumTstTakr).",
      "reason": "Query satisfies key anchors: location (Fresno interpreted as city), open-year 1980, and computes the requested average of NumTstTakr. No extraneous or missing constraints.",
      "verdict": true,
      "evidence": "sql_result shows one column AvgNumTstTakers with value 203.8 for the specified filter."
    }
  },
  {
    "question_id": 77,
    "result": {
      "expected_answer": "List each Los Angeles-county school whose served grade span runs from Kindergarten (K) up through 9th grade and give, for each school, its Percent (%) Eligible FRPM (Ages 5-17).",
      "sql_description": "Joins schools with frpm by CDSCode, keeps rows where the FRPM record has Low Grade = 'K' and High Grade = '9' and the school record’s County is 'Los Angeles', then returns the School name together with the stored Percent (%) Eligible FRPM (Ages 5-17).",
      "reason": "All required anchors are present: Los Angeles county, grade span K–9 (checked via Low Grade/High Grade), and the requested FRPM percentage is returned. No extra or missing constraints.",
      "verdict": true,
      "evidence": "sql_result columns: School, Percent (%) Eligible FRPM (Ages 5-17); 0 rows returned, but structure matches the requested answer."
    }
  },
  {
    "question_id": 189,
    "result": {
      "expected_answer": "Account IDs belonging to female clients (gender = 'F') who are the oldest among all female clients (earliest birth_date) and whose average salary (column A11 from the district table linked through client.district_id) is the lowest among those oldest females (or overall, depending on interpretation).",
      "sql_description": "Builds a list of female clients, computes the average of their transaction amounts as \"avg_salary\", keeps all of them (the HAVING clause is ineffective), then returns account_ids whose birth_date is the minimum in that list AND whose computed avg_salary is also the minimum.",
      "reason": "Wrong salary source (uses avg(trans.amount) instead of A11), no join to district table, HAVING clause does not isolate oldest clients, and birth_date comparison uses MIN correctly but salary criterion is unrelated. Required anchors \"average salary (A11)\" and correct oldest logic are missing/incorrect.",
      "verdict": false
    }
  },
  {
    "question_id": 234,
    "result": {
      "expected_answer": "The number (count) of distinct bonds in molecule TR009 that involve atom 12 (atom id 'TR009_12').",
      "sql_description": "Counts distinct bond_id values from bond joined to connected where either atom_id or atom_id2 equals 'TR009_12'; additionally requires bond.molecule_id='TR009'.",
      "reason": "Query retrieves bonds involving atom 12 and, through the join, ensures they belong to molecule TR009 (the molecule_id filter is present). Parentheses around OR/AND are missing, but because 'TR009_12' uniquely implies molecule TR009, the count still correctly reflects bonds for that molecule. All required anchors (atom 12 involvement and molecule TR009) are met.",
      "verdict": true,
      "evidence": "sql_result shows num_bonds = 3."
    }
  },
  {
    "question_id": 48,
    "result": {
      "expected_answer": "A numeric ratio: (number of schools in Orange County whose StatusType is 'Merged' and DOC=54) divided by (number of schools in Orange County whose StatusType is 'Merged' and DOC=52).",
      "sql_description": "Computes ratio of ALL schools in Orange County with DOC=54 to ALL schools with DOC=52, ignoring StatusType.",
      "reason": "The question explicitly asks for merged schools; the SQL omits the StatusType='Merged' filter. Missing required anchor 'merged'.",
      "verdict": false
    }
  },
  {
    "question_id": 89,
    "result": {
      "expected_answer": "The count of distinct accounts whose issuance frequency is 'POPLATEK PO OBRATU' (issuance after transaction) and whose branch region (district.A3) is 'East Bohemia'.",
      "sql_description": "Counts distinct accounts that have at least one transaction with type = 'PRIJEM' and operation = 'VYDAJ' and whose clients belong to a district with region 'East Bohemia'. It ignores the account.frequency column entirely.",
      "reason": "Required anchor 'account.frequency = \"POPLATEK PO OBRATU\"' is missing; instead, unrelated transaction filters are used. Hence the query does not select the requested group of accounts.",
      "verdict": false
    }
  },
  {
    "question_id": 244,
    "result": {
      "expected_answer": "Yes or No (or + / -): whether the molecule that has the highest count of double bonds is carcinogenic.",
      "sql_description": "Returns every molecule that is labeled '+' and has at least one double bond; it does not determine which molecule has the most double bonds nor compare counts.",
      "reason": "Missing anchor: needs to identify the molecule(s) with the maximum number of double bonds before checking carcinogenicity; instead checks only for carcinogenic label and ignores counts, so it cannot answer the yes/no question.",
      "verdict": false
    }
  },
  {
    "question_id": 93,
    "result": {
      "expected_answer": "The number (count) of male clients whose district region is 'North Bohemia' and whose district average salary (A11) exceeds 8000.",
      "sql_description": "Selects male clients (gender='M') whose district (via client.district_id) has region 'North Bohemia' and average salary > 8000, counts DISTINCT client_ids to avoid duplicates created by joins through disp/account.",
      "reason": "All required anchors—male gender, region North Bohemia, district average salary >8000—are correctly filtered, and the query returns a distinct count of the relevant clients, matching the question’s demand.",
      "verdict": true,
      "evidence": "Result: column male_customers_with_avg_salary_gt_8000 = 0 (row 0)."
    }
  },
  {
    "question_id": 255,
    "result": {
      "expected_answer": "Percentage (with five decimal places) of all bonds with bond_type '-' that are in molecules labeled '+' (carcinogenic).",
      "sql_description": "Counts single bonds, counts how many of those belong to molecules with label '+', divides by total single bonds and multiplies by 100 to output the proportion as a percentage.",
      "reason": "Query filters to bond_type '-', evaluates carcinogenic label '+', computes (carcinogenic single bonds / total single bonds)*100. All required anchors present; five-decimal formatting is presentation, not logic.",
      "verdict": true,
      "evidence": "sql_result row 0: proportion_of_carcinogenic_bonds = 39.752034"
    }
  },
  {
    "question_id": 138,
    "result": {
      "expected_answer": "Count of male clients (gender='M') whose accounts are in the district(s) that have the second-highest value of A15 (number of committed crimes in 1995).",
      "sql_description": "Finds district(s) whose A15 equals the maximum value of A15 (highest crimes), then counts distinct male clients linked through accounts in those districts.",
      "reason": "The query targets the district with the highest, not the second-highest, number of crimes (A15). Missing the explicit second-highest anchor, so it answers a different question.",
      "verdict": false
    }
  },
  {
    "question_id": 31,
    "result": {
      "expected_answer": "Eligible free rate (percent of students eligible for free meals) for the two schools that rank 10th and 11th in highest K-12 enrollment.",
      "sql_description": "Filters frpm to schools whose low grade is 1 and high grade is 12, ranks them by Enrollment (K-12) in descending order using ROW_NUMBER, then returns the School Name and Percent (%) Eligible Free (K-12) for ranks 10 and 11.",
      "reason": "Query correctly applies grade-range filter, orders by enrollment to obtain 10th and 11th largest, and returns the requested eligible free rates. All anchors satisfied.",
      "verdict": true,
      "evidence": "Returned columns: School Name, Percent (%) Eligible Free (K-12); rows correspond to ranks 10 and 11."
    }
  },
  {
    "question_id": 149,
    "result": {
      "expected_answer": "Names of disposition/account types other than 'OWNER' (i.e., loan-ineligible) that appear on accounts whose district average salary (A11) is > 8000 and <= 9000.",
      "sql_description": "Looks across disp → account → district, filters rows where type is not 'OWNER' and district.A11 is between 8000 and 9000, then returns DISTINCT type values.",
      "reason": "Query applies the required salary range, excludes the loan-eligible type 'OWNER', and outputs the distinct remaining types. All anchors (salary bounds, non-OWNER) are present; returning distinct types satisfies the requested listing.",
      "verdict": true,
      "evidence": "sql_result shows column account_type with value 'DISPONENT' (row 0)."
    }
  },
  {
    "question_id": 186,
    "result": {
      "expected_answer": "The proportion (in percent) of clients with weekly statement frequency ('POPLATEK TYDNE') who are male, i.e. 100 * male weekly-requesting clients / all weekly-requesting clients.",
      "sql_description": "Finds all clients whose accounts have frequency = 'POPLATEK TYDNE', counts distinct clients per gender, then divides the male count by the overall count and multiplies by 100 to return the percentage.",
      "reason": "Query applies the required weekly-statement anchor and computes the male share among those clients, matching the evidence’s definition of the desired percentage.",
      "verdict": true,
      "evidence": "Result set has column percentage_male_clients_weekly_requests with value ≈52.13% (row 0)."
    }
  },
  {
    "question_id": 169,
    "result": {
      "expected_answer": "Percentage growth from 1996 to 1997 in the summed loan amounts taken by male clients (gender = 'M'):  (total 1997 − total 1996) / total 1996 * 100.",
      "sql_description": "For each account, the query sums loan amounts in 1996 and 1997, but first joins loan→disp→client keeping every row where the linked client is male; it then aggregates by account_id (but after the join) and finally computes ((Σ1997−Σ1996)/Σ1996)*100.",
      "reason": "The join duplicates a loan when an account has more than one male disposition, so each loan can be counted multiple times. This inflates the yearly totals and the resulting growth rate, violating the ‘total amount across all accounts’ anchor which implies each loan should be counted once regardless of how many male clients are linked.",
      "verdict": false
    }
  },
  {
    "question_id": 41,
    "result": {
      "expected_answer": "For each county, find schools ranked by average SAT reading score. Return the school names of those whose virtual instruction type is 'F' (exclusively virtual) and whose county-wide rank, measured against ALL schools in that county, is 5 or better.",
      "sql_description": "Filters schools to Virtual='F', then (among this already-filtered subset) ranks them by AvgScrRead within each county and keeps those with row_number≤5; returns their names.",
      "reason": "Ranking is computed only among virtual schools because the WHERE filter precedes the window function. The question requires the virtual schools that are top-5 when compared to every school in their county, not just other virtual ones. Thus some returned schools could be outside the true county-wide top 5.",
      "verdict": false
    }
  },
  {
    "question_id": 62,
    "result": {
      "expected_answer": "A single integer: the count of unique schools (CDSCode) in Los Angeles County that are not charter (Charter = 0) whose percent of eligible free meals for grades 1-12 is below 0.18 %.",
      "sql_description": "Counts all rows in the join of schools and frpm where County Name is Los Angeles, Charter School (Y/N)=0 and Percent Eligible Free (K-12) <0.18, returning 201.",
      "reason": "It counts table rows, not distinct schools. Because frpm contains one record per school per academic year, the query can count the same school multiple times, inflating the total. The question asks for the number of schools, requiring DISTINCT CDSCode.",
      "verdict": false
    }
  },
  {
    "question_id": 119,
    "result": {
      "expected_answer": "Return each account opened (or at least existing) in 1993 whose statement frequency is 'POPLATEK PO OBRATU' (meaning statement is issued after each transaction), showing account_id together with the related district name (A2) and region (A3).",
      "sql_description": "Finds accounts that have a transaction dated in 1993 occurring after the account-opening date, then lists those accounts’ district name and region.",
      "reason": "The query never checks the required anchor that the account’s statement frequency is 'POPLATEK PO OBRATU'; instead it substitutes an unrelated condition (transaction date > account date). Therefore it does not guarantee the accounts actually have statements issued after transactions, violating an explicit requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 85,
    "result": {
      "expected_answer": "For each school whose administrator’s first name is Alusine, return its District Code together with the Percent (%) Eligible Free (K-12) value (i.e., Free Meal Count (K-12) / Enrollment (K-12) * 100%).",
      "sql_description": "Finds schools with AdmFName1 = 'Alusine' and returns only their District Code from the frpm table; it neither computes nor returns the Percent (%) Eligible Free (K-12).",
      "reason": "The query omits the requested Percent (%) Eligible Free (K-12) value, returning only District Code, so it does not fulfill the question requirements.",
      "verdict": false
    }
  },
  {
    "question_id": 95,
    "result": {
      "expected_answer": "Account numbers of the client(s) whose birth date is the most recent (youngest) and who have the highest average salary (average of trans.amount).",
      "sql_description": "Computes average trans.amount per client, then selects account_id where the client’s birth_date equals the global MIN(birth_date) (i.e., the earliest/oldest person) and keeps only the top average-salary one among them.",
      "reason": "Anchor error: youngest should correspond to the most recent (MAX) birth_date, but the query uses MIN(birth_date), yielding the oldest clients. Therefore it does not satisfy the question’s requirement.",
      "verdict": false
    }
  },
  {
    "question_id": 129,
    "result": {
      "expected_answer": "The ten districts with the largest totals of non-credit-card withdrawals (type = 'VYDAJ') that occurred during January 1996, reported as district names (A2) and their summed withdrawal amounts.",
      "sql_description": "Filters trans rows to type='VYDAJ' and dates like '1996-01%', joins to account and district, sums the amounts per district, orders the sums descending, and outputs the top 10 district names with their total withdrawals.",
      "reason": "Meets all explicit anchors: restricts to type='VYDAJ' (evidence defines this as non-credit-card), limits dates to January 1996, groups results by district name, orders by total withdrawal amount, and returns the top ten. This satisfies a reasonable interpretation of \"top ten withdrawals … by district names\" as top ten districts by total withdrawals.",
      "verdict": true,
      "evidence": "sql_result has 10 rows with columns district_name and total_withdrawals, e.g., row0 district_name='Hl.m. Praha', total_withdrawals=6757078."
    }
  },
  {
    "question_id": 159,
    "result": {
      "expected_answer": "All transaction records representing withdrawals in cash (operation = 'VYBER') made by the client with id 3356; should list every such transaction with its details.",
      "sql_description": "Joins trans with disp on account_id, keeps rows where disp.client_id = 3356 and trans.operation = 'VYBER', returning the full transaction details.",
      "reason": "Query applies required client filter (3356) and withdrawal-in-cash filter (operation 'VYBER'); returns the matching transactions, exactly what the question asks.",
      "verdict": true,
      "evidence": "sql_result shows 20 rows with columns trans_id, account_id, date, type, operation (all 'VYBER'), amount, etc., confirming correct filtering."
    }
  },
  {
    "question_id": 192,
    "result": {
      "expected_answer": "The numeric average of the approved loan amounts for all loans whose repayment status is running (status C or D) and whose account has statement-issuance transactions (k_symbol = 'POPLATEK PO OBRATU'). Each qualifying loan should be counted once.",
      "sql_description": "Builds a list of running-status loans, joins them to any transaction on the same account that has k_symbol = 'POPLATEK PO OBRATU', then takes AVG(amount) over the resulting rows (without DISTINCT).",
      "reason": "The join may duplicate a loan once for every matching transaction, so the AVG is weighted by the number of such transactions rather than by loans. The question asks for the average across loans, not across (loan, transaction) pairs. A DISTINCT around the loan amounts (or aggregation per loan before averaging) is required but missing.",
      "verdict": false
    }
  }
]